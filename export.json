[
{"author": ["ConfGuru"], "date": [" 9 июня в 04:50"], "hubs": ["Разработка веб-сайтов", "ReactJS", "Lua", "Angular", "Блог компании DevConf"], "type_label": [], "text": "17 июня в Москве, Измайлово пройдет конференция Devconf::FrontEnd Откроет ее Виталий Грин, лидер Frontend разработки Альфа Лаборатории, Ex-Яндекс.Карты, который расскажет как сделать общую библиотеку компонентов с одной стороны стабильной для десятков команд, а с другой стороны гибкой и расширяемой Сергей Аверин, tech-менеджер из компании Acronis поведает о том, как важен правильный выбор JS-фреймоврка для крупного проекта в условиях, когда любое более-менее важное технологическое решение сразу затрагивает с десяток команд, несколько сотен человек и права «случайно все сломать» нет. Алексей Фомкин выступит с холиварным докладом — как вернуть фронтенд на сервер Алексей Охрименко, один из организаторов Angular митапа, автор дизайн паттерна MALEVICH и PEG парсера SimplePEG расскажет про Angular 4 Дмитрий Пацура, разработчик ReactJS, React Native, Zephir Language & Phalcon Framework начнет с обзора архитектуры React Native до грамотного построения приложения на нем. Григорий Петров, технический евангелист Voximplant, поделится опытом насчет ReactVR и WebVR и где его можно использовать, также про JavaScript технологии, полезные в VR: WebRTC Дмитрий Шуранов, фронтэнд-разработчик из Туту.ру обсудит что заставляет браузер пропускать фреймы? Заканчивает секцию встреча разработчиков Lua-in-Moscow Заявленные темы встречи: Быстрое прототипирование функциональных макетов UI на Lua и Mermaid.js Вжух — и написал кроссплатформенную игру. Архитектура бэкенда нагруженной игры на C++ и Lua Как и зачем LuaJIT нарушает DRY? Вопросы по конференции в официальном чате Telegram https://t.me/devconfru До встречи на конференции сообществ разработчиков DevConf 2017!", "image": ["https://habrastorage.org/web/995/30e/ba4/99530eba4ac84a83a351a5531c2beab3.png"], "tag": ["angularjs", "react.js", "reactnative", "lua", "luajit", "встречи разработчиков"], "rating": ["+34"], "bookmarks": ["24"], "views": ["5,8k"], "comments_count": ["5"]},
{"author": ["lera_alfimova"], "date": ["28 июля в 14:43"], "hubs": ["Разработка под iOS", "Разработка под Android", "Разработка игр", "Lua", "Блог компании Appodeal"], "type_label": [], "text": "Партнеры и друзья Appodeal, Corona Labs совместно с Defold и DevGAMM Минск, объявляют о старте геймджема #CoronaDefoldJam на базе Lua. Джем пройдет с 28 июля по 30 сентября 2017 на платформе itch.io. Требование к участникам только одно — игры в рамках джема должны быть созданы на Corona или Defold. Если вы никогда не использовали эти движки, не страшно: обе платформы просты для изучения и обладают очень дружелюбными сообществами, которые всегда помогут разобраться. В общем, #CoronaDefoldJam — идеальный повод освоить новые инструменты для создания игр; тем более, что джем поддерживает легендарный Джон Ромеро. Правила джема разрешают использовать готовые архивы (например, вот этот), однако игра должна быть создана специально для #CoronaDefoldJam. Еще из хороших новостей — джем стартует вместе с Ludum Dare 39 и будет иметь с ним общую тему. Она появится на странице джема 28-29 июля. Itch.io позволит продвигать игры в широком международном кругу разработчиков и любителей indie. Джем — отличная возможность наконец взяться за разработку игры, о которой вы давно думали. К тому же, организаторы обещают призы: 10 000 установок от Corona с рекламной кампанией в 25 000+ приложениях по всему миру для лучшей игры на Corona; Для всех победителей — возможность выставляться с созданной игрой на DevGAMM Минск (16-17 ноября 2017), где и состоится церемония награждения; Wacom Intuous Pro за лучший арт на Corona; Шведские наушники JAYS ручной сборки за лучшую игру на Defold; Три Amazon Echo Dot за лучшие технологии на Defold; Кредиты для Steam или itch.io на выбор + лицензии Spine ESS. Подробнее с условиями можно ознакомиться по ссылке. Все вопросы вы можете задать организаторам через почту: oleg@gamesjam.org, в твиттере с хэштегом #CoronaDefoldJam или в секции “коммьюнити” на itch.io. Slack Defold Slack Corona", "image": ["https://habrastorage.org/web/b43/9b7/6cc/b439b76cc1e4472294b8cad22fb1dcec.png", "https://habrastorage.org/web/820/9e6/446/8209e64469d640dfb302a2c541039dc7.png"], "tag": ["game development", "game dev", "gamesjam", "devgamm", "corona sdk", "defold"], "rating": ["+13"], "bookmarks": ["17"], "views": ["3,9k"], "comments_count": ["2"]},
{"author": ["relevance_17"], "date": [" 1 августа в 12:29"], "hubs": ["Open source", "NoSQL", "Lua", "Блог компании Mail.Ru Group"], "type_label": ["Tutorial"], "text": "Привет, Хабр! Сегодня я хочу поделиться с вами опытом написания приложений для Tarantool 1.7. Этот цикл статей будет полезен тем, кто уже собирается использовать Tarantool в своих проектах, либо тем, кто ищет новое решение для оптимизации проектов. Весь цикл посвящен рассмотрению уже существующего приложения на Tarantool. В этой части будут описаны вопросы установки Tarantool, хранения данных и обращения к ним, а также некоторые хитрости написания хранимых процедур. Tarantool — это NoSQL база данных, которая хранит данные в памяти либо на диске (в зависимости от подсистемы хранения). Хранилище персистентно за счет продуманного механизма write ahead log. В Tarantool встроен LuaJIT (Just-In-Time Compiler), позволяющий исполнять код на Lua. Также можно писать хранимые процедуры на C. Содержание цикла «Приложения для Tarantool 1.7» — Часть 1. Хранимые процедуры — Часть 2. OAuth2-авторизация — Часть 3. Тестирование и запуск Зачем создавать свои приложения для Tarantool Есть две причины: Это ускорит работу сервиса. Обработка данных на стороне хранилища сокращает объем передаваемых данных, а объединение нескольких запросов в одну хранимую процедуру позволит сэкономить на сетевых задержках. Готовые приложения можно переиспользовать. Сейчас экосистема Tarantool активно развивается, появляются новые opensource-приложения на Tarantool, часть которых со временем переносится в сам Tarantool. Такие модули позволяют создавать новые сервисы быстрее. Конечно, у такого подхода есть и недостатки. Tarantool не может утилизировать все ресурсы многоядерного процессора, поэтому для масштабирования сервиса придется позаботиться о шардировании хранилища, а также о соответствующей архитектуре проекта. Однако при росте числа запросов такой подход позволит легко масштабировать нагрузку. Рассмотрим, как было создано одно из приложений для Tarantool. Оно реализует API для регистрации и аутентификации пользователей. Функционал приложения: регистрация и аутентификация по email в два этапа: создание аккаунта, подтверждение аккаунта с установкой пароля; регистрация через социальные сети (FB, VK, Google+); возможность восстановить пароль. В качестве примера написания хранимой процедуры Tarantool мы разберем первый этап регистрации по email — получение кода подтверждения. Чтобы оживить примеры, можно воспользоваться исходным кодом, который доступен на github. Поехали! Установка Tarantool О том, как установить Tarantool, прочитайте в документации. Например, для Ubuntu нужно выполнить в терминале: curl http://download.tarantool.org/tarantool/1.7/gpgkey | sudo apt-key add - release=`lsb_release -c -s` sudo apt-get -y install apt-transport-https sudo rm -f /etc/apt/sources.list.d/*tarantool*.list sudo tee /etc/apt/sources.list.d/tarantool_1_7.list <<- EOF deb http://download.tarantool.org/tarantool/1.7/ubuntu/ $release main deb-src http://download.tarantool.org/tarantool/1.7/ubuntu/ $release main EOF sudo apt-get update sudo apt-get -y install tarantool Проверим, что установка прошла успешно, вызвав в консоли tarantool и запустив интерактивный режим работы. $ tarantool version 1.7.3-202-gfe0a67c type 'help' for interactive help tarantool> Здесь можно попробовать свои силы в программировании на Lua. Если сил нет, то наберитесь их в этом небольшом tutorial. Регистрация по email Идем дальше. Напишем первый скрипт, позволяющий создать пространство (space) с пользователями. Space — это аналог таблиц для хранения данных. Cами данные хранятся в виде кортежей (tuple). Space должен содержать один первичный (primary) индекс, в нем также может быть несколько вторичных (secondary) индексов. Индекс бывает и по одному ключу, и сразу по нескольким. Tuple представляет собой массив, в котором хранятся записи. Рассмотрим схему space’ов сервиса аутентификации: Как видно из схемы, мы используем индексы двух типов: hash и tree. Hash-индекс позволяет находить кортежи по полному совпадению первичного ключа и обязан быть уникальным. Tree-индекс поддерживает неуникальные ключи, поиск по первой части составного индекса и позволяет оптимизировать операции сортировки по ключу, так как значения в индексе хранятся упорядоченно. В space session хранится ключ (session_secret), которым подписывается сессионная кука. Хранение ключей сессий позволяет разлогинивать пользователей на стороне сервиса, если нужно. Сессия имеет опциональную ссылку на space social. Это необходимо для валидации сессий пользователей, входящих через социальные сети (проверки валидности хранимого OAuth2-токена). Перейдем к написанию приложения. Для начала рассмотрим структуру будущего проекта: tarantool-authman ├── authman │ ├── model │ │ ├── password.lua │ │ ├── password_token.lua │ │ ├── session.lua │ │ ├── social.lua │ │ └── user.lua │ ├── utils │ │ ├── http.lua │ │ └── utils.lua │ ├── db.lua │ ├── error.lua │ ├── init.lua │ ├── response.lua │ └── validator.lua └── test ├── case │ ├── auth.lua │ └── registration.lua ├── authman.test.lua └── config.lua Модули в Lua импортируются из путей, указанных в package.path переменной. В нашем случае модули импортируются относительно текущей директории, т. е. tarantool-authman. Однако при необходимости пути импорта можно дополнить: lua -- Добавляем новый путь с самым высоким приоритетом (в начало строки) package.path = \"/some/other/path/?.lua;\" .. package.path Прежде чем мы создадим первый space, вынесем необходимые константы в модели. Каждый space и каждый индекс должен определить свое название. Также необходимо определить порядок хранения полей в кортеже. Так выглядит модель пользователя authman/model/user.lua: -- Наш модуль — это Lua-таблица local user = {} -- Модуль содержит единственную функцию — model, которая возвращает таблицу с полями и методами модели -- На входе функция принимает конфигурацию в виде опять же lua-таблицы function user.model(config) local model = {} -- Название спейса и индексов model.SPACE_NAME = 'auth_user' model.PRIMARY_INDEX = 'primary' model.EMAIL_INDEX = 'email_index' -- Номера полей в хранимом кортеже (tuple) -- Индексация массивов в Lua начинается с 1 (!) model.ID = 1 model.EMAIL = 2 model.TYPE = 3 model.IS_ACTIVE = 4 -- Типы пользователя: email-регистрация или через соцсеть model.COMMON_TYPE = 1 model.SOCIAL_TYPE = 2 return model end -- Возвращаем модуль return user В случае с пользователями нам понадобится два индекса. Уникальный по id и неуникальный по email, так как, регистрируясь через социальные сети, два разных пользователя могут получить одинаковый email либо не получить email вовсе. Уникальность email для пользователей, зарегистрировавшихся не через социальные сети, обеспечим логикой приложения. Модуль authman/db.lua содержит метод для создания space’ов: local db = {} -- Импортируем модуль и вызываем функцию model -- При этом в параметр config попадает nil — пустое значение local user = require('authman.model.user').model() -- Метод модуля db, создающий пространства (space) и индексы function db.create_database() local user_space = box.schema.space.create(user.SPACE_NAME, { if_not_exists = true }) user_space:create_index(user.PRIMARY_INDEX, { type = 'hash', parts = {user.ID, 'string'}, if_not_exists = true }) user_space:create_index(user.EMAIL_INDEX, { type = 'tree', unique = false, parts = {user.EMAIL, 'string', user.TYPE, 'unsigned'}, if_not_exists = true }) end return db В качестве id пользователя берем uuid, тип индекса hash, ищем по полному совпадению. Индекс для поиска по email состоит из двух частей: (user.EMAIL, 'string') — email, (user.TYPE, 'unsigned') — тип пользователя. Типы были определены ранее в модели. Составной индекс позволяет искать не только по всем полям, но и по первой части индекса, поэтому доступен поиск только по email (без типа пользователя). Теперь запустим интерактивную консоль Tarantool в директории с проектом и попробуем воспользоваться модулем authman/db.lua. $ tarantool version 1.7.3-202-gfe0a67c type 'help' for interactive help tarantool> db = require('authman.db') tarantool> box.cfg({listen=3331}) tarantool> db.create_database() Отлично, первый space создан! Внимание: перед обращением к box.schema.space.create необходимо сконфигурировать и запустить сервер методом box.cfg. Теперь рассмотрим несколько простых действий внутри созданного space: -- Создание пользователей tarantool> box.space.auth_user:insert({'user_id_1', 'exaple_1@mail.ru', 1}) --- - ['user_id_1', 'exaple_1@mail.ru', 1] ... tarantool> box.space.auth_user:insert({'user_id_2', 'exaple_2@mail.ru', 1}) --- - ['user_id_2', 'exaple_2@mail.ru', 1] ... -- Получие Lua-таблицы (массива) всех пользователей tarantool> box.space.auth_user:select() --- - - ['user_id_2', 'exaple_2@mail.ru', 1] - ['user_id_1', 'exaple_1@mail.ru', 1] ... -- Получение пользователя по первичному ключу tarantool> box.space.auth_user:get({'user_id_1'}) --- - ['user_id_1', 'exaple_1@mail.ru', 1] ... -- Получение пользователя по составному ключу tarantool> box.space.auth_user.index.email_index:select({'exaple_2@mail.ru', 1}) --- - - ['user_id_2', 'exaple_2@mail.ru', 1] ... -- Обновление данных с заменой второго поля tarantool> box.space.auth_user:update('user_id_1', {{'=', 2, 'new_email@mail.ru'}, }) --- - ['user_id_1', 'new_email@mail.ru', 1] ... Уникальные индексы ограничивают вставку неуникальных значений. Если необходимо создавать записи, которые уже могут находиться в space, воспользуйтесь операцией upsert (update/insert). Полный список доступных методов можно найти в документации. Обновим модель пользователя, добавив функционал, позволяющий нам зарегистрировать его: function model.get_space() return box.space[model.SPACE_NAME] end function model.get_by_email(email, type) if validator.not_empty_string(email) then return model.get_space().index[model.EMAIL_INDEX]:select({email, type})[1] end end -- Создание пользователя -- Поля, не являющиеся частями уникального индекса, необязательны function model.create(user_tuple) local user_id = uuid.str() local email = validator.string(user_tuple[model.EMAIL]) and user_tuple[model.EMAIL] or '' return model.get_space():insert{ user_id, email, user_tuple[model.TYPE], user_tuple[model.IS_ACTIVE], user_tuple[model.PROFILE] } end -- Генерация кода, который отправляется в письме, с просьбой активировать аккаунт -- Как правило, такой код подставляется GET-параметром в ссылку -- activation_secret — один из настраиваемых параметров при инициализации приложения function model.generate_activation_code(user_id) return digest.md5_hex(string.format('%s.%s', config.activation_secret, user_id)) end В приведенном фрагменте кода применены два стандартных модуля Tarantool — uuid и digest, а также один пользовательский — validator. Перед использованием их необходимо импортировать: -- Стандартные модули Tarantool local digest = require('digest') local uuid = require('uuid') -- Модуль нашего приложения (отвечает за валидацию данных) local validator = require('authman.validator') Переменные объявляются с оператором local, ограничивающим область видимости переменной текущим блоком. В противном случае переменная будет глобальной, чего следует избегать из-за возможного конфликта имен. А теперь создадим основной модуль authman/init.lua. В этом модуле будут собраны все методы api приложения. local auth = {} local response = require('authman.response') local error = require('authman.error') local validator = require('authman.validator') local db = require('authman.db') local utils = require('authman.utils.utils') -- Модуль возвращает единственную функцию — api, которая конфигурирует приложение и возвращает его function auth.api(config) local api = {} -- Модуль validator содержит проверки различных типов значений -- Здесь же выставляются значения по умолчанию config = validator.config(config) -- Импортируем модели для работы с данными local user = require('authman.model.user').model(config) -- Создаем space db.create_database() -- Метод api создает неактивного пользователя с указанным адресом электронной почты function api.registration(email) -- Перед работой с email — приводим его к нижнему регистру email = utils.lower(email) if not validator.email(email) then return response.error(error.INVALID_PARAMS) end -- Проверяем, нет ли существующего пользователя с таким email local user_tuple = user.get_by_email(email, user.COMMON_TYPE) if user_tuple ~= nil then if user_tuple[user.IS_ACTIVE] then return response.error(error.USER_ALREADY_EXISTS) else local code = user.generate_activation_code(user_tuple[user.ID]) return response.ok(code) end end -- Записываем данные в space user_tuple = user.create({ [user.EMAIL] = email, [user.TYPE] = user.COMMON_TYPE, [user.IS_ACTIVE] = false, }) local code = user.generate_activation_code(user_tuple[user.ID]) return response.ok(code) end return api end return auth Отлично! Теперь пользователи смогут создавать аккаунты. tarantool> auth = require('authman').api(config) -- Воспользуемся api для получения кода регистрации tarantool> ok, code = auth.registration('example@mail.ru') -- Этот код необходимо передать пользователю на email для активации аккаунта tarantool> code 022c1ff1f0b171e51cb6c6e32aefd6ab На этом все. В следующей части рассмотрим использование готовых модулей, сетевое взаимодействие и реализацию OAuth2 в tarantool-authman.", "image": ["https://habrastorage.org/web/6bc/a42/ca2/6bca42ca2fc74d00923ad3348e4cdb09.png", "https://habrastorage.org/web/7b7/387/2de/7b73872de7b0408da6885e35503a3e5e.png"], "tag": ["Tarantool", "Lua"], "rating": ["+63"], "bookmarks": ["80"], "views": ["8k"], "comments_count": ["13"]},
{"author": ["majesty"], "date": ["20 мая в 03:32"], "hubs": ["Разработка веб-сайтов", "Клиентская оптимизация", "Высокая производительность", "Lua"], "type_label": [], "text": "Медленные сайты раздражают пользователей. Когда основной контент — фоточки, а сайт тормозит — это раздражает вдвойне. И как бы мы ни оптимизировали свой сервис, всегда остаётся такой фактор, как качество связи между пользователем и нашим ЦОДом. В решении этой проблемы нам помогает CDN. Мы — это компания «Колёса Крыша Маркет», разработчик самых крупных и посещаемых сайтов частных объявлений в Казахстане и фотографии из объявлений — критически важная часть нашего бизнеса. Специфика Казахстанского интернет-пространства такова — в стране есть несколько крупных интернет-провайдеров, достаточно жёстко конкурирующих между собой. Помимо доступа к сети они также предоставляют услуги colocation и с целью монополизации крайне неохотно строят пиринг между собой. Страна при этом большая и потоки трафика между городами частенько проходят очень неожиданными и совсем не оптимальными маршрутами. В этих условиях нам нужно максимально быстро отдать пользователям 1.5 Гбит/сек фотографий автомобилей, недвижимости и товаров личного потребления. Мы искали публичный CDN под свои нужды и нашли только присутствующий в Алматы Akamai без каких-либо подробностей по стоимости и планах расширения на остальную часть Казахстана. Мы приняли решение строить свой. Первой идеей было получить по ip-адресу пользователя его географическое положение и отдать ему данные с ближайшего сервера. Однако этот вариант был быстро отвергнут — мы вспомнили кейсы, когда трафик в соседнюю деревню идёт через 1000 км и в таком случае скорость может быть даже ниже, чем без использования CDN. По тем же причинам не стали мы использовать и любое другое гео-позиционирование. Один из наших админов предложил «пинговать сервер из браузера», что и послужило отправной точкой в реализации текущей схемы. Мы построили свой CDN на связке OpenResty и Lua с использованием JavaScript. Это не потребовало никаких доработок в коде сайтов (менеджеры и разработчики рады — можно «пилить» фичи вместо инфраструктурных задач :)) и немножко «допилов» в мобильных приложениях. OpenResty — это прекрасный форк Nginx от китайских разработчиков, о котором неоднократно писали на Хабре. Мы использовали его в качестве реверс-прокси. Lua — простой, мощный, встраиваемый язык, который тоже получил достаточно внимания на Хабре. При первом заходе пользователя на сайт (запуске мобильного приложения) мы определяем хост, с которого пользователь получает данные максимально быстро. На сайте для этого в ответ сервера встраивается небольшой код на JavaScript (в мобильных приложениях эту логику пришлось реализовать дополнительно). Он, в свою очередь, встраивает в страницу по одной невидимой картинке с каждого из хостов CDN и замеряет время, за которое эта картинка была получена. По результатам измерений пользователю на основной домен ставится кука с именем самого быстрого хоста. function getFastestHost() { var fastest = arguments[0], fastestDuration = 600000, timing = [], track = function (host) { var tracker = new Image(); tracker.src = \"/set.gif?cdn=\" + host; }; for (var i = 0; i < arguments.length; i++) { (function(host) { var image = new Image(), timeStart = (new Date()).getTime(); image.onload = function () { var duration = (new Date()).getTime() - timeStart; if (duration < fastestDuration) { fastestDuration = duration; fastest = host; } timing[timing.length] = duration; if (timing.length == arguments.length) { track(fastest); } } image.onerror = function () { timing[timing.length] = -1 if (timing.length == arguments.length) { track(fastest); } } image.src = host + \"/empty.gif\"; }(arguments[i])); } } При последующих запросах OpenResty запускает код на Lua, который проверяет наличие куки, валидирует её и, если всё хорошо, подменяет в URL изображений хост на тот, что был получен из куки. init_by_lua_block { -- получение хостов из файла function getCdnHosts(file) local hosts = {} for line in io.lines(file) do table.insert(hosts, line) end return hosts end -- разбор строки хостов в массив по регулярному выражению function stringToTable(t, s) local it, err = ngx.re.gmatch(s, \"(//[^;]+);?\") while true do local m, err = it() if not m then break end table.insert(t, m[1]) end return t end -- поиск значения в таблице function valueExists(tbl, value) for k,v in pairs(tbl) do if value == v then return true end end return false end } server { server_name kolesa.kz; # компонент куки cdn set $cdn_project kl; # хост куки cdn set $cookie_host .kolesa.kz; # файл с хостами cdn set $cdn_hosts_file \"/etc/nginx/cdn/cdn.data.active\"; # хосты статики set $replace_hosts \"//photos-a-kl.kcdn.kz;//photos-b-kl.kcdn.kz\"; # проверка наличия куки и подмена ответа с правильными uri location / { proxy_set_header Host kolesa.kz; proxy_pass http://kolesa; header_filter_by_lua_block { ngx.header.content_length = nil } body_filter_by_lua_block { allCdnHosts = getCdnHosts(ngx.var[\"cdn_hosts_file\"]) replaceHosts = stringToTable({}, ngx.var[\"replace_hosts\"]) cdnHost = ngx.var[\"cookie_\" .. ngx.var[\"cdn_project\"] .. \"_cdn_host\"] replaceEof = ngx.arg[2] if cdnHost ~= nil and valueExists(allCdnHosts, cdnHost) == true then -- кука есть, перезапишем на него всё, что нужно for k,v in pairs(replaceHosts) do local newStr, n, err = ngx.re.gsub(ngx.arg[1], v, cdnHost) if n > 0 then ngx.arg[1] = newStr replaceEof = false end end else -- кука ещё не установлена, добавим скрипт и он поставит куку local scriptStr = \"<script src='/cdn.js' type='text/javascript'></script>\" .. \"<script type='text/javascript'>\" .. \"(function(){\" .. \"getFastestHost('\" .. table.concat(allCdnHosts, \"', '\") .. \"')\" .. \"}())\" .. \"</script>\" local newStr, n, err = ngx.re.gsub(ngx.arg[1], \"(</body>)\", scriptStr .. \"$1\", \"i\") if n > 0 then ngx.arg[1] = newStr replaceEof = false end end ngx.arg[2] = replaceEof } } } Список доступных хостов лежит в файле, который формируется по результатам опроса хостов на доступность с фронтенда, раздающего html-код сайта. Таким образом, недоступные по какой-то причине хосты мы выводим из сервиса. Хостов CDN на данный момент у нас 5 штук — три в Алматы и по одному в Астане и Шымкенте. Каждый хост обслуживают два сервера Supermicro (для отказоустойчивости). На каждом крутится OpenResty + Memcached на 120 Gb для кэширования фотографий. По результатам внедрения мы снизили трафик на основной ЦОД (1.2 Гбит против 400 Мбит) и увеличили общий трафик от нас к пользователям (1.5 Гбит против 1.2 Гбит). Фоточки перестали тормозить у пользователей отдельных интернет-провайдеров (что частенько бывало до внедрения CDN) и в целом наши клиенты стали счастливее. В ближайших планах установить серверы в ЦОДы мобильных операторов, поскольку для пользователей мобильного интернета проблема ещё более актуальна.", "image": ["https://habrastorage.org/web/f5e/fff/3a4/f5efff3a4dbc4e65aa133f7cf013f20e.jpg"], "tag": ["lua", "nginx", "openresty", "memcached", "cdn", "статические ресурсы"], "rating": ["+20"], "bookmarks": ["76"], "views": ["9,4k"], "comments_count": ["18"]},
{"author": ["Migrator"], "date": ["26 сентября в 11:09"], "hubs": ["Разработка для интернета вещей", "Программирование микроконтроллеров", "Lua"], "type_label": [], "text": "Некоторое время назад я описывал прибор для мониторинга качества воздуха в помещении, который можно сделать самостоятельно из деталей заказанных на известном китайском интернет магазине. И вот появилась новая версия прибора. Доработки в новой версии небольшие, в основном касаются прошивки. Но добавление нового датчика BME280 существенно расширило функциональность прибора. Теперь стала доступна информация о температуре, влажности окружающего воздуха и атмосферном давлении. Для тех кто собрал прибор первой версии его доработка и усовершенствование будет простейшей задачей. Просто добавить новый датчик и пере прошить контроллер. Новый датчик подключается по интерфейсу I2C прямо к уже установленным часам. При наличии датчика BME280 прибор будет каждые 15 секунд переключать панель показывающую параметры измерения пыли в режим демонстрации температуры, влажности, атмосферного давления, и через 15 секунд обратно в режим демонстрации пыли. Датчик BMP280 вынесен из корпуса что бы на него не оказывало влияние нагрев остальных компонентов прибора. На картинке это маленький радиатор в верхнем левом углу. Для работы остальных датчиков используется вентилятор, который не спеша продувает корпус. Еще в данной версии появилась возможность использовать прибор без наличия датчика формальдегида. В старой прошивки без этого датчика не работал датчик пыли. → Тут можно взять новую прошивку → Тут Архив с файлами скриптов → Тут инструкция о том как самостоятельно собрать подобный прибор Инструкцию о том как прошивать контроллер можно посмотреть тут. Электрическая схема: Монтажная плата: Дополнительную информацию можно найти на моем сайте", "image": ["https://habrastorage.org/getpro/habr/post_images/56d/747/6d1/56d7476d11a1f2789618d933f06dff89.jpg", "https://habrastorage.org/getpro/habr/post_images/3a1/be1/af1/3a1be1af1989ec8ebdce32180063f8b1.jpg", "https://habrastorage.org/getpro/habr/post_images/c86/b6b/c81/c86b6bc81729f49583567f50922f874c.jpg", "https://habrastorage.org/getpro/habr/post_images/3f8/336/c3e/3f8336c3e8ad4c171e1321c0f901cded.jpg", "https://habrastorage.org/getpro/habr/post_images/3f2/c2e/2b0/3f2c2e2b0f70511825c2553e15cf592a.jpg", "https://habrastorage.org/getpro/habr/post_images/23f/f1c/5ce/23ff1c5cef907a3b69457b220e0fc3f4.jpg", "http://crystalairfresh.ucoz.net/PYL_2/pyl.zip", "https://habrastorage.org/getpro/habr/post_images/79f/b8b/6df/79fb8b6dfb0d1ed1cdd6a93d4a8eeeb6.png", "https://habrastorage.org/getpro/habr/post_images/4e7/e7a/68d/4e7e7a68dab85c5ea905bea7be41427d.png"], "tag": ["со2 экология климат в офисе"], "rating": ["+13"], "bookmarks": ["52"], "views": ["6,1k"], "comments_count": ["17"]},
{"author": ["Wolf_Black"], "date": [" 2 июня в 12:13"], "hubs": ["Lua", "C++"], "type_label": ["Tutorial"], "text": "Предисловие Возможно у вас наступал такой момент, что хотелось написать свой движок для игр, или просто вы хотели узнать, как такое реализовать, но по каким — то причинам вам это не удавалось. Ну что ж, тема довольно обширная, поэтому я начинаю серию уроков по написанию своего 2д игрового движка, и поверьте он будет не хуже того же Love2d, именно такого стиля и будет наш движок. Что нужно? Средние знания С++(на нем и будем писать двигатель). Базовые знания Lua (для описания игровой логики). Как все устроено? Вся игровая логика будет программироваться в файле, например — «main.lua». Движок будет читать этот файл и исполнять действия описанные в этом файле. Вывод графики будет с помощью SDL 2.0, физика — Box2D, аудио — OpenAl, скриптинг — Lua. IDE — Microsoft Visual Studio любой версии. Нарисовал схему Начинаем! Сначала надо скачать: Lua SDL 2.0 Box2D (надо будет скомпилировать самому) OpenAL Скачайте и переместите все файлы в отдельную папку, например — «Engine SDK». Открываем MVS, создаем «пустое» консольное приложение, далее добавляем файл — «main.cpp». Заполняем пока таким образом: int main() { return 0; } Компилируем, если скомпилировалось, идем дальше. Жмем «Project → project properties». Выбираем «C/C++ → General» и добавляем дополнительные папки включения (указывайте путь где вы извлекли из архива Lua). Указываем путь к «include» Lua. После этого заходим «Linker → General» и добавляем путь к либе. Применяем и изменяем «main.cpp» int main(int argc, char * argv[]) { return 0; } Компилируем, идем дальше. Далее нам нужно создать отдельный заголовочный файл, в котором будет основная часть движка. Добавляем файл «Engine.h». И сразу заполняем его таким образом. #include<iostream> #include<lua.hpp> #pragma comment(lib,\"lua53\") // на момент написания статьи версия Lua 5.3. using namespace std; class Lua { private: lua_State * lua_state; public: void Init() // инициализируем и подключаем модули. { lua_state = luaL_newstate(); static const luaL_Reg lualibs[] = { { \"base\", luaopen_base }, { \"io\", luaopen_io }, { \"os\",luaopen_os }, { \"math\",luaopen_math }, { \"table\",luaopen_table }, { \"string\",luaopen_string }, { \"package\",luaopen_package }, { NULL, NULL } }; for (const luaL_Reg *lib = lualibs; lib->func != NULL; lib++) { luaL_requiref(lua_state, lib->name, lib->func, 1); lua_settop(lua_state, 0); } } void Open(const char*filename) // открываем файл с кодом (main.lua) { luaL_openlibs(lua_state); if (luaL_dofile(lua_state, filename)) { const char*error = lua_tostring(lua_state, -1); } } void Close() // закрываем { lua_close(lua_state); } void Reg_int(int value, char*name) { lua_pushinteger(lua_state, value); lua_setglobal(lua_state, name); } void Reg_double(double value, char*name) { lua_pushnumber(lua_state, value); lua_setglobal(lua_state, name); } void Reg_bool(bool value, char*name) { lua_pushboolean(lua_state, value); lua_setglobal(lua_state, name); } void Reg_string(char*value, char*name) { lua_pushstring(lua_state, value); lua_setglobal(lua_state, name); } void Reg_function(lua_CFunction value, const char*name) // регистр нашей функции { lua_pushcfunction(lua_state, value); lua_setglobal(lua_state, name); } int Get_int(int index) // берем числовой аргумент из функции { return (int)lua_tointeger(lua_state, index); } double Get_double(int index) { return lua_tonumber(lua_state, index); } char* Get_string(int index) { return (char*)lua_tostring(lua_state, index); } bool Get_bool(int index) { return lua_toboolean(lua_state, index); } void Return_int(int value) // возвращаем числовое значение из функции { lua_pushinteger(lua_state, value); } void Return_double(double value) { lua_pushnumber(lua_state, value); } void Return_string(char*value) { lua_pushstring(lua_state, value); } void Return_bool(int value) { lua_pushboolean(lua_state, value); } int Call_load() // вызываем при старте { lua_getglobal(lua_state, \"Load\"); lua_call(lua_state, 0, 1); return 0; } int Call_update() // вызываем пока работает приложения { lua_getglobal(lua_state, \"Update\"); lua_call(lua_state, 0, 1); return 0; } int Call_draw() { lua_getglobal(lua_state, \"Draw\"); // вызываем после \"Update\" lua_call(lua_state, 0, 1); return 0; } }; Lua lua;// lua экземпляр Компилируем, если нет ошибок, идем дальше, если же есть, значит вы где- то накосячили. Изменяем «main.cpp»: include \"Engine.h\" int main(int argc, char * argv[]) { lua.Init(); lua.Open(\"main.lua\"); lua.Call_load(); lua.Close(); return 0; } Компилируем, если без ошибок, двигаемся дальше. Создаем в папке проекта текстовый файл «main.lua». Заполняем его так: function Load() print(\"Lua inited!\") end function Update() end function Draw() end Компилируем, бросаем «lua5*.dll» в папку проекта, запускаем, и Оппа! В консоле вывело «Lua inited!». По сути мы написали простой Lua — интерпретатор. В второй части приступим к выводу графики.", "image": ["https://habrastorage.org/web/579/7c2/0b2/5797c20b2edf4d829492933e1122bf21.png", "https://habrastorage.org/web/91c/889/b01/91c889b01ca34d5090dd06884610684e.png", "https://habrastorage.org/web/3fc/043/467/3fc0434670cc459f8745b1220e6ceeb6.png"], "tag": ["c++", "engine", "lua", "gamedev"], "rating": ["+11"], "bookmarks": ["91"], "views": ["7,6k"], "comments_count": ["17"]},
{"author": ["32bit_me"], "date": ["28 августа в 04:53"], "hubs": ["Программирование", "Компиляторы", "Open source", "Lua", "Brainfuck"], "type_label": ["Перевод"], "text": "Terra — низкоуровневый язык системного программмирования, встраиваемый и имеющий возможность метапрограммирования с помощью языка Lua. -- Это обычный код на Lua function printhello() -- Это обычная функция Lua print(\"Hello, Lua!\") end printhello() -- Terra обратно совместим с C, мы будем использовать библиотеку C в нашем примере C = terralib.includec(\"stdio.h\") -- Ключевое слово 'terra' вводит новую функцию terra hello(argc : int, argv : &rawstring) -- Здесь мы вызываем функцию C из Terra C.printf(\"Hello, Terra!\\n\") return 0 end -- Вы можете вызвать функцию Terra прямо из Lua, она компилируется JIT -- используя LLVM для создания машинного кода hello(0,nil) -- Функции Terra являются значениями первого класса в Lua, и могут участвовать в интроспекции -- и использоваться в метапрограммировании hello:disas() --[[ output: assembly for function at address 0x60e6010 0x60e6010(+0): push rax 0x60e6011(+1): movabs rdi, 102129664 0x60e601b(+11): movabs rax, 140735712154681 0x60e6025(+21): call rax 0x60e6027(+23): xor eax, eax 0x60e6029(+25): pop rdx 0x60e602a(+26): ret ]] -- Вы можете сохранить код на Terra как исполняемый, как объектный файл,или как разделяемую библиотеку -- и слинковать его с существующими программами terralib.saveobj(\"helloterra\",{ main = hello }) Как и C/C++, язык Terra статически типизируемый, компилируемый язык с «ручным» управлением памятью. В отличие от C/C++, он изначально спроектирован для метапрограммирования с помощью Lua. Terra спроектирован на основе того факта, что C/C++ на самом деле состоит из множества “языков.” Есть ядро языка, состоящее из операторов, управления потоком исполнения и вызова функций, но окружающий его язык, это метаязык, составленный из смеси разных вещей, таких, как препроцессор, шаблоны, объявления структур. Шаблоны сами по себе образуют Тьюринг-полный язык и используются для порождения оптимизированных библиотек, таких, как Eigen, но ужасны в плане практического использования. В языке Terra мы отказались от идеи сделать метаязык C/C++ более мощным и заменили его настоящим языком программирования, Lua. Комбинация низкоуровневого языка, который может метапрограммироваться высокоуровневым скриптовым языком делает возможными многие варианты поведения, невозможные в других системах. В отличие от C/C++, код на Terra может быть JIT-компилирован и запущен совместно с интерпретатором Lua, что делает простым написание библиотек, зависящих от рантаймовой кодогенерации. Возможности других языков, такие, как условная компиляция и шаблоны просто проигрывают по сравнению с использованием Lua для метапрограммирования Terra: -- C++ | -- Lua/Terra int add(int a, int b) { | terra add(a : int,b : int) : int return a + b; | return a + b } | end | | -- Условная компиляция завершена | -- передача управления | -- решает, какой код определён #ifdef _WIN32 | if iswindows() then void waitatend() { | terra waitatend() getchar(); | C.getchar() } | end #else | else void waitatend() {} | terra waitatend() end #endif | end | | -- Шаблоны стали функциями Lua | -- принимающими тип Т из terra | -- и использующими его для генерации новых типов | -- и кода template<class T> | function Array(T) struct Array { | struct Array { int N; | N : int T* data; | data : &T | } T get(int i) { | terra Array:get(i : int) return data[i]; | return self.data[i] } | end | return Array }; | end typedef | Array<float> FloatArray; | FloatArray = Array(float) Вы можете использовать Terra и Lua как… Встраиваемый JIT-компилятор для конструирования языков. Мы используем техники многоступенчатого программирования [2] для того, чтобы сделать возможным метапрограммирование Terra с использованием Lua. Выражения, типы и функции языка Terra являются значениями первого класса в языке Lua, что делает возможным генерацию произвольных программ в рантайме. Это позволяет вам компилировать предметно-ориентированные языки (DSL), написанные на Lua в высокопроизводительный код на Terra. Более того, так как Terra построен на экосистеме Lua, легко встроить программу на Terra-Lua в другую программу в виде библиотеки. Такой дизайн позволяет вам добавлять JIT-компилятор в ваше существующее программное обеспечение. Вы можете использовать его для добавления JIT-компилируемых DSL-языков в ваше приложение, либо автоматически и динамически конфигурировать высокопроизводительный код. Скриптовой язык с высокопроизводительными расширениями. Хотя производительность Lua и других динамических языков непрерывно улучшается, низкой уровень абстракции даёт вам предсказуемое управление производительностью, когда вам это нужно. Программы Terra используют тот же бэкенд LLVM, который Apple использует в своих компиляторах C. Это значит, что производительность кода Terra близка к аналогичному коду C. Например, наши переводы программ nbody и fannhakunen из бенчмарка [1] языков программирования имеют производительность, отличающуюся не более, чем на 5% от их эквивалентов на С, скомпилированных на Clang, фронтенде LLVM. Terra также включает встроенную поддержку SIMD-операций и другие низкоуровневые возможности, такие, как запись и предвыборка не-временной памяти. Вы можете использовать Lua для организации и конфигурирования вашего приложения, а затем, когда вам нужна управляемая производительность, сделать вызов кода Terra. Самостоятельный низкоуровневый язык. Terra спроектирован так, что может работать независимо от Lua. Фактически, ваша конечная программа не требует Lua, вы можете сохранить код Terra в файл .o или в исполняемый файл. Вдобавок к ясному разделению между высокоуровневым и низкоуровневым кодом, такой дизайн позволяет вам использовать Terra как независимый низкоуровневый язык. В таком сценарии использования, Lua выступает в роли мощного языка метапрограммирования. Lua служит заменой шаблонов C++ [3] и макросов препроцессора C (X-Macro) [4], имея при этои лучший синтаксис и лучшие свойства в плане гигиены [5]. Так как Terra существует только как код, встроенный в метапрограмму Lua, те возможности, которые обычно встроены в низкоуровневый язык, могут быть реализованы как библиотеки Lua. Такой дизайн сохраняет ядро Terra простым, делая возможным сложное поведение, такое, как условная компиляция, пространства имён, шаблоны, и даже систему классов, реализованную в виде библиотек. Чтобы получить больше информации об использовании Terra, смотрите руководство для начинающих и справочник по API. Наши публикации дают более глубокое представление о дизайне языка. [1] http://benchmarksgame.alioth.debian.org [2] http://www.cs.rice.edu/~taha/MSP/ [3] http://en.wikipedia.org/wiki/Template_metaprogramming [4] http://en.wikipedia.org/wiki/X_Macro [5] http://en.wikipedia.org/wiki/Hygienic_macro Порождающее программирование Сущности языка Terra, такие, как функции, типы, переменные и выражения являются в Lua значениями первого класса, они могут быть сохранены как переменные, а также передаваться в функции Lua и возвращаться из функций Lua. Используя конструкции из многоступенчатого программирования, вы можете писать код на Lua, порождающий произвольный код Terra. Многоступенчатые операторы В коде Terra вы можете использовать опрератор escape ([]), помещающий результат выражения Lua в код Terra: local a = 5 terra sin5() return [ math.sin(a) ] end Значение escape вычисляется, когда функция Terra компилируется, и результат помещается в код Terra. В данном примере, это означает, что выражение math.sin(5) будет вычислено один раз, и код, реализующий функцию Terra, возвратит константу. Это можно проверить, если вывести скомпилированную версию функции sin5. --вывод хорошо показывает, что делает функция sin5:printpretty() > output: > sin50 = terra() : {double} > return -0.95892427466314 > end Escape-операторы также могут возвращать другие сущности Terra, например, функции: add4 = terra(a : int) return a + 4 end terra example() return [add4](3) -- 7 end В этом случае, код Terra будет вставлен в функцию Terra, сохранённую в переменной add4: example:printpretty() > output: > example4 = terra() : {int32} > return <extract0> #add43(3)# > end Фактически, любое имя, используемое в коде Terra, такое, как add4 или foo.bar рассматривается по умолчанию, как если бы оно было escape-оператором. Внутри escape-оператора вы можете ссылаться на переменные, определённые в Terra: --функция для вызова внутри escape function choosesecond(a,b) -- выводит false, 'a' - не число: print(a == 1) -- выводит true, 'a' - символ Terra: print(terralib.issymbol(a)) return b end terra example(input : int) var a = input var b = input+1 --создаёт escape со ссылками на 'a' и 'b' return [ choosesecond(a,b) ] --возвращает значение b end example(1) --возвращает 2 Так как escape-операторы вычисляются до того, как функции Terra скомпилированы, переменные a и b не будут иметь конкретных целых значений внутри escape-оператора. Вместо этого, внутри кода Lua переменные a и b являются символами Terra, представляющими ссылки на значения Terra. Так как choosesecond возвращает символ b, функция в примере возвратит значение переменной b кода Terra, когда она будет вызвана. Оператор цитирования (quotation), обратный апостроф, позволяет вам генерировать операторы и выражения Terra в Lua. Они могут быть вставлены в код Terra с использованием escape-оператора. function addtwo(a,b) return `a + b end terra example(input : int) var a = input var b = input+1 return [ addtwo(a,b) ] end example(1) -- возвращает 3 Для генерации операторов вместо выражений исользуйте опретор quote: local printtwice = quote C.printf(\"hello\\n\") C.printf(\"hello\\n\") end terra print4() [printtwice] [printtwice] end Компиляция языка С помощью этих двух операторов вы можете генерировать произвольный код на Terra во время компиляции. Это делает комбинацию Lua/Terra хорошо подходящей для написания компилятора высокопроизводительного предметно-ориентированного языка. Например, мы можем реализовать компилятор BF, минимального языка, эмулирующего машину Тьюринга. Функция compile на языке Lua принимает строку кода BF и максимальный размер ленты N. Затем она генерирует функцию Terra, реализующую BF-код. Это «скелет», который подготавливает программу BF: local function compile(code,N) local function body(data,ptr) --<<реализация body>> end return terra() --массив с содержимым ленты var data : int[N] --сначала очищаем ленту for i = 0, N do data[i] = 0 end var ptr = 0 --генерируем код функции body [ body(data,ptr) ] end end Функция body отвечает за генерацию тела программы BF по строке кода: local function body(data,ptr) --список операторов Terra, исполняющих программу BF local stmts = terralib.newlist() --цикл по символам кода BF for i = 1,#code do local c = code:sub(i,i) local stmt --генерируем соответствующие операторы Terra --для каждого оператора BF if c == \">\" then stmt = quote ptr = ptr + 1 end elseif c == \"<\" then stmt = quote ptr = ptr - 1 end elseif c == \"+\" then stmt = quote data[ptr] = data[ptr] + 1 end elseif c == \"-\" then stmt = quote data[ptr] = data[ptr] - 1 end elseif c == \".\" then stmt = quote C.putchar(data[ptr]) end elseif c == \",\" then stmt = quote data[ptr] = C.getchar() end elseif c == \"[\" then error(\"Implemented below\") elseif c == \"]\" then error(\"Implemented below\") else error(\"unknown character \"..c) end stmts:insert(stmt) end return stmts end Цикл проходит по строке кода, генерирует соответствующий код на Terra для каждого символа BF (например, \">\" сдвигает ленту на один символ и реализуется на Terra кодом ptr = ptr + 1). Сейчас мы можем скомпилировать функцию BF: add3 = compile(\",+++.\") Результат, add3 — функция Terra, прибавляющая 3 к входному символу и выводящая результат: add3:printpretty() > bf_t_46_1 = terra() : {} > var data : int32[256] > ... > var ptr : int32 = 0 > data[ptr] = <extract0> #getchar()# > data[ptr] = data[ptr] + 1 > data[ptr] = data[ptr] + 1 > data[ptr] = data[ptr] + 1 > <extract0> #putchar(data[ptr])# > end Также мы можем использовать оператор goto (goto labelname) и метки (::labelname::) для реализации конструкции цикла в BF: local function body(data,ptr) local stmts = terralib.newlist() --добавляем стек, чтобы отслеживать начало каждого цикла local jumpstack = {} for i = 1,#code do local c = code:sub(i,i) local stmt if ... elseif c == \"[\" then --генерируем метки, представляющие начало --и конец цикла --функция 'symbol' генерирует глобальное уникальное --имя метки local target = { before = symbol(), after = symbol() } table.insert(jumpstack,target) stmt = quote --метка начала цикла ::[target.before]:: if data[ptr] == 0 then goto [target.after] --exit the loop end end elseif c == \"]\" then --извлекаем метки, соответствующие циклу local target = table.remove(jumpstack) assert(target) stmt = quote goto [target.before] --loop back edge :: [target.after] :: --label for end of the loop end else error(\"unknown character \"..c) end stmts:insert(stmt) end return stmts end Мы используем конструкции порождающего программирования для реализации предметно-ориентированных языков и автонастройки. Наша статья в PLDI описывает нашу реализацию Orion, языка для ядер обработки изображений, и мы в процессе портирования языка Liszt (основанное на сетках решение дифференциальных уравнений в частных производных) на язык Terra. Встраивание и взаимодействие Языки программирования не существуют в вакууме, и возможности порождающего программирования в Terra могут быть полезны даже в проектах, которые изначально реализованы на других языках программирования. Мы делаем возможным интеграцию Terra с другими проектами, так что вы можете использовать генерацию низкоуровнего кода, и в то же время большая часть вашего проекта будет реализована на каком-либо традиционном языке. Сначала сделаем возможной передачу значений между Lua и Terra. Наша реализация построена на основе интерфейса «чужих» функций (foreign function) LuaJIT. Вы можете вызвать функции Terra прямо из Lua (и наоборот) и получать доступ к объектам прямо из Lua (более подробно описано в справочнике по API). Более того, Lua-Terra обратно совместим с чистыми Lua и C, что облегчает использование существующего кода. В Lua-Terra, вы можете использовать require или loadfile и рассматривать файл как программу Lua (используйте terralib.loadfile для загрузки комбинированного файла Lua-Terra). Вы можете использовать terralib.includec для импорта функций C из существующих заголовочных файлов. Наконец, Lua-Terra может также быть встроен в существующме приложения путём линковки приложения с libterra.a и использования Terra’s C API. Интерфейс очень похож на интерфейс интерпретатора Lua. Простой пример инициализирует Terra и запускает код из файла, определённого в каждом аргументе: #include <stdio.h> #include \"terra.h\" int main(int argc, char ** argv) { lua_State * L = luaL_newstate(); //создаем состояние обычного Lua luaL_openlibs(L); //инициализируем его библиотеки //инициализируем состояние Terra в Lua terra_init(L); for(int i = 1; i < argc; i++) //запускаем код Terra из каждого файла if(terra_dofile(L,argv[i])) exit(1); return 0; } Простота Комбинация простого низкоуровневого языка с простым языком динамического программирования означает, что много встроенных возможностей статически типизированных низкоуровневых языков могут быть реализованы как библиотеки в динамическом языке. Вот неколько примеров: Условная компиляция Как правило, условная компиляция совершается с использованием директив препроцессора (например, #ifdef), или какой-либо системы сборки. При использовании Lua-Terra, мы можем написать код Lua, определяющий, как сконструировать функцию Terra. Так как Lua является полноценным языком программирования, он может делать вещи, которые большинство препроцессоров делать не могут, например, вызывать внешние программы. В этом примере, мы применяем условную компиляцию, чтобы скомпилировать функцию Terra по-разному для OSX и Linux путём вызова uname, чтобы определить операционную систему, и заием используем оператор if для инстанцирования разных версий функции Terra в зависимости от результата: --запускаем uname чтобы узнать, какая ОС запущена local uname = io.popen(\"uname\",\"r\"):read(\"*a\") local C = terralib.includec(\"stdio.h\") if uname == \"Darwin\\n\" then terra reportos() C.printf(\"this is osx\\n\") end elseif uname == \"Linux\\n\" then terra reportos() C.printf(\"this is linux\\n\") end else error(\"OS Unknown\") end --условная компиляция в --нужную версию для данной ОС reportos() Пространства имён Статически типизированным языкам обычно нужны конструкции, которые решают проблему пространств имён (например, ключевое слово namespace в C++, или конструкция import в Java). Для Terra мы просто используем таблицы первого класса из Lua как способ организации функций. Когда вы используете любое имя, например, myfunctions.add, внутри функции Terra, Terra будет разрешать его во время компиляции в связанное с ним значение Terra. Вот пример размещение функции Terra внутри таблицы Lua, с последующим вызовом из другой функции Terra: local myfunctions = {} -- функции terra - это значения первого класса в Lua -- они могут быть сохранены в таблицах Lua terra myfunctions.add(a : int, b : int) : int return a + b end -- и вызваны из таблиц terra myfunctions.add3(a : int) return myfunctions.add(a,3) end --объявление myfunctions.add это просто синтаксический сахар для: myfunctions[\"add\"] = terra(a : int, b : int) : int return a + b end print(myfunctions.add3(4)) Фактически, вы уже видели такое поведение когда мы импортировали функции С: C = terralib.includec(\"stdio.h\") Функция includec просто возвращает таблицу Lua ( C ), содержащую функции C. Так как C — это таблица Lua, вы можете делать итерации по ней: for k,v in pairs(C) do print(k,v) end > seek <terra function> > asprintf <terra function> > gets <terra function> > size_t uint64 > ... Шаблоны Так как типы и функции Terra являются значениями первого класса, вы можете получить фунциональность, близкую к шаблонам C++, просто создав тип Terra и определив функцию Terra внутри функции Lua. Ниже приведён пример, в котором мы определяем функцию Lua MakeArray(T), приимающую тип T языка Terra и порождающую объект Array который может хранить множество объектов типа T (т.е. простую версию std::vector из C++). C = terralib.includec(\"stdlib.h\") function MakeArray(T) --создаем новый тип Struct, содержащий указатель --на список объектов T и размер N local struct ArrayT { --&T i- указатель на T data : &T; N : int; } --добавляем методы к типу terra ArrayT:init(N : int) -- синтаксис [&T](...) - преобразование типов, -- эквивалентно (T*)(...) в С self.data = [&T](C.malloc(sizeof(T)*N)) self.N = N end terra ArrayT:get(i : int) return self.data[i] end terra ArrayT:set(i : int, v : T) self.data[i] = v end --возвращаем тип как return ArrayT end IntArray = MakeArray(int) DoubleArray = MakeArray(double) terra UseArrays() var ia : IntArray var da : DoubleArray ia:init(1) da:init(1) ia:set(0,3) da:set(0,4.5) return ia:get(0) + da:get(0) end Как показано в примере, Terra позволяет вам определять методы в типах struct. В отличие от других статически типизированных языков с классами, здесь нет встроенных механизмов наследования или run-time полиморфизма. Декларации методов, это просто синтаксический сахар, который ассоциирует таблицы методов Lua с каждым типом. Здесь метод get эквивалентен следующему: ArrayT.methods.get = terra(self : &T, i : int) return self.data[i] end Объект ArrayT.methods в таблице Lua хранит методы для типа ArrayT. Аналогично, вызов, например, ia:get(0) эквивалентен T.methods.get(&ia,0). Специализация Помещая функцию Terra внутрь функции Lua, вы можете скомпилировать разные версии функции. Здесь мы генерируем разные версии функции степени (т.е. pow2, pow3): --генерируем функцию степени для данного N (например, N = 3) function makePowN(N) local function emit(a,N) if N == 0 then return 1 else return `a*[emit(a,N-1)] end end return terra(a : double) return [emit(a,N)] end end --используем это для заполнения таблицы функций local mymath = {} for n = 1,10 do mymath[\"pow\"..n] = makePowN(n) end print(mymath.pow3(2)) -- 8 Система классов Как показано в примере для шаблонов, Terra позволяет определять методы для типов struct, но не предоставляет встроенного механизма для наследования или полиморфизма. Вместо этого, обычная система классов может быть написана как библиотека. Например, пользователь может написать: J = terralib.require(\"lib/javalike\") Drawable = J.interface { draw = {} -> {} } struct Square { length : int; } J.extends(Square,Shape) J.implements(Square,Drawable) terra Square:draw() : {} --реализация draw end Функции J.extends и J.implements являются функциями Lua, генерирующими соответствующий код на Terra для реализации системы классов. Больше информации доступно в нашей статье в PLDI. Файл lib/javalike.t содержит одну возможную реализацию системы классов, аналогичную Java, а файл lib/golike.t — более похожую на язык Go.", "image": ["https://habrastorage.org/web/3c5/425/78c/3c542578c1b04aec8778786e90983716.jpg"], "tag": ["lua", "terralang", "terra", "язык terra", "LLVM", "brainfuck"], "rating": ["+57"], "bookmarks": ["100"], "views": ["11,3k"], "comments_count": ["28"]},
{"author": ["OlegBou"], "date": ["14 июня в 18:14"], "hubs": ["Системы обмена сообщениями", "Системное программирование", "Разработка под Linux", "Высокая производительность", "Lua"], "type_label": ["Tutorial"], "text": "Допустим, у вас имеются миллионы и миллионы хранимых объектов данных, например, данный портал или телеметрия с космического телескопа или адронного коллайдера. Перемещение вычислений в сторону данных может приводить к снижению временных затрат на порядки за счёт исключения необходимости перемещения самих данных в сетевой среде для их обработки. В точном соответствии с притчей о горе и Магомеде. Именно этой цели служит класс RADOS, вызовы к которому могут выполняться функциями librados. Асинхронная система сообщений существенно снижает накладные расходы самого сетевого уровня Ceph, а применение абстракций NetworkStack делает возможной реализацию различных протоколов стека (POSIX/ SPDK/ DPDK/ RDMA). В том числе применение объектов класса RADOS. Программирование при помощи librados Для достижения максимальной производительности и внутренней гибкости Ceph можно применять встроенные в библиотеку librados вызовы функций, доступные для большинства языком программирования, например, для C, C++, Python, PHP и Java. С этой целью вы сначала устанавливаете инструменты разработки. Например, для Debian- дистрибутивов: $ sudo apt-get install build-essential $ sudo apt-get install librados-dev Затем в своём приложении мы: Выполняем необходимые подготовительные операции самого приложения (считывание параметров, подготовку справки об этом приложении и т.п.) Считываем файл настроек ceph.conf для получения мониторов Подключаемся к кластеру Ceph Открываем нужный пул RADOS Открываем образ для чтения/записи Выполняем необходимую операцию чтения/записи Закрываем соединение с пулом Закрываем соединение с кластером Ceph (Пример приложения) Порой приложение требует атомарности выполняемой операции, состоящей из нескольких действий, например, из записи собственно данных и их атрибутов. То есть, если в процессе выполнения атомарной (неделимой) последовательности действий происходит какое- либо прерывание или некий сбой, отвергаются все уже выполненные действия. Реальной записи или изменения не происходит. Долгое время разработчики Ceph не теряли надежды на поддержку атомарности за счёт средств btrfs, поскольку её реализация в рамках xfs приводит к снежному кому проблем, самой малой из которых является необходимость, как минимум, дублированной записи. В конце концов, начиная с выпуска Kraken для лежащего в основе OSD хранилища было принято решение по умолчанию отказываться от файлового хранения с применением POSIX файловых систем и применять упрощённую файловую систему BlueFS для хранения собственно данных и RocksDB для хранения метаданных и, возможно, отложенных записей (WAL, write-ahead log). Данное хранилище получило название BlueStore (указывающая на Blочную природу хранилища, изначально имевшего незатейливое название NewStore). Подробнее... Теперь, имея в руках полноценную реализацию транзакций, не отягощённую избыточными накладными расходами, мы со спокойной совестью можем их использование в своих приложениях. Посмотрим как меняется скелет нашей программы: Выполняем необходимые подготовительные операции самого приложения (считывание параметров, подготовку справки об этом приложении и т.п.) Считываем файл настроек ceph.conf для получения мониторов Подключаемся к кластеру Ceph Открываем нужный пул RADOS Инициализируем списки буферов обмена (по числу необходимых действий) и заполняем их данными Создаём транзакцию Последовательно записываем данные буферов обмена в транзакцию Фиксируем транзакцию Закрываем соединение с пулом Закрываем соединение с кластером Ceph (Пример приложения) Ещё одной достойной функциональностью librados является организация приложений наблюдатель- уведомитель (watch — notify). Работа наблюдателя организуется путём обратного вызова (callback). При создании наблюдателя через вызов соответствующей функции вы передаёте в таком вызове двумя параметрами ссылки на необходимые функции обратного вызова. Первая применяется для выполнения действия в случае получения уведомления, а вторая используется когда что-то пошло не так, в ней вы производите необходимые действия по отработке ошибок. Например, таким образом вы создаёте моментальный снимок некоторого объекта. Клиент, которому требуется выполнить такой снимок, отправляет всем находящимся в ожидании для данного объекта клиентам (watcher) уведомления (выступая в качестве notifier), в котором он сообщает, что может сбросить свой кэш данного объекта и выполнить проверку на непротиворечивость данных. (Пример приложения) Распределённые вычисления при помощи классов RADOS Ceph Библиотека librados работает с объектами, хранящимися в распределённой системе хранения RADOS (Reliable Autonomic Distributed Object Store), в основе которого лежат демоны хранения объектов (OSD, Object Storage Daemon), каждый из которых обслуживает некое собственное хранилище (например, уже упоминавшееся BlueStore). Одним из примечательных свойств OSD является возможность локальной обработки хранимых в нём данных методами класса RADOS. Это открывает широкие возможности революционного увеличения производительности распределённой обработки хранимых данных, поскольку избавляет вас от необходимости обмена самими данными для такой обработки. Например, вы можете вычислять хеш-значения и контрольные суммы данного объекта, осуществлять их проверку. Вы можете выполнять поиск в таких данных и их анализ, выставляя результаты, скажем, в метаданных самого объекта. Одним из простейших способов такой разработки является применение языка сценариев Lua, который, начиная с выпуска Kraken встроен в класс RADOS. Данный сценарий, как правило, в виде строк JSON (скажем, в программе с применением librados на Python) передаётся в имеющийся объект класса RADOS, где он и исполняется. Пример приложения изменения в объекте всех строчных букв на прописные. Отметим, что по умолчанию исполнение сценариев Lua в OSD отключено, для включения такой возможности необходимо внести приведённые в примере изменения в файлы настроек OSD. К сожалению, в настоящее время функциональные возможности языка сценариев Lua достаточно ограничены. Для решения более сложных задач вам придётся скомпилировать исходный код Ceph со встроенным в него классом RADOS, написанным, например, на C или C++. В Примере приложения вычисления MD5 объекта приводятся пошаговые инструкции построения такого решения, а также сопоставляются результаты времён его работы в сравнении с аналогичным приложением, исполняющимся на клиенте, находящимся не на узле OSD и вынужденном считывать данные с OSD и записывать в него результат расчёта. результат сравнения даёт преимущество в абсолютных затратах времени в два порядка. Поскольку данный метод обработки может приводить в случае ошибок к утрате данных и нарушению работы самого OSD, естественно, все применяемые методы должны быть тщательно проверены и иметь всеобъемлющие средства обработки ошибок. Мы предлагаем подход к решению такой проблемы, основанный на выводе подобных вычислений в отдельный LXC с изолированным пространством имён, причём с возможностью применения вычислений на пробрасываемых в данный контейнер ресурсах GPU и/или FPGA, с последующим использованием обсуждаемой далее методики асинхронного обмена сообщениями. Ceph Async Messenger Дополнительные средства для распределённой обработки данных предоставляет имеющаяся в Ceph система асинхронного обмена сообщениями. Например, таким образом реализован механизм применения RDMA в реализации Mellanox. Первоначально AsyncMessenger, судя по всему, разрабатывался в качестве расширения epoll, призванного полностью вытеснить SimpleMessenger, являющийся первоначальной системой обмена сообщений и лежащей в основе сетевого протокола Ceph. Такая потребность вызвана тем фактом, что для каждой пары участников однорангового взаимодействия (peering) в SimpleMessenger создаются 4 потока (по два с каждой стороны). С ростом числа участников это приводит к экспоненциальному росту общего числа потоков (thread) в узлах участников. В настоящее время все три метода реализуют сетевой протокол Ceph, при этом применяя один общий рабочий пул. В протоколе AsyncMessenger участвуют сервер и клиент. Сервер выполняет инициализацию, привязывается к file descriptor (fd) и осуществляет ожидание уведомлений по нему (listen). В отличие от определённых POSIX методов select() и poll(), epoll предоставляет механизм обработки сообщений со сложностью O(1), в отличие от O(n) для SimpleMessenger, исключая перебор событий, не имеющих активных fd. AsyncMessenger применяет библиотеку libevent, предоставляемую средствами epoll. Обработка события осуществляется сервером по получению уведомления на fd, либо по тайм- ауту. Помимо этого сервер может добавлять ожидание fd, принимать соединения, добавлять приём fd и осуществлять взаимодействие. Клиент инициирует установление соединения и устанавливает его для выполнения взаимодействия. Весь обмен сетевого уровня приложений обрабатывается машиной состояний AsyncConnection. Статья Wei Jin акцентирует основные моменты данного типа взаимодействия. Дальнейшим развитием механизма AsyncMessenger является развитие абстракции NetworkStack, которая позволяет осуществлять распределённую поддержку различных сетевых стеков (Posix/ DPDK/ RDMA), а также встроенной в BlueStore поддержки SPDK. Данный уровень абстракции реализует понятия ServerSocket и ConnectedSocket, причём первый ожидает поступления запросов, а второй собственно и осуществляет чтение и запись всех данных. Основные моменты реализации приложений с применением данных абстракций приводятся в статье Стек асинхронной системы сообщений Ceph того же Wei Jin. Материалы: Изучаем Ceph, 2е издание Энтони Д'Атри, Вайбхав Бхембре, Каран Сингх, октябрь 2017, Packt Publishing Полное руководство работы с сетями на Python Эрик Чоу, июнь 2017, Packt Publishing Полное руководство Ansible, 2е издание Джесс Китинг, май 2017, Packt Publishing Полное руководство Ceph Ник Фиск, май 2017, Packt Publishing Настройка RDMA Ceph Mellanox, 30.11.2016 с изменениями 27.03.2017 Асинхронная система сообщений Ceph Wei Jin (Eric), 28.12.2016 Стек асинхронной системы сообщений Ceph Wei Jin (Eric), 12.01.2017 Книга рецептов Ceph Каран Сингх, февраль 2016, Packt Publishing Изучаем Ceph Каран Сингх, январь 2015, Packt Publishing Proxmox. Полное руководство. 2е изд Васим Ахмед, август 2015, Packt Publishing Книга рецептов Proxmox Васим Ахмед, май 2016, Packt Publishing Стек протоколов Mellanox OFED Mellanox, Rev. 3.20 Контейнеризация при помощи LXC Константин Иванов, февраль 2017, Packt Publishing Zabbix. Полное руководство. 2е изд. Андреа Далле Ваккье, сентябрь 2015, Packt Publishing Пример системы виртуализации Юрий Шкандыбин, 14-10-2016 Рекомендуемые розничные цены CPU Intel Xeon E5 v4/v3, 01-04-2016 Обзор рекомендуемых аппаратных средств, sddc.mdl.ru, 01-04-2017", "image": [], "tag": ["Ceph", "BlueStore", "BlueFS", "RocksDB", "RADOS", "librados", "epoll", "AcyncMessenger", "NetworkStack", "Lua", "ServerSocket", "ConnectedSocket"], "rating": ["+8"], "bookmarks": ["19"], "views": ["1,8k"], "comments_count": []},
{"author": ["relevance_17"], "date": ["30 августа в 12:06"], "hubs": ["Open source", "NoSQL", "Lua", "Блог компании Mail.Ru Group"], "type_label": ["Tutorial"], "text": "Как построить свое приложение для Tarantool и при этом не городить огород каждый раз, когда требуется сделать, казалось бы, элементарную вещь? Это продолжение цикла статей о том, как создавать свои приложения для Tarantool. Сегодня мы рассмотрим вопросы сетевого взаимодействия, установки и использования сторонних модулей. Содержание цикла «Приложения для Tarantool 1.7» — Часть 1. Хранимые процедуры — Часть 2. OAuth2-авторизация — Часть 3. Тестирование и запуск Взаимодействие с внешними сервисами В качестве примера рассмотрим реализацию OAuth2-авторизации через Facebook в приложении tarantool-authman. При OAuth2-авторизации пользователь переходит по ссылке, которая ведет на окно логина в социальной сети. После ввода авторизационных данных и подтверждения разрешений (permisssions) соцсеть переадресует пользователя обратно на сайт с авторизационным кодом в GET-параметре запроса. Сервер должен обменять этот код на токен (либо на пару токенов — access и refresh). С токеном можно получить информацию о пользователе из социальной сети. Подробнее о OAuth2-авторизации написано в этой статье. Tarantool-приложение возьмет на себя обмен авторизационного кода (code) на токен доступа (token) к информации о пользователе из социальной сети, а также получит по этому токену пользовательские данные. В нашем случае это email, имя и фамилия. Для обмена авторизационного кода на токен доступа нужно отправить запрос к Facebook с кодом, а также параметрами приложения Facebook — client_id и client_secret. В Tarantool с версии 1.7.4-151 встроен модуль http.client, работающий на базе libcurl. Модуль позволяет принимать и отправлять HTTP-запросы. Воспользуемся этим модулем для реализации OAuth2-авторизации. Для начала создадим вспомогательную функцию для отправки HTTP-запросов в модуле authman/utils/http.lua: local http = {} local utils = require('authman.utils.utils') local curl_http = require('http.client') -- config — общая конфигурация приложения authman function http.api(config) local api = {} -- Конфигурация сетевых запросов local timeout = config.request_timeout function api.request(method, url, params, param_values) local response, body, ok, msg if method == 'POST' then -- utils.format — функция для подстановки значений в placeholder’ы body = utils.format(params, param_values) -- Безопасный вызов pcall не прервет исполнение программы при ошибке сети ok, msg = pcall(function() response = curl_http.post(url, body, { headers = {['Content-Type'] = 'application/x-www-form-urlencoded'}, timeout = timeout }) end) end return response end return api end return http Стоит обратить внимание на функцию pcall. Она обрабатывает исключения, возникшие при выполнении анонимной функции. В нашем случае необходимо обработать сетевые ошибки, которые генерирует HTTP-клиент. Результат вызова pcall записывается в переменные ok (true/false) и msg (сообщение об ошибке, nil при успехе). OAuth2-авторизации в приложении Создадим модель social и напишем метод для получения токена по авторизационному коду get_token(provider, code), а также метод для получения или обновления данных профиля get_profile_info(provider, token, user_tuple). Рассмотрим эти методы: -- Метод получения токена function model.get_token(provider, code) local response, data, token if provider == 'facebook' then -- Здесь http — модуль authman/utils/http.lua response = http.request( 'GET', 'https://graph.facebook.com/v2.8/oauth/access_token', '?client_id=${client_id}&redirect_uri=${redirect_uri}&client_secret=${client_secret}&code=${code}', { -- config — конфигурации проекта, которые передаются в модель при инициализации -- Это параметры приложения в социальной сети client_id = config[provider].client_id, redirect_uri = config[provider].redirect_uri, client_secret = config[provider].client_secret, code = code, } ) if response == nil or response.code ~= 200 then return nil else data = json.decode(response.body) return data.access_token end end end -- Метод получения профиля пользователя function model.get_profile_info(provider, token, user_tuple) local response, data user_tuple[user.PROFILE] = {} if provider == 'facebook' then response = http.request( 'GET', 'https://graph.facebook.com/me', '?access_token=${token}&fields=email,first_name,last_name', { token = token } ) if response == nil or response.code ~= 200 then return nil else data = json.decode(response.body) user_tuple[user.EMAIL] = data.email user_tuple[user.PROFILE][user.PROFILE_FIRST_NAME] = data.first_name user_tuple[user.PROFILE][user.PROFILE_LAST_NAME] = data.last_name return data.id end end end Теперь добавим метод API приложения, позволяющий создать пользователя или войти под уже существующим через Facebook. Метод будет возвращать пользователя вместе с сессионными данными. Подробнее о том, как формируется и валидируется сессия, можно посмотреть в исходном коде. -- Метод api в authman/init.lua function api.social_auth(provider, code) local token, social_id, social_tuple local user_tuple = {} if not (validator.provider(provider) and validator.not_empty_string(code)) then return response.error(error.WRONG_PROVIDER) end -- Получим OAuth2-токен token = social.get_token(provider, code, user_tuple) if not validator.not_empty_string(token) then return response.error(error.WRONG_AUTH_CODE) end -- Получим информацию о пользователе social_id = social.get_profile_info(provider, token, user_tuple) if not validator.not_empty_string(social_id) then return response.error(error.SOCIAL_AUTH_ERROR) end user_tuple[user.EMAIL] = utils.lower(user_tuple[user.EMAIL]) user_tuple[user.IS_ACTIVE] = true user_tuple[user.TYPE] = user.SOCIAL_TYPE -- Проверим, есть ли в space пользователь с таким же social_id social_tuple = social.get_by_social_id(social_id, provider) if social_tuple == nil then -- Если нет — создадим его user_tuple = user.create(user_tuple) social_tuple = social.create({ [social.USER_ID] = user_tuple[user.ID], [social.PROVIDER] = provider, [social.SOCIAL_ID] = social_id, [social.TOKEN] = token }) else -- А если есть — обновим информацию профиля user_tuple[user.ID] = social_tuple[social.USER_ID] user_tuple = user.create_or_update(user_tuple) social_tuple = social.update({ [social.ID] = social_tuple[social.ID], [social.USER_ID] = user_tuple[user.ID], [social.TOKEN] = token }) end -- Создание пользовательской сессии local new_session = session.create( user_tuple[user.ID], session.SOCIAL_SESSION_TYPE, social_tuple[social.ID] ) return response.ok(user.serialize(user_tuple, { session = new_session, social = social.serialize(social_tuple), })) end Как проверить, что метод работает? Для начала необходимо зарегистрировать приложение в Facebook. Сделаем это на странице разработчика Facebook. В созданном приложении нужно добавить продукт «Вход через Facebook» и указать redirect_uri — «Действительные URL-адреса для перенаправления OAuth». Параметр redirect_uri — это урл вашего сайта, куда социальная сеть перенаправит пользователя с параметром code после успешной авторизации в социальной сети. Далее откройте в браузере урл https://www.facebook.com/v2.8/dialog/oauth?client_id=${client_id}&redirect_uri=${redirect_uri}&scope=email, где • client_id — id вашего приложения в Facebook; • redirect_uri — урл для редиректа, который вы указали ранее; • scope — список разрешений (в данном случае только email). Facebook запросит подтверждение разрешений, после подтверждения переадресует вас с GET-параметром code. Это и есть тот самый авторизационный код, которой принимает метод api.social_auth(). Прежде чем проверять работоспособность кода, создадим конфигурационный файл authman/config/config.lua, в котором укажем настройки приложения Facebook. return { facebook = { client_id = 'id from fb application', client_secret = 'secret from fb application'', redirect_uri='http://redirect_to_your_service', } } Теперь проверим, что код работает и приложение получает информацию о пользователе из социальной сети: $ tarantool version 1.7.4-384-g70898fd type 'help' for interactive help tarantool> config = require('config.config') tarantool> box.cfg({listen = 3331}) tarantool> auth = require('authman').api(config) tarantool> code = 'auth_code_from_get_param' tarantool> ok, user = auth.social_auth('facebook', code) tarantool> user --- - is_active: true social: provider: facebook social_id: '000000000000001' profile: {'first_name': 'Иван', 'last_name': 'Иванов'} id: b1e1fe02-47a2-41c6-ac8e-44dae71cde5e email: ivanov@mail.ru session: ... ... Установка сторонних модулей Для решения многих задач хорошо иметь под рукой готовые решения. Например, в версиях Tarantool ниже 1.7.4-151 отправить HTTP-запрос «из коробки» было нельзя. Требовался модуль tarantool-curl. Сейчас этот модуль больше не поддерживается, не рекомендуется его использовать. Однако есть много других полезных модулей, один из них — tarantool-queue — реализация FIFO-очереди. Есть несколько способов установить tarantool-queue. Первый, самый простой и удобный, появился относительно недавно, в версии Tarantool 1.7.4-294. $ tarantoolctl rocks install queue Другие пакеты Tarantool также доступны для установки с использованием менеджера пакетов. Полный список модулей для Tarantool можно найти на странице Rocks. Второй способ — с помощью менеджера пакетов вашей ОС. Здесь необходимо подключить репозиторий Tarantool, если вы еще не подключили его на этапе установки, а также убедиться, что соответствующий пакет есть в репозитории. Например, для Ubuntu: $ sudo apt-get install tarantool-queue Третий способ сложнее, однако позволяет использовать не только приложения для Tarantool, но и готовые модули Lua. Устанавливать модули для Tarantool и Lua удобно с помощью менеджера пакетов LuaRocks. Подробно о нем и доступных модулях можно прочитать в документации. Установим LuaRocks и настроим его для работы с репозиторием Tarantool: $ sudo apt-get install luarocks Теперь настроим LuaRocks, чтобы устанавливать не только Lua-пакеты, но и пакеты для Tarantool. Для этого требуется создать файл ~/.luarocks/config.lua со следующим содержимым: rocks_servers = { [[http://luarocks.org/repositories/rocks]], [[http://rocks.tarantool.org/]] } Установим сам модуль и проверим его работу: # Установка tarantool-queue $ sudo luarocks install queue # Запустим интерактивную консоль и проверим работоспособность модуля: $ tarantool version 1.7.3-433-gef900f2 type 'help' for interactive help tarantool> box.cfg({listen = 3331}) tarantool> queue = require('queue') tarantool> test_queue = queue.create_tube('test_queue', 'fifo') tarantool> test_queue:put({'task_1'}) tarantool> test_queue:put({'task_2'}) tarantool> test_queue:take() --- - [0, 't', ['task_1']] ... Итак, теперь мы можем создавать приложения со сложной архитектурой и внешними взаимодействиями. В следующей части рассмотрим тестирование приложений, а также конфигурацию и запуск в бою. До новых встреч!", "image": ["https://habrastorage.org/web/6bc/a42/ca2/6bca42ca2fc74d00923ad3348e4cdb09.png", "https://habrastorage.org/web/bd8/ad3/e34/bd8ad3e349dc419c864e4ebb83f3fff6.png"], "tag": ["Tarantool", "Lua", "oauth2"], "rating": ["+39"], "bookmarks": ["43"], "views": ["4,1k"], "comments_count": []},
{"author": ["phpclub"], "date": ["17 мая в 18:01"], "hubs": ["Разработка игр", "Разработка веб-сайтов", "Высокая производительность", "Lua", "Блог компании DevConf"], "type_label": [], "text": "Приглашаем на митап с докладами Lua in Moscow 17-го июня на конференцию сообществ разработчиков DEVCONF. На митапе у вас будет шанс послушать доклады об устройстве и применении Lua и LuaJIT и обменяться опытом с членами коммьюнити. Lua — уникальный язык программирования, который используется далеко не только в индустрии компьютерных игр, но и как встроенный язык расширений в таких инструментах web-программирования, как Redis, nginx, Tarantool, OpenResty. Lua также применяется для анализа больших данных, научных вычислений. Во многих роутерах, принтерах и других подобных устройствах есть Lua. Lua in Moscow — отечественный митап по языку программирования Lua. Даже если вы ещё не пишете на языке Lua, приходите, возможно, митап откроет вам глаза на что-то новое и интересное! Присоединяйтесь к нам в Telegram: @luainmoscow Посещение митапа бесплатное для всех желающих, нужно лишь зарегистрироваться Если у Вас есть уже билет на DEVCONF — Вам повезло, Вы уже потенциальный участник. До встречи на Lua in Moscow 17 июня!", "image": ["https://habrastorage.org/web/211/2b4/e68/2112b4e681b14fc8ad6e0a4c8c0f3d3e.png", "https://habrastorage.org/web/db8/66d/1ba/db866d1ba055471fb9fb8fb268510985.png"], "tag": ["lua", "highload", "встреча разработчиков", "gamedev", "devconf"], "rating": ["+25"], "bookmarks": ["9"], "views": ["3,5k"], "comments_count": []},
{"author": ["vlfedotov"], "date": [" 9 мая в 19:08"], "hubs": ["Разработка игр", "Lua"], "type_label": [], "text": "Добрый день! Сегодня будем делать классическую игру Space Invaders на движке Love2d. Для любителей «кода сразу» окончательную версию игры можно посмотреть на гитхабе. Тем же кому интересен процесс разработки, добро пожаловать под кат. Здесь я не смогу описать всего, что есть в окончательной версии, это и не интересно и сделает статью бесконечной. Могу сказать, что кроме того, что я разберу здесь, игра содержит разные режимы (пауза, проигрыш, выигрыш), может выводить отладочную информацию (скорость и количество объектов, память, пр.), у Игрока есть жизни и ведётся счёт, существуют разные уровни игры (не сложность, а последовательность). Всё это либо можно посмотреть в коде, либо разработать собственные варианты. Итак, план работы: Подготовка Добавляем игрока Врагов Стены и обработчик коллизий Учим игрока стрелять Прикрепляем графику Подготовка В main.lua добавим вызовы основных методов love2d. Каждый элемент или функция, которые мы сделаем впоследствии должны прямо или косвенно быть связаны с этими методами, иначе пройдут незамеченными. function love.load() end function love.keyreleased( key ) end function love.draw() end function love.update( dt ) end Добавляем игрока Добавляем в корень проекта файл player.lua local player = {} player.position_x = 500 player.position_y = 550 player.speed_x = 300 player.width = 50 player.height = 50 function player.update( dt ) if love.keyboard.isDown( \"right\" ) and player.position_x < ( love.graphics.getWidth() - player.width ) then player.position_x = player.position_x + ( player.speed_x * dt ) end if love.keyboard.isDown( \"left\" ) and player.position_x > 0 then player.position_x = player.position_x - ( player.speed_x * dt ) end end function player.draw() love.graphics.rectangle( \"fill\", player.position_x, player.position_y, player.width, player.height ) end return player А также обновим main.lua local player = require 'player' function love.draw() player.draw() end function love.update( dt ) player.update( dt ) end Если запустить игру, то мы увидим чёрный экран с белым квадратом снизу, которым можно управлять клавишами «влево» и «вправо». Причём выйти за пределы экрана он не может в силу ограничений в коде Игрока: player.position.x < ( love.graphics.getWidth() - player.width ) player.position.x > 0 Добавим врагов Так как бороться мы будем против иноземных захватчиков, то и файлик с ними назовём invaders.lua: local invaders = {} invaders.rows = 5 invaders.columns = 9 invaders.top_left_position_x = 50 invaders.top_left_position_y = 50 invaders.invader_width = 40 invaders.invader_height = 40 invaders.horizontal_distance = 20 invaders.vertical_distance = 30 invaders.current_speed_x = 50 invaders.current_level_invaders = {} local initial_speed_x = 50 local initial_direction = 'right' function invaders.new_invader( position_x, position_y ) return { position_x = position_x, position_y = position_y, width = invaders.invader_width, height = invaders.invader_height } end function invaders.new_row( row_index ) local row = {} for col_index=1, invaders.columns - (row_index % 2) do local new_invader_position_x = invaders.top_left_position_x + invaders.invader_width * (row_index % 2) + (col_index - 1) * (invaders.invader_width + invaders.horizontal_distance) local new_invader_position_y = invaders.top_left_position_y + (row_index - 1) * (invaders.invader_height + invaders.vertical_distance) local new_invader = invaders.new_invader( new_invader_position_x, new_invader_position_y ) table.insert( row, new_invader ) end return row end function invaders.construct_level() invaders.current_speed_x = initial_speed_x for row_index=1, invaders.rows do local invaders_row = invaders.new_row( row_index ) table.insert( invaders.current_level_invaders, invaders_row ) end end function invaders.draw_invader( single_invader ) love.graphics.rectangle('line', single_invader.position_x, single_invader.position_y, single_invader.width, single_invader.height ) end function invaders.draw() for _, invader_row in pairs( invaders.current_level_invaders ) do for _, invader in pairs( invader_row ) do invaders.draw_invader( invader, is_miniboss ) end end end function invaders.update_invader( dt, single_invader ) single_invader.position_x = single_invader.position_x + invaders.current_speed_x * dt end function invaders.update( dt ) local invaders_rows = 0 for _, invader_row in pairs( invaders.current_level_invaders ) do invaders_rows = invaders_rows + 1 end if invaders_rows == 0 then invaders.no_more_invaders = true else for _, invader_row in pairs( invaders.current_level_invaders ) do for _, invader in pairs( invader_row ) do invaders.update_invader( dt, invader ) end end end end return invaders Обновим main.lua ... local invaders = require 'invaders' function love.load() invaders.construct_level() end function love.draw() ... invaders.draw() end function love.update( dt ) ... invaders.update( dt ) end love.load вызывается в самом начале работы приложения. Он вызывает метод invaders.construct_level, который создаёт таблицу invaders.current_level_invaders и наполняет её по строкам и столбцам отдельными объектами invader с учётом высоты и ширины объектов, а также требуемого расстояния между ними по горизонтали и вертикали. Пришлось немного усложнить метод invaders.new_row, чтобы добиться смещения чётных и нечётных рядов. Если заменить текущую конструкцию: for col_index=1, invaders.columns - (row_index % 2) do local new_invader_position_x = invaders.top_left_position_x + invaders.invader_width * (row_index % 2) + (col_index - 1) * (invaders.invader_width + invaders.horizontal_distance) вот такой: for col_index=1, invaders.columns do local new_invader_position_x = invaders.top_left_position_x + (col_index - 1) * (invaders.invader_width + invaders.horizontal_distance) то уберём этот эффект и вернём прямоугольное заполнение. Сравнение на картинках Текущий вариант Прямоугольный вариант Объект invader представляет собой таблицу со свойствами: position_x, position_y, width, height. Всё это требуется для отрисовки объекта, а также позднее потребуется для проверки на коллизии с выстрелами. love.draw вызывает invaders.draw и отрисовываются все объекты во всех рядах таблицы invaders.current_level_invaders. love.update, а следом и invaders.update обновляют текущую позицию каждого захватчика с учётом текущей скорости, которая пока только одна — изначальная. Захватчики уже начали двигаться, но пока только вправо, за экран. Это мы сейчас поправим. Добавим стены и коллизии Новый файл walls.lua local walls = {} walls.wall_thickness = 1 walls.bottom_height_gap = 1/5 * love.graphics.getHeight() walls.current_level_walls = {} function walls.new_wall( position_x, position_y, width, height ) return { position_x = position_x, position_y = position_y, width = width, height = height } end function walls.construct_level() local left_wall = walls.new_wall( 0, 0, walls.wall_thickness, love.graphics.getHeight() - walls.bottom_height_gap ) local right_wall = walls.new_wall( love.graphics.getWidth() - walls.wall_thickness, 0, walls.wall_thickness, love.graphics.getHeight() - walls.bottom_height_gap ) local top_wall = walls.new_wall( 0, 0, love.graphics.getWidth(), walls.wall_thickness ) local bottom_wall = walls.new_wall( 0, love.graphics.getHeight() - walls.bottom_height_gap - walls.wall_thickness, love.graphics.getWidth(), walls.wall_thickness ) walls.current_level_walls[\"left\"] = left_wall walls.current_level_walls[\"right\"] = right_wall walls.current_level_walls[\"top\"] = top_wall walls.current_level_walls[\"bottom\"] = bottom_wall end function walls.draw_wall(wall) love.graphics.rectangle( 'line', wall.position_x, wall.position_y, wall.width, wall.height ) end function walls.draw() for _, wall in pairs( walls.current_level_walls ) do walls.draw_wall( wall ) end end return walls И немного в main.lua ... local walls = require 'walls' function love.load() ... walls.construct_level() end function love.draw() ... -- walls.draw() end Аналогично с созданием захватчиков, за создание стен отвечает вызов walls.construct_level. Стены нам нужны только для перехвата «столкновений» с ними захватчиков и выстрелов, поэтому отрисовывать их нам без надобности. Но это может понадобиться для целей отладки, поэтому у объекта Walls имеется метод draw, вызов которого происходит стандартно из main.lua -> love.draw, но пока отладка не нужна — он (вызов) закомментирован. Теперь напишем обработчик коллизий, который был мной позаимствован отсюда. Итак, collisions.lua local collisions = {} function collisions.check_rectangles_overlap( a, b ) local overlap = false if not( a.x + a.width < b.x or b.x + b.width < a.x or a.y + a.height < b.y or b.y + b.height < a.y ) then overlap = true end return overlap end function collisions.invaders_walls_collision( invaders, walls ) local overlap, wall if invaders.current_speed_x > 0 then wall, wall_type = walls.current_level_walls['right'], 'right' else wall, wall_type = walls.current_level_walls['left'], 'left' end local a = { x = wall.position_x, y = wall.position_y, width = wall.width, height = wall.height } for _, invader_row in pairs( invaders.current_level_invaders ) do for _, invader in pairs( invader_row ) do local b = { x = invader.position_x, y = invader.position_y, width = invader.width, height = invader.height } overlap = collisions.check_rectangles_overlap( a, b ) if overlap then if wall_type == invaders.allow_overlap_direction then invaders.current_speed_x = -invaders.current_speed_x if invaders.allow_overlap_direction == 'right' then invaders.allow_overlap_direction = 'left' else invaders.allow_overlap_direction = 'right' end invaders.descend_by_row() end end end end end function collisions.resolve_collisions( invaders, walls ) collisions.invaders_walls_collision( invaders, walls ) end return collisions Добавим пару методов и переменную в invaders.lua invaders.allow_overlap_direction = 'right' function invaders.descend_by_row_invader( single_invader ) single_invader.position_y = single_invader.position_y + invaders.vertical_distance / 2 end function invaders.descend_by_row() for _, invader_row in pairs( invaders.current_level_invaders ) do for _, invader in pairs( invader_row ) do invaders.descend_by_row_invader( invader ) end end end И добавим проверку на коллизии в main.lua local collisions = require 'collisions' function love.update( dt ) ... collisions.resolve_collisions( invaders, walls ) end Теперь захватчики натыкаются на стену collisions.invaders_walls_collision и спускаются немного пониже, а также меняют скорость на противоположную. Пришлось ввести дополнительную проверку на равенство типа той стены, на которую наткнулись захватчики, и переменной, в которой хранится допустимый тип: if overlap then if wall_type == invaders.allow_overlap_direction then ... из-за того, что на стену натыкаются сразу все захватчики одновременно из крайнего столбца и обработчик коллизий успевает «для каждого» отработать и снизить на один ряд весь коллектив, прежде чем, захватчики развернутся и выйдут из соприкосновений, в итоге армада спускалась сразу на несколько рядов. Тут либо ставить какой-нибудь блок при возникновении одной коллизии на ближайшие коллизии, либо расставлять захватчиков не точно один под другим, либо так как сделано, либо как-то ещё. Пора игроку научиться стрелять Новый файлик и класс bullets.lua local bullets = {} bullets.current_speed_y = -200 bullets.width = 2 bullets.height = 10 bullets.current_level_bullets = {} function bullets.destroy_bullet( bullet_i ) bullets.current_level_bullets[bullet_i] = nil end function bullets.new_bullet(position_x, position_y) return { position_x = position_x, position_y = position_y, width = bullets.width, height = bullets.height } end function bullets.fire( player ) local position_x = player.position_x + player.width / 2 local position_y = player.position_y local new_bullet = bullets.new_bullet( position_x, position_y ) table.insert(bullets.current_level_bullets, new_bullet) end function bullets.draw_bullet( bullet ) love.graphics.rectangle( 'fill', bullet.position_x, bullet.position_y, bullet.width, bullet.height ) end function bullets.draw() for _, bullet in pairs(bullets.current_level_bullets) do bullets.draw_bullet( bullet ) end end function bullets.update_bullet( dt, bullet ) bullet.position_y = bullet.position_y + bullets.current_speed_y * dt end function bullets.update( dt ) for _, bullet in pairs(bullets.current_level_bullets) do bullets.update_bullet( dt, bullet ) end end return bullets Здесь основной метод — bullets.fire. Мы передаём в него Игрока, т.к. хотим, чтобы пуля вылетала «из него», а значит нам надо знать его местоположение. Т.к. патрон у нас не один, а возможна целая очередь, то храним её в таблице bullets.current_level_bullets, вызываем для неё и каждого патрона методы draw и update. Метод bullets.destroy_bullet нужен, чтобы при соприкосновении с захватчиком или потолком удалять лишние патроны из памяти. Добавим обработку коллизий пуля-захватчик и пуля-потолок. collisions.lua function collisions.invaders_bullets_collision( invaders, bullets ) local overlap for b_i, bullet in pairs( bullets.current_level_bullets) do local a = { x = bullet.position_x, y = bullet.position_y, width = bullet.width, height = bullet.height } for i_i, invader_row in pairs( invaders.current_level_invaders ) do for i_j, invader in pairs( invader_row ) do local b = { x = invader.position_x, y = invader.position_y, width = invader.width, height = invader.height } overlap = collisions.check_rectangles_overlap( a, b ) if overlap then invaders.destroy_invader( i_i, i_j ) bullets.destroy_bullet( b_i ) end end end end end function collisions.bullets_walls_collision( bullets, walls ) local overlap local wall = walls.current_level_walls['top'] local a = { x = wall.position_x, y = wall.position_y, width = wall.width, height = wall.height } for b_i, bullet in pairs( bullets.current_level_bullets) do local b = { x = bullet.position_x, y = bullet.position_y, width = bullet.width, height = bullet.height } overlap = collisions.check_rectangles_overlap( a, b ) if overlap then bullets.destroy_bullet( b_i ) end end end function collisions.resolve_collisions( invaders, walls, bullets ) ... collisions.invaders_bullets_collision( invaders, bullets ) collisions.bullets_walls_collision( bullets, walls ) end К захватчикам добавим метод для его уничтожения, а также для проверки на наличие захватчиков в конкретном ряду в общей таблице захватчиков — если никого не осталось, то и сам ряд удаляем. А также увеличиваем скорость всей армады при убийстве. invaders.lua ... invaders.speed_x_increase_on_destroying = 10 function invaders.destroy_invader( row, invader ) invaders.current_level_invaders[row][invader] = nil local invaders_row_count = 0 for _, invader in pairs( invaders.current_level_invaders[row] ) do invaders_row_count = invaders_row_count + 1 end if invaders_row_count == 0 then invaders.current_level_invaders[row] = nil end if invaders.allow_overlap_direction == 'right' then invaders.current_speed_x = invaders.current_speed_x + invaders.speed_x_increase_on_destroying else invaders.current_speed_x = invaders.current_speed_x - invaders.speed_x_increase_on_destroying end end ... И обновляем mail.lua: добавляем новый класс, отправляем его в обработчик коллизий, и вешаем вызов стрельбы на клавишу Space. ... local bullets = require 'bullets' function love.keyreleased( key ) if key == 'space' then bullets.fire( player ) end end function love.draw() ... bullets.draw() end function love.update( dt ) ... collisions.resolve_collisions( invaders, walls, bullets ) bullets.update( dt ) end Дальнейшая работа предполагает модификацию существующего кода, поэтому то, что получилось на данном этапе сохраняем как версию 0.5. NB Код в гите отличается от разобранного здесь. Изначально использовалась библиотека hump для работы с векторами. Но потом стало ясно, что вполне можно обойтись и без неё, и в окончательной редакции выпилил библиотеку. Код одинаково рабочий и здесь и там, единственно, для запуска кода с гитхаба придётся проинициировать сабмодули: git submodule update --init Навешиваем текстуры Это три стандартных врага, плюс один минибосс, устройство которого здесь рассмотрено не будет, но он есть в окончательной версии. И сам игрок-танк. Текстуры для игры любезно предоставила annnushkkka. Все картинки будут находиться в каталоге images в корне проекта. Меняем Игрока в player.lua ... player.image = love.graphics.newImage('images/Hero.png') -- from https://love2d.org/forums/viewtopic.php?t=79756 function getImageScaleForNewDimensions( image, newWidth, newHeight ) local currentWidth, currentHeight = image:getDimensions() return ( newWidth / currentWidth ), ( newHeight / currentHeight ) end local scaleX, scaleY = getImageScaleForNewDimensions( player.image, player.width, player.height ) function player.draw() -- меняем полностью love.graphics.draw(player.image, player.position_x, player.position_y, rotation, scaleX, scaleY ) end ... Фнкция getImageScaleForNewDimensions, подсмотренная вот отсюда, подгоняет картинку под те размеры, которые мы указали в player.width, player.height. Она используется и здесь и для врагов, впоследствии вынесем её в отдельный модуль utils.lua. Функцию player.draw заменяем. При запуске бывший игрок-квадрат теперь — танк! Меняем врагов invaders.lua ... invaders.images = {love.graphics.newImage('images/bad_1.png'), love.graphics.newImage('images/bad_2.png'), love.graphics.newImage('images/bad_3.png') } -- from https://love2d.org/forums/viewtopic.php?t=79756 function getImageScaleForNewDimensions( image, newWidth, newHeight ) local currentWidth, currentHeight = image:getDimensions() return ( newWidth / currentWidth ), ( newHeight / currentHeight ) end local scaleX, scaleY = getImageScaleForNewDimensions( invaders.images[1], invaders.invader_width, invaders.invader_height ) function invaders.new_invader(position_x, position_y ) -- меняем local invader_image_no = math.random(1, #invaders.images) invader_image = invaders.images[invader_image_no] return ({position_x = position_x, position_y = position_y, width = invaders.invader_width, height = invaders.invader_height, image = invader_image}) end function invaders.draw_invader( single_invader ) -- меняем love.graphics.draw(single_invader.image, single_invader.position_x, single_invader.position_y, rotation, scaleX, scaleY ) end Добавляем картинки врагов в таблице и подгоняем размеры через getImageScaleForNewDimensions. При создании нового захватчика ему в атрибут image присваивается рандомная картинка из нашей таблицы картинок. И меняем сам метод отрисовки. Вот что вышло: Если позапускать игру несколько раз, то можно увидеть, что рандомная комбинация врагов каждый раз одинаковая. Чтобы этого избежать надо определить math.randomseed перед началом игры. Хорошо это делать, передавая в качестве аргумента os.time. Добавим это в main.lua function love.load() ... math.randomseed( os.time() ) ... end Теперь у нас есть почти полноценная игра, версия 0.75. Разобрали всё, что планировали. Буду рад отзывам, комментариям, подсказкам!", "image": ["https://habrastorage.org/web/92a/03a/066/92a03a0667b54bf4aee39deb4ef5752d.png", "https://habrastorage.org/web/1e7/85e/166/1e785e16664545d8a3847a888da7fb32.png", "https://habrastorage.org/web/17f/9e6/e92/17f9e6e92dcc468e808b9ec4ddefc24f.png", "https://habrastorage.org/web/be4/392/9c1/be43929c136d4c08955a23d847cf6dda.png", "https://habrastorage.org/web/399/282/0aa/3992820aa7eb489695770c7f7383096f.png"], "tag": ["gamedev", "lua", "love2d", "classic games", "space invaders"], "rating": ["+17"], "bookmarks": ["52"], "views": ["5,2k"], "comments_count": ["7"]},
{"author": ["romy4"], "date": ["25 сентября в 09:37"], "hubs": ["Высокая производительность", "PHP", "Lua"], "type_label": [], "text": "Кратко: nginx не умеет пулить websockets, а php работает per request. Нужна прослойка которая будет держать открытыми вебсокеты и при поступлении данных соединяться с php (через тот же fastcgi) и отправлять обратно ответ. update: Здесь не идётся про решения на php, так как по сравнению даже с nodejs, они гораздо медленнее. Тема, как оказалось, не нова, исходники тянуться аж из 2014, но, тем не менее, информации о трюке, про который здесь пойдёт речь, крайне мало. Можете погуглить \"websockets php\". Усугубляется тема ещё тем, что найденные примеры реализации (два, точнее) не работают, включая тот, что в документации :) Вот где-то внутри чувствовал, знал, что есть. Мне настолько давно хотелось иметь этот Middleware внутри Nginx, чтобы не использовать разные довольно медленные php библиотеки (раз и два) и обойти стороной однопоточность nodejs. А вебсокетов хочется много (и как можно больше), и чтобы лишние затраты на прослойку были поменьше. Так вот, дабы не плодить кучу машин с nodejs (в будущем при высоких нагрузках так и поступают обычно), воспользуемся тем, что предоставляет Nginx с некоторыми пристройками в виде lua + resty. Nginx+lua можно установить из пакета nginx-extras или же собрать самому. От Resty нам понадобятся только websockets. Скачиваем и закидываем содержимое каталога lib куда-нибудь себе в пути (у меня это /home/username/lib/lua/lib, а по-хорошему надо бы в /usr/local/share/lua). Стандартно nginx+websockets работает так: Клиент соединяется с nginx Nginx проксирует в upstream/открывает прокси поток с другим сервером (Middle Server на основе nodejs + sockets.io например), обслуживающим websockets. Middle Server сервер кидает socket соединение в какой-нибудь слушатель событий типа epoll и ждёт данных. При получении данных, Middle Server сервер, в свою очередь, открывает Fastcgi соединение с php, ожидает и забирает ответ. Отправляет его в socket. Возвращает socket снова в ожидание данных. И так по кругу, пока не прийдёт специальный фрейм закрытия websocket. Всё просто, кроме накладных расходов на ресурсы и однопоточность этого решения. В предлагаемой схеме MiddleServer превращается в middleware внутри nginx. К тому же нет никакого ожидания Fastcgi, всю работу делает тот же epoll, к которому nginx доверяет открытый сокет, а тем временем поток nginx'a может заняться другими делами. Схема позволяет одновременно работать с кучей вебсокетов раскиданными по потокам. Здесь приведу только упрощённый код, который относится к задаче без остальных настроек хостинга. Я не старался сделать правильными все заголовки за ненадобностью оных. lua_package_path \"/home/username/lib/lua/lib/?.lua;;\"; server { # магия, которая держит вебсокет открытым столько, сколько нам надо внутри nginx location ~ ^/ws/?(.*)$ { default_type 'plain/text'; # всё что надо здесь для веб сокета - это включить луа, который будет его хендлить content_by_lua_file /home/username/www/wsexample.local/ws.lua; } # а это магия, которая отдаёт ответы от php # я шлю только POST запросы, чтобы нормально передать json payload location ~ ^/lua_fastcgi_connection(/?.*)$ { internal; # видно только подзапросам внутри nginx fastcgi_pass_request_body on; fastcgi_pass_request_headers off; # never never use it for lua handler #include snippets/fastcgi-php.conf; fastcgi_param QUERY_STRING $query_string; fastcgi_param REQUEST_METHOD \"POST\"; # $request_method; fastcgi_param CONTENT_TYPE \"application/x-www-form-urlencoded\"; #вместо $content_type; fastcgi_param CONTENT_LENGTH $content_length; fastcgi_param DOCUMENT_URI \"$1\"; # вместо $document_uri fastcgi_param DOCUMENT_ROOT $document_root; fastcgi_param SERVER_PROTOCOL $server_protocol; fastcgi_param REQUEST_SCHEME $scheme; fastcgi_param HTTPS $https if_not_empty; fastcgi_param GATEWAY_INTERFACE CGI/1.1; fastcgi_param SERVER_SOFTWARE nginx/$nginx_version; fastcgi_param REMOTE_ADDR $remote_addr; fastcgi_param REMOTE_PORT $remote_port; fastcgi_param SERVER_ADDR $server_addr; fastcgi_param SERVER_PORT $server_port; fastcgi_param SERVER_NAME $server_name; fastcgi_param SCRIPT_FILENAME \"$document_root/mywebsockethandler.php\"; fastcgi_param SCRIPT_NAME \"/mywebsockethandler.php\"; fastcgi_param REQUEST_URI \"$1\"; # здесь вообще может быть что угодно. А можно передать параметр из lua чтобы сделать какой-нибудь роутинг внутри php обработчика. fastcgi_pass unix:/var/run/php/php7.1-fpm.sock; fastcgi_keep_conn on; } И код ws.lua: local server = require \"resty.websocket.server\" local wb, err = server:new{ -- timeout = 5000, -- in milliseconds -- не надо нам таймаут max_payload_len = 65535, } if not wb then ngx.log(ngx.ERR, \"failed to new websocket: \", err) return ngx.exit(444) end while true do local data, typ, err = wb:recv_frame() if wb.fatal then return elseif not data then ngx.log(ngx.DEBUG, \"Sending Websocket ping\") wb:send_ping() elseif typ == \"close\" then -- send a close frame back: local bytes, err = wb:send_close(1000, \"enough, enough!\") if not bytes then ngx.log(ngx.ERR, \"failed to send the close frame: \", err) return end local code = err ngx.log(ngx.INFO, \"closing with status code \", code, \" and message \", data) break; elseif typ == \"ping\" then -- send a pong frame back: local bytes, err = wb:send_pong(data) if not bytes then ngx.log(ngx.ERR, \"failed to send frame: \", err) return end elseif typ == \"pong\" then -- just discard the incoming pong frame elseif data then -- здесь в пути передаётся реальный uri, а json payload уходит в body local res = ngx.location.capture(\"/lua_fastcgi_connection\"..ngx.var.request_uri,{method=ngx.HTTP_POST,body=data}) if wb == nil then ngx.log(ngx.ERR, \"WebSocket instaince is NIL\"); return ngx.exit(444) end wb:send_text(res.body) else ngx.log(ngx.INFO, \"received a frame of type \", typ, \" and payload \", data) end end Что ещё можно с этим сделать? Замерить скорость и сравнить с nodejs :) А можно внутри lua делать запросы в Redis, MySQL, Postgres… проверять куки и прочие токены авторизации, обрабатывать сессии, кешировать ответы в memcached и потом быстро-быстро отдавать другим клиентам с одинаковыми запросами внутри websocket. Известные мне недоработки: максимальный размер пакета данных по вебсокету 65Кб. При желании можно дописать разбитие на фреймы. Протокол не сложный. Тестовый html (ws.html): HTML тут<!DOCTYPE> <html> <head> <meta charset=\"utf-8\" /> <script type=\"text/javascript\"> \"use strict\"; let socket; function tryWebSocket() { socket = new WebSocket(\"ws://try6.local/ws/\"); socket.onopen = function() { console.log(\"Соединение установлено.\"); }; socket.onclose = function(event) { if (event.wasClean) { console.log('Соединение закрыто чисто'); } else { console.log('Обрыв соединения'); // например, \"убит\" процесс сервера } console.log('Код: ' + event.code + ' причина: ' + event.reason); }; socket.onmessage = function(event) { console.log(\"Получены данные \" + event.data); }; socket.onerror = function(error) { console.log(\"Ошибка \" + error.message); }; } function tryWSSend(event) { let msg = document.getElementById('msg'); socket.send(msg.value); event.stopPropagation(); event.preventDefault(); return false; } function closeWebSocket(event) { socket.close(); } </script> </head> <body onLoad=\"tryWebSocket(event);return false;\"> <form onsubmit=\"tryWSSend(event); return false;\"> <button onclick=\"tryWebSocket(event); return false;\">Try WebSocket</button> <fieldset> Message: <input value=\"Test message 4444\" type=\"text\" size=\"10\" id=\"msg\"/><input type=\"submit\"/> </fieldset> <fieldset> <button onclick=\"closeWebSocket(event); return false;\">Close Websocket</button><br/> </fieldset> </form> </body> </html> Тестовый php (mywebsockethandler.php): PHP тут<?php header(\"Content-Type: application/json; charset=utf-8\"); echo json_encode([\"status\"=>\"ok\",\"response\"=>\"php websocket json @ \".time(), \"payload\"=>[$_REQUEST,$_SERVER]]); exit; Чтобы воспользоваться FastCGI для Lua, установите ещё одно Resty расширение.", "image": ["https://habrastorage.org/web/a77/c68/c23/a77c68c23f3c4eddaab2c77a372d96d0.png"], "tag": ["fastcgi", "php", "websockets", "nginx", "lua", "highload", "nodejs", "lua-nginx-module"], "rating": ["+12"], "bookmarks": ["105"], "views": ["6,1k"], "comments_count": ["30"]},
{"author": ["RussDragon"], "date": [" 6 февраля в 18:49"], "hubs": ["Разработка игр", "Программирование", "Алгоритмы", "Lua"], "type_label": ["Tutorial"], "text": "Предисловие → Первая часть Итак. Оценив отклик аудитории Хабра и разобравшись с делами, я принялся за написание второй статьи из цикла. Реакция публики оказалась значительно позитивнее моих предположений, а значит, мы продолжаем разговор на одну из любопытнейших тем процедурной генерации – создание лабиринтов. В этой части мы поговорим о том, что же такое случайная и псевдослучайная генерации, какие алгоритмы могут дать нам равновероятно ничем не похожие друг на друга лабиринты и в чем их минусы. Героями нашего сегодняшнего приключения станут алгоритм Уилсона и алгоритм Олдоса-Бродера для создания случайного остовного дерева (Uniform Spanning Tree). ОСТОРОЖНО ТРАФИК. Давайте вспомним, что такое идеальные лабиринты, о которых идет речь. Если из каждой вершины графа в любую другую имеется ровно один путь и нельзя пройти все вершины, не пройдя по одному и тому же ребру дважды, то мы называем такой граф остовным деревом. Если в рассматриваемом лабиринте из каждой клетки в любую другую имеется ровно один проход и нельзя посетить все клетки, не пройдя через один и тот же коридор дважды, то мы говорим, что такой лабиринт идеальный. Смысл не меняется по одной простой причине – лабиринты и есть графы, о чём я писал в прошлой статье. Если Вы её ещё не читали, настоятельно советую пролистать немного выше, перейти по ссылке и ознакомиться с ней, прежде чем идти дальше. И хотя представленные в этой части алгоритмы весьма медленные и «глупые», с ними необходимо разобраться, так как они являют собой фундамент для всей нашей темы и для всех моих статей. Главная причина, почему я сразу не начал с них – Уилсон не очень прост в реализации и понимании для начинающих, что не мешает быть ему крайне любопытным. Про LuaВ алгоритме Уилсона, и, возможно, в некоторых других, о которых я буду писать, для выбора случайной еще не посещенной клетки используется функция next (table [, index]). Её описание из официальной документации Lua: Позволяет программе получить все поля таблицы. Первый параметр – это таблица, второй – индекс в этой таблице. next возвращает следующий индекс в таблице и соответствующее ему значение. Если второй параметр nil, next возвращает начальный индекс и связанное с ним значение. При вызове последнего индекса, или с nil в пустой таблице, next возвращает nil. Если второй параметр отсутствует, он интерпретируется как nil. В частности, Вы можете использовать next(t) для проверки пустая таблица или нет. Следовательно, вместо того, чтобы выбирать клетку с помощью math.random и проверять, обработана ли она или использовать связку стэк-клеток вместе с хэш-таблицей для отслеживания местоположения в нем, можно использовать лишь одну хэш-таблицу, ключи в которой будут захэшироваными координатами и брать элементы из неё с помощью next. key = next(cellsHash, nil) local start_x, start_y = aux.deHashKey(key) cellsHash[key] = nil — Напомню, присваивание nil удаляет элемент/поле Смещение и случайность Что мы подразумеваем под случайной генерацией? Можем ли мы сказать, что если во втором лабиринте, в отличии от первого, отсутствует две стенки на юге, то они полностью случайны? Или если первый лабиринт имеет на два горизонтальных коридора больше? И да, и нет. Говоря о случайности в лабиринтах, мы должны четко осознавать, что имеем в виду. Давайте посмотрим на результат работы алгоритма двоичного дерева: Как видим, хотя лабиринты сами по себе совершенно разные, смещение у них слабо отличается. Мы получили случайный результат? Да. Можем ли мы его таковым считать? Ну, по-моему мнению, нет. Проблема в смещении (bias), которое во многом определяет «случайность». Алгоритмы, которые по определению должны создавать случайные лабиринты, в итоге создают похожие. Если «похожесть» ярко выражена, как в двоичном дереве, мы говорим, что такой лабиринт легко решается. Если же при сравнении нескольких лабиринтов нам трудно однозначно сказать, к чему тяготеет алгоритм, мы говорим, что такой лабиринт решается сложнее. Для нахождения смещение, нам нужно сравнить несколько результатов генерации и построить статистическую модель, по которой бы мы могли написать более умный поиск пути или самим, «более умно» решать лабиринты такого типа. Например, мы можем сказать, что алгоритм двоичного дерева имеет в n раз больше горизонтальных проходов, чем вертикальных. Значит, можно будет учесть данные и ускорить процесс нахождения выхода. А что если мы хотим, чтобы смещения вообще не было? Чтобы из, к примеру, 9 не связанных точек графа, каждый раз мы получали совершенно непохожее на остальные остовное дерево? Тогда нам нужно, чтобы каждое из направлений для алгоритма было равноценно. Значит, мы разрешаем проходить по уже пройденным вершинам, следовательно, в каждой итерации цикла будем случайно выбирать одно из четырех направлений вне зависимости от того, были ли мы там или нет. Единственное условие – не выходить за рамки поля. К слову о термине Uniform Spanning Tree. Мы уже знаем, что такое остовное дерево. Соединив все вершины графа ребрами так, чтобы из любой вершины в другую нельзя было попасть, не пройдя одно и то же ребро дважды, мы получим остовное дерево. Но ведь если вершин в графе более двух, то и вариаций деревьев может быть больше, верно? Так вот, Uniform Spanning Tree – одна равновероятно выбранная вариация остовного дерева в некотором графе. И так. Мы хотим совершенно случайные, совершенно непохожие друг на друга лабиринты, и даже готовы пожертвовать скоростью. Тогда давайте познакомимся с алгоритмами Олдоса-Бродера и Уилсона. Алгоритм Олдоса-Бродера Описание Помните я говорил, что алгоритм двоичного дерева самый простой в понимании? Так вот, я лукавил. Он действительно проще в реализации, так как там мы имеем дело всегда только с одним направлением и c одним рассматриваемым рядом, но в примитивности и «глупости» алгоритм Олдоса-Бродера ушел далеко вперед. Весь его смысл заключается в том, чтобы бесцельно блуждать по полю в надежде наткнуться на вершину создаваемого остовного дерева и присоединить еще одну, а потом снова случайно выбрать точку в лабиринте и гулять, пока не попадем в одну из соединенных. Олдос-Бродер избавлен от какого-либо смещения. Совершенно. Все лабиринты, получаемые с его помощью, абсолютно случайны и не похожи друг на друга. Алгоритм не имеет предпочтений по направленности, запутанности или ещё каким-либо характеристикам. Результирующие лабиринты случайны и равновероятны. Проблемой может стать несовершенство генераторов случайных чисел, которые сами могут тяготеть к каким-либо значениям и выдавать их чаще. Но если использовать, к примеру, генератор случайности на основе природного шума (ветра, распада урана), то, пожалуй, вы сможете, наконец, в полной мере насладиться работой алгоритма. Надо признать, наблюдение за его работой поистине даёт осознание всей тленности и бессмысленности бытия. Чтобы записать гифку с его анимацией, я потратил очень немало времени, так как укладываться в 30 секунд в поле 5×5 он упорно не хотел. Когда оставалось соединить всего одну последнюю непроверенную клетку к остовному дереву, Олдос-Бродер уходил в другой угол и наматывал там круги. Пришлось значительно увеличить скорость анимации и уменьшить поле, чтобы, наконец, он успел обойти все клетки лабиринта. Его создали два независимых исследователя, изучавших равновероятные варианты остовных деревьев: Дэвид Олдос, профессор Калифорнийского университета Беркли и Андрей Бродер, учёный, ныне работающий в Google. Однозначно сказать, в какой сфере данные исследования были бы полезны, трудно. Однако, кроме лабиринтов, алгоритм часто всплывает в работах о математической вероятности, что, впрочем, неудивительно, учитывая принцип его работы. Формальный алгоритм: Выбрать случайную вершину (клетку). Абсолютно случайную; Выбрать случайную соседнюю вершину (клетку) и перейти в неё. Если она не была посещена, добавить её в дерево (соединить с предыдущей, убрать между ними стену); Повторять шаг 2, пока все клетки не будут посещены. Пример работыКрасным цветом выделено наше текущее положение на поле. Начинаем с левого верхнего угла. Тут ничего необычного. Случайным образом решаем пойти направо и убрать стенку между двумя клетками. Хорошо, делаем. Неповезло. Наш ГСЧ говорит, чтобы мы пошли обратно, то есть налево. А теперь вниз. Попутно соединяем все непосещенные клетки и убираем между ними стены. Еще раз повезло. Вниз! Ладно, один возврат назад можно простить. Выбираем пойти направо и убираем стену. А тут нам дважды невезет и мы возвращаемся в самое начало. Выбор дважды пал пойти направо. Отлично, хоть какое-то разнообразие. Спускаемся ниже и убираем стену. А вот тут мы хоть и перемещаемся в соседнюю клетку, стену не убираем, так как они уже в одном и том же дереве. Пришло время бесцельно поблуждать, погулять. Возвращаемся к клетке 2-2 и спускамся ниже, убирая стенку. Завершаем нашу проголку и получаем сгенерированный лабиринт. Плюсы: Отсутствует какое-либо смещение; Лабиринты абсолютно случайны, поэтому невозможно создать определенный алгоритм их решения; Сложность решения для человека; Простая реализация; Минусы: Скорость. Пока будет генерироваться лабиринт, Вы успеете состариться и умереть; Не позволяет генерировать бесконечные лабиринты; Сильное падение эффективности под конец генерации; Реализацияlocal mod = {} local aux = {} aux.width = false aux.height = false aux.sx = false aux.sy = false aux.grid = false aux.dirs = {\"UP\", \"DOWN\", \"LEFT\", \"RIGHT\"} function aux.createGrid (rows, columns) local MazeGrid = {} for y = 1, rows do MazeGrid[y] = {} for x = 1, columns do MazeGrid[y][x] = {visited = false, bottom_wall = true, right_wall = true} end end return MazeGrid end function mod.createMaze(x1, y1, x2, y2, grid) aux.width, aux.height, aux.sx, aux.sy = x2, y2, x1, y1 aux.grid = grid or aux.createGrid(y2, x2) aux.aldous_broder() return aux.grid end function aux.aldous_broder() local unvisited_cells = aux.width * aux.height local ix = math.random(aux.sx, aux.width) local iy = math.random(aux.sy, aux.height) aux.grid[iy][ix].visited = true unvisited_cells = unvisited_cells - 1 while unvisited_cells ~= 0 do local dir = aux.dirs[math.random(1, 4)] if dir == \"UP\" then if iy-1 >= aux.sy then if aux.grid[iy-1][ix].visited == false then aux.grid[iy-1][ix].bottom_wall = false aux.grid[iy-1][ix].visited = true unvisited_cells = unvisited_cells - 1 end iy = iy-1 end elseif dir == \"DOWN\" then if iy+1 <= aux.height then if aux.grid[iy+1][ix].visited == false then aux.grid[iy][ix].bottom_wall = false aux.grid[iy+1][ix].visited = true unvisited_cells = unvisited_cells - 1 end iy = iy+1 end elseif dir == \"RIGHT\" then if ix+1 <= aux.width then if aux.grid[iy][ix+1].visited == false then aux.grid[iy][ix].right_wall = false aux.grid[iy][ix+1].visited = true unvisited_cells = unvisited_cells - 1 end ix = ix+1 end elseif dir == \"LEFT\" then if ix-1 >= aux.sx then if aux.grid[iy][ix-1].visited == false then aux.grid[iy][ix-1].right_wall = false aux.grid[iy][ix-1].visited = true unvisited_cells = unvisited_cells - 1 end ix = ix-1 end end end end return mod Алгоритм Уилсона Описание Поздравляю, мы, наконец, добрались до чего-то посерьезнее. Алгоритм Уилсона значительно сложнее всех предыдущих как в реализации, так и в понимании. Цель Уилсона, как и у своего более глупого напарник Олдоса-Бродера – генерация равновероятного случайного остовного дерева. И хотя принцип работы в чем-то схож, детали сильно различаются. В основе алгоритма по-прежнему лежит равновероятный случайный выбор стороны перемещения в лабиринте (графе), с двумя важными отличиями: Перемещаясь по полю мы «запоминаем» все вершины, в которых побывали до момента нахождения вершины остовного дерева. Как только мы натыкаемся на уже добавленную вершину, мы присоединяем получившийся подграф (ветвь) к нашему генерируемому дереву. Если создается цикл в подграфе, то удаляем его. Под циклом я подразумеваю соединение какой-либо вершины, которая уже находится во временном подграф с ним же, но в другой точке. Иначе говоря, не должно быть вершин, у которых больше 2 ребер. Если не понимаете сейчас, не страшно – дальше на примере работы наглядно увидите. После присоединения подграфа к остовному дереву, выбор следующей случайной точки происходит исключительно из еще не присоединенных вершин. Следовательно, в отличии от Олдоса-Бродера, Уилсон лишен недостатка бесцельного блуждания по уже обработанным вершинам. Алгоритм Уилсона, как и Олдос-Бродер, генерирует абсолютно случайные лабиринты без какого-либо смещения. Алгоритм не имеет предпочтений по направленности, запутанности или ещё каким-либо характеристикам. К сожалению, для получения наилучших результатов следует использовать аппаратные генераторы случайных чисел, которые не имеют предпочтений в числах. Сам алгоритм был опубликован Дэвидом Уилсоном в 1996 году в своей работе о генерации равновероятных случайных остовных деревьев. Как и прежде, кроме лабиринтов, материалы всплывают на различных сайтах посвященных математической вероятностям. Более того, мне довелось наткнуться на несколько интересных публикаций, касательно Uniform Spanning Tree и алгоритма Уилсона в частности. Если в одной их них описывается больше сам алгоритм, то в другой в целом само понятие и математическая основа остовных деревьев. Если читателям будет интересно, возможно, я напишу часть 2a, где приведу сами работы и их частичный перевод. Основная причина, почему я избегаю математического обоснования здесь – мои статьи направлены на новичков и людей, которым программирование интереснее сухой математики. Формальный алгоритм: Выбрать случайную вершину, не принадлежащую остовному дереву и добавить её в дерево; Выбрать случайную вершину, не принадлежащую остовному дереву и начать обход графа (лабиринта), пока не придём в уже добавленную вершину дерева; Если образуется цикл, удалить его; Добавить все вершины получившегося подграфа в остовное дерево; Повторять шаги 2-3, пока все вершины не будут добавлены в остовное дерево. Пример работыЗеленом выделена первая вершина дерева. Красным – создаваемая ветвь (подграф). Традиционно, нужно попасть в левый верхний угол. Начинаем строить ветвь с координаты 3-2. Вот сейчас интересный и важный момент. Алгоритм решает пойти наверх, тем самым замкнув ветвь в координате 2-2. Удаляем получившийся цикл и начинаем с 2-2 строить заново. habrastorage.org/files/e9c/8e6/46a/e9c8e646af564a42bbb391fbe263044b.png Отлично, алгоритм решил пойти наверх и тем самым присоединился к основному дереву. Убираем стены на пути и выбираем следующую клетку. Вновь, коснулись созданного недавно дерева, убрали стены и начали заново. Замкнулись, убрали цикл, продолжили с 2-3 заново. Соединились с деревом, очистили от стен путь. Продолжили наше путешествие в новой клетке. Снова соединились с основным деревом, убрали стены, закончили лабиринт. Плюсы: Отсутствует какое-либо смещение; Лабиринты абсолютно случайны, поэтому невозможно создать определенный алгоритм их решения; Сложность решения для человека; Нет бессмысленного блуждания; Скорость по сравнению с Олдос-Бродером в разы больше; Минусы: Непростая реализация; Падения скорости в начале генерации; Большие требования к памяти, чем у Олдос-Бродера; Реализацияlocal mod = {} local aux = {} aux.width = false aux.height = false aux.sx = false aux.sy = false aux.grid = false aux.dirs = {\"UP\", \"DOWN\", \"LEFT\", \"RIGHT\"} function aux.createGrid (rows, columns) local MazeGrid = {} for y = 1, rows do MazeGrid[y] = {} for x = 1, columns do MazeGrid[y][x] = {visited = false, bottom_wall = true, right_wall = true} end end return MazeGrid end function mod.createMaze(x1, y1, x2, y2, grid) aux.width, aux.height, aux.sx, aux.sy = x2, y2, x1, y1 aux.grid = grid or aux.createGrid(y2, x2) aux.wilson() return aux.grid end function aux.hashKey(x, y) return x * aux.height + (y - 1) end function aux.deHashKey(value) return math.floor(value/aux.height), value%aux.height + 1 end function aux.hashCells(grid) local vtable = {} for yk, yv in pairs(grid) do for xk, xv in pairs(yv) do if xv.visited == false then vtable[aux.hashKey(xk, yk)] = xv end end end return vtable end function aux.wilson() local cellsHash = aux.hashCells(aux.grid) -- Вершины, не находящиеся в дереве local dirsStack = {} -- Стак направлений local dsHash = {} local dsSize = 0 -- Создаем дерево local key, v = next(cellsHash, nil) v.visited = true cellsHash[key] = nil while next(cellsHash) do -- Пока есть необработанные вершины, работает key = next(cellsHash, nil) -- Получаем ключ и по нему координаты клетки local start_x, start_y = aux.deHashKey(key) local ix, iy = start_x, start_y while not aux.grid[iy][ix].visited do -- Ходим, пока не найдем относящуюся к дереву клетку local dir = aux.dirs[math.random(1, 4)] local isMoved = false key = aux.hashKey(ix, iy) if dir == \"UP\" and iy-1 >= aux.sy then iy = iy - 1 isMoved = true elseif dir == \"DOWN\" and iy+1 <= aux.height then iy = iy + 1 isMoved = true elseif dir == \"LEFT\" and ix-1 >= aux.sx then ix = ix - 1 isMoved = true elseif dir == \"RIGHT\" and ix+1 <= aux.width then ix = ix + 1 isMoved = true end if isMoved then -- Если мы можем двигаться, тогда проверяем на циклы if dsHash[key] then -- Удаление циклов dirsStack[dsHash[key]].dir = dir for i = dsHash[key]+1, dsSize do local x, y = aux.deHashKey(dirsStack[i].hashref) dsHash[dirsStack[i].hashref] = nil dirsStack[i] = nil dsSize = dsSize - 1 end else local x, y = aux.deHashKey(key) -- Добавление в стак направлений dsSize = dsSize + 1 dsHash[key] = dsSize dirsStack[dsSize] = {dir = dir, hashref = key} end end end for i = 1, dsSize do -- Проквапывание пути aux.grid[start_y][start_x].visited = true cellsHash[aux.hashKey(start_x, start_y)] = nil aux.grid[start_y][start_x].point = false local dir = dirsStack[i].dir if dir == \"UP\" then aux.grid[start_y-1][start_x].bottom_wall = false start_y = start_y - 1 elseif dir == \"DOWN\" then aux.grid[start_y][start_x].bottom_wall = false start_y = start_y + 1 elseif dir == \"LEFT\" then aux.grid[start_y][start_x-1].right_wall = false start_x = start_x - 1 elseif dir == \"RIGHT\" then aux.grid[start_y][start_x].right_wall = false start_x = start_x + 1 end end dsHash, dirsStack, dsSize = {}, {}, 0 -- Обнуление стака направлений end end return mod Эпилог: Суммируя всё выше сказаное, стоит отметить, что хотя мы и добрались до более сложных алгоритмов и разобрались с некоторыми новыми (для кого-то) понятиями графов, главные трудности ещё впереди. Неочевидно запутанные алгоритмы Эллера, Краскала и Прима, основанные исключительно на работе с графами и деревьями, готовят нам непростые, пусть и интересные публикации. Однако, прежде чем приступать к их написанию, следует взглянуть на алгоритмы поиска с возвратом и нечто под названием «Поймать&Убить», чья работа по генерации лабиринта сильно отличается от всех остальных. Намёк на тему следующей статьи я дал. Что ещё. В комментариях к предыдущей части, некоторые люди спрашивали или скидывали свои алгоритмы генерации, что было крайне занимательно и радостно. Если Вы когда-то реализовывали создание лабиринтов своим придуманным способом и можете его сейчас вспомнить – прошу, поделитесь. Может быть, с вашего разрешения, в какой-нибудь из статей я напишу и о нём. Вообще, я рад любым интересным историям и воспоминаниям по теме. Не важно, вспоминаете ли Вы то, как рисовали лабиринты в тетраде в школе или на компьютере в университете. Ну, и как всегда. Пожелания, критика, замечания всегда приветствуются и если Вам нравится тема и хотите видеть следующую часть, напишите об этом в комментариях. Исходники алгоритмов на Луа + рендер на Love2D (код выложен по просьбам в комментариях. Не рефакторился): Github", "image": ["https://habrastorage.org/files/ec0/af2/8bf/ec0af28bf45241ee9de2add7bf33e87b.png", "https://habrastorage.org/files/1f3/f7d/90f/1f3f7d90f0ee4fbba511eaf6c9042dd3.png", "https://habrastorage.org/files/b33/7fd/dcc/b337fddcc18f4f6f9d1690e137c95003.png", "https://habrastorage.org/files/ea9/699/e97/ea9699e97af847d8ae245a20212cdcf7.png", "https://habrastorage.org/files/c19/bf3/0e7/c19bf30e7b8341ee817b014c559e7fe2.png", "https://habrastorage.org/files/084/f65/5b4/084f655b45044098919550948e35f60a.gif", "https://habrastorage.org/files/9f7/838/76a/9f783876affb4a24ba271affe8a3e3ab.gif", "https://habrastorage.org/files/a1a/ac3/20f/a1aac320f9824b96b2af0ec8bc804cfe.png", "https://habrastorage.org/files/e2b/91e/0cb/e2b91e0cb28f48cba245c224b68ca9b6.png", "https://habrastorage.org/files/ce7/d98/8bf/ce7d988bf95f44c4b875cb039a457ca1.png", "https://habrastorage.org/files/a2e/fc2/173/a2efc2173bf54fda8c62a6f74d93e2d6.png", "https://habrastorage.org/files/886/d7e/e2c/886d7ee2c3da4cc4866d421c3013a979.png", "https://habrastorage.org/files/c44/fd5/1ed/c44fd51ed98d41ae9c575587cb616499.png", "https://habrastorage.org/files/5e3/04f/738/5e304f7388114a0385be2f12f3b8a804.png", "https://habrastorage.org/files/366/646/a0b/366646a0b1e14b17ab1be1cec4591ef1.png", "https://habrastorage.org/files/748/9e9/350/7489e9350cae4a57baa4fe49cde97976.png", "https://habrastorage.org/files/28c/189/5af/28c1895afb1f4ec2a5fb2fc9c3ee1610.png", "https://habrastorage.org/files/e5c/d40/beb/e5cd40beb32340a6a2e458efbc5d7ace.png", "https://habrastorage.org/files/70f/8a2/10c/70f8a210c6864405ac08f50d1bdc8c48.png", "https://habrastorage.org/files/746/a79/2f8/746a792f8bbb45ef8ccfee413d222822.png", "https://habrastorage.org/files/f57/ca6/689/f57ca668915746308daa59fbfd7d48ee.png", "https://habrastorage.org/files/ff2/eca/cef/ff2ecacef0e040e496a2f0db7bc55208.png", "https://habrastorage.org/files/177/3c7/97e/1773c797ebd14de9afe28e671186e2c7.png", "https://habrastorage.org/files/89b/e58/dbe/89be58dbe89f447cadda9f2570176278.png", "https://habrastorage.org/files/0a6/e21/5ce/0a6e215ce75f461eb0cd9533d5c0534a.png", "https://habrastorage.org/files/b01/d21/0a4/b01d210a432e4ef791649d70f4d08fc4.png", "https://habrastorage.org/files/fe2/112/aba/fe2112abacea4afda1fac350bfcfd689.png", "https://habrastorage.org/files/45f/26f/d10/45f26fd105dd4306a844d8a1146fecd8.png", "https://habrastorage.org/files/fc9/db9/9b6/fc9db99b62154bfb995b6489e342caed.gif", "https://habrastorage.org/files/198/51d/a13/19851da13b5f42518e8fde188c816df5.gif", "https://habrastorage.org/files/c32/4b8/deb/c324b8deba6f4996ab3866c51bd5841d.png", "https://habrastorage.org/files/5aa/6ed/046/5aa6ed046a904094b02e77299de117a6.png", "https://habrastorage.org/files/e9c/8e6/46a/e9c8e646af564a42bbb391fbe263044b.png", "https://habrastorage.org/files/9d0/aa3/572/9d0aa3572d9d4ebc9483ebe54d7ed78f.png", "https://habrastorage.org/files/6e2/91e/72f/6e291e72f05d4efd93f4e063d257ab16.png", "https://habrastorage.org/files/464/2ff/fbf/4642fffbf13a4d0382012f42b4ba3875.png", "https://habrastorage.org/files/cd8/bd5/8fb/cd8bd58fbd6846d1aae7ae15c1bf1c09.png", "https://habrastorage.org/files/e6d/4ca/3a2/e6d4ca3a24e2461584be977381686509.png", "https://habrastorage.org/files/426/1dc/57b/4261dc57b9084c1dbeb905097579ceb7.png", "https://habrastorage.org/files/04e/a12/a6f/04ea12a6f46746faa4813364e4c971b1.png", "https://habrastorage.org/files/c63/519/345/c635193455cc466093e603659759686e.png", "https://habrastorage.org/files/d9e/76e/1a0/d9e76e1a00c54539bb8899abd02d2e97.png", "https://habrastorage.org/files/77e/482/644/77e48264497e4585a9b1952193e091c2.png", "https://habrastorage.org/files/d47/ea0/f88/d47ea0f88e2844a6b36bd675c6f0c455.png", "https://habrastorage.org/files/c6a/96e/39f/c6a96e39f6404038b4b11d3abd0f64d6.png", "https://habrastorage.org/files/447/f45/059/447f45059d6c47b1934ed29ae8cd571d.png", "https://habrastorage.org/files/cbb/b04/de6/cbbb04de6f1846159b398eb68c8ead9c.png"], "tag": ["Lua", "процедурная генерация", "лабиринты", "програмирование", "алгоритмы"], "rating": ["+47"], "bookmarks": ["206"], "views": ["14,7k"], "comments_count": ["25"]},
{"author": ["dedokOne"], "date": ["31 января в 15:53"], "hubs": ["Разработка для интернета вещей", "Lua", "Блог компании Mail.Ru Group"], "type_label": [], "text": "На фото представлены устройства, использованные для прототипирования. Как видно, за основу взята процессор x86 (Intel Edison) Всем привет. В этой статье я хотел бы поделиться опытом решения одной интересной проблемы, связанной с синхронизацией данных между IoT-устройствами и облачным приложением. Сначала я расскажу об основной идее и целях моего проекта, а затем подробно опишу его техническую сторону и реализацию: речь пойдет об ОС Contiki, базах данных, протоколах и подобных аспектах. В заключение я кратко перечислю технологии, использованные при построении системы. Вкратце о проекте Для начала давайте поговорим об основной идее проекта. Ниже схематично изображен принцип работы готовой системы: Есть пользователь, который через облачный сервис или напрямую (по Wi-Fi) подключается к IoT- устройству. Также где-то в Интернете имеется облачный сервер приложения. Облаком может служить что угодно: скажем, инстанс AWS или Azure или выделенный сервер. Для обмена данными между сервером приложения и IoT-устройствами устанавливается соединение по какому-то протоколу. IoT-устройства каким-то образом соединены друг с другом (например, по Ethernet или Wi-Fi). Помимо этого, есть отдельная группа IoT-устройств, генерирующих телеметрические данные (такие как показатели освещенности или температура). В общей сложности, может набраться больше 100 или даже больше 1000 устройств. Моя основная задача заключалась в том, чтобы обеспечить обмен данными между облаком и этими IoT-устройствами. Прежде чем двигаться дальше, стоит упомянуть, какие требования предъявлялись к системе: Она должна синхронизировать данные между IoT-устройствами. Она должна собирать данные с IoT-устройств. Она должна синхронизировать данные между IoT-устройствами и облаком. Техническая реализация Здесь все довольно просто: пользователь подключается к серверу приложения по HTTP(S), WebSocket или подобному протоколу. Небольшая задачка для читателей: как вы думаете, что можно использовать для соединения между сервером приложения и IoT-устройством? Если вы подумали про MQTT, вы однозначно правы! Равно как и те, кто выбрал HTTP(S). На самом деле подойдет любой протокол — выбирайте на свой вкус! Мой же выбор пал на — барабанная дробь — асинхронную репликацию! Я имею в виду обычную для баз данных репликацию. Вы можете спросить, зачем мне репликация. Ответ прост: репликация используется для синхронизации данных, поэтому я могу повсюду — включая облако и IoT-устройства — поддерживать одну версию базы данных. Однако репликацию довольно сложно реализовать. Хочешь репликацию — заведи базу данных, которая ее поддерживает, потому что — повторюсь — репликация естественно присуща базам данных. Здесь я бы хотел сказать пару слов о тех базах данных, которые я рассматривал при работе над проектом: SQLite, Redis, MySQL, PostgreSQL и Tarantool. Я сравнил их характеристики и попробовал запустить несколько штук — за исключением MySQL и PostgreSQL — прямо на IoT-устройстве. Ниже расскажу, что из этого вышло. SQLite — однозначно хорошее решение для хранения данных непосредственно на IoT-устройстве, но у нее нет репликации, и она не поддерживает параллельный доступ из разных процессов. Redis не поддерживает master-master репликацию и поэтому не может решить мою проблему, так как мне необходима двусторонняя репликация. MySQL и PostgreSQL слишком тяжеловесны для IoT-устройства, так что я даже не пытался их устанавливать. Но если вы все-таки решите это сделать, смело делитесь своим опытом в комментариях. Последней в моем списке шла база данных Tarantool. Сразу скажу, что я являюсь коммитером в проект Tarantool, поэтому хорошо знаю сам проект и людей, которые его разрабатывают. К тому же, в Tarantool есть master-master репликация. В общем, для меня это был определенно лучший вариант. Вы же можете использовать в своем проекте другую базу данных. Основная идея, которую я пытаюсь донести, в том, что IoT-устройства могут использовать базы данных с master-master репликацией для обмена данными. До настоящего момента я лишь поверхностно знакомил вас с проектом. Теперь давайте немного погрузимся в его технические аспекты. Начну с проблем, с которыми я столкнулся при использовании Tarantool. Во-первых, Tarantool не запускалась на архитектуре ARMv7. Во-вторых, Tarantool не запускалась в 32-битном окружении, что только усугубляло ситуацию. В итоге я смог решить эти проблемы. Ниже приведу правила разработки, которые мне в этом помогли. Используйте toolchain-файлы для CMake. В противном случае вы, так же как и я, потратите много времени на исправление CMake-файлов. Не используйте беззнаковый тип и другие типы, для которых не указан размер. В libc для этого есть специальные типы, такие как uint32_t. Иначе можно получить неопределенное поведение. Это правило применимо только к C/C++. Портируйте ваши автотесты. Ожидается, что ваши автотесты можно запустить на IoT-устройстве. Если это не так, есть риск убить много времени на отладку. Итак, у меня есть работающая база данных с master-master репликацией. Замечательно! Следующий шаг — соединить устройства, на которых эта база данных установлена, по 6LoWPAN. Напомню, у меня есть сеть из множества IoT-устройств, соединенных друг с другом по 6LoWPAN, с которых мне необходимо собрать все телеметрические данные. Краткая схема работы готовой системы Устройства с сенсорами передают телеметрические данные посредством радиоволн. Этот стандарт называется 6LoWPAN (IPv6 поверх маломощных беспроводных персональных сетей). Замечу, что я не использовал в проекте LoRaWAN. Возможно, я найду применение этой технологии в будущем, но в этой статье я сосредоточусь на 6LoWPAN. Итак, для сбора телеметрических данных я буду использовать шлюз, являющийся важной частью системы. Шлюз — это MIPS-устройство (MIPS — это семейство процессоров) с WAN-антенной для сбора данных, передаваемых посредством радиоволн. Кроме этого, на шлюзе установлено приложение 6LBR, конвертирующее полученные данные в IPv6-пакеты. Приложение 6LBR Изображение выше иллюстрирует принцип работы 6LBR. Шлюз с установленным на него 6LBR служит конвертером между беспроводной сенсорной сетью и любой другой. На картинке изображена конвертация из беспроводной сенсорной сети в IP-сеть лишь потому, что так 6LBR работает по умолчанию. Немного позже я объясню, как изменить это поведение. Более подробную информацию можно найти на странице 6LBR на GitHub. Вы можете спросить, что же мне дает использование 6LBR. Во-первых, я получаю стек IP, так что я могу использовать функционал стеков TCP и UDP в моих приложениях 6LBR. Во-вторых, я могу использовать любое устройство ввода-вывода с 6LBR. Скажем, можно записать сырые данные прямо в bash. =) К сожалению, 6LBR не пишет напрямую в MQTT. MQTT-брокеры ничего не знают о сырых данных, и с этим приходится мириться. Зачем же мне понадобилась прямая запись в MQTT-брокер? Ответ прост: дело в legacy-коде. Здесь я бы хотел сказать пару слов о приложениях 6LBR. В общем случае приложение 6LBR — это написанный на С код с API, позволяющим использовать стек IP и делать некоторые другие вещи. Разработка такого приложения сопряжена как минимум с двумя трудностями: сложная модель потоков и сложная модель памяти. Поэтому запаситесь терпением и приготовьтесь к частым аварийным завершениям вашей программы. Ниже приведен небольшой кусок разработанного мной приложения 6LBR (заранее прошу прощения: могу выложить только картинку с нарочно запутанным кодом, потому что исходники закрыты): Обратите внимание на одну интересную вещь — PROCESS_YIELD(). В 6LBR есть кооперативная многозадачность, а это значит, что приложения 6LBR должны возвращать управление в каждой итерации цикла. Код не должен выполняться слишком долго. Итак, давайте еще раз посмотрим, на какой стадии находится наш проект. С помощью шлюза и установленного на него приложения 6LBR я создал mesh network для чтения и записи данных внутри нее. Мне также удалось обернуть IP-пакеты в MQTT-сообщения, каждое из которых содержит информацию об устройстве, включая телеметрические данные. Кроме того, у меня появилась возможность манипулировать устройствами ввода-вывода: скажем, я могу записывать MQTT-сообщения на UART. Но затем я столкнулся с новой проблемой: Tarantool не работает с MQTT-брокерами. Ниже расскажу, как мне удалось обойти это ограничение. Я решил использовать libmosquitto, написанную на чистом С MQTT-библиотеку, потому что она позволяет довольно просто интегрировать MQTT в мое приложение. Ниже приведен пример использования этой библиотеки для работы с MQTT-сообщениями (ссылка): static int mosq_poll_one_ctx(mosq_t *ctx, int revents, size_t timeout, int max_packets) { /** XXX * I'm confused: socket < 0 means MOSQ_ERR_NO_CONN */ int rc = MOSQ_ERR_NO_CONN; int fd = mosquitto_socket(ctx->mosq); if (fd >= 0) { /** Wait until event */ revents = coio_wait(fd, revents, timeout); if (revents != 0) { if (revents & COIO_READ) rc = mosquitto_loop_read(ctx->mosq, max_packets); if (revents & COIO_WRITE) rc = mosquitto_loop_write(ctx->mosq, max_packets); } /** * mosquitto_loop_miss * This function deals with handling PINGs and checking * whether messages need to be retried, * so should be called fairly _frequently_(!). * */ if (ctx->next_misc_timeout < fiber_time64()) { rc = mosquitto_loop_misc(ctx->mosq); ctx->next_misc_timeout = fiber_time64() + 1200; } } return rc; } Я могу взять ссылку на дескриптор сокета и использовать собственный событийный цикл для обработки некоторых событий. И это здорово! Хотел бы обратить ваше внимание на то, что в Tarantool, так же как и в 6LBR, есть кооперативная многозадачность. Для возвращения управления Tarantool использует coio_wait(). Ах да, забыл упомянуть, что Tarantool — это еще и сервер приложений на языке Lua. Сюрприз! Поэтому я портировал libmosquitto на Lua. Ниже привожу кусок кода, в котором вызывается функция, которую вы уже видели в предыдущем примере: __poll_forever = function(self) local mq = self.mqtt while true do self.connected, _ = mq:poll_one() if not self.connected then if self.auto_reconect then self:__try_reconnect() else log.error( \"mqtt: the client is not currently connected, error %s\", emsg) end end fiber.sleep(self.POLL_INTERVAL) end end, Я также портировал все функции из API libmosquitto. Посмотреть на результат можно здесь. По ссылке дан пример использования. Все что нужно сделать для сбора данных со всех устройств внутри mesh network — это вызвать функцию subscribe() из определенного места и опубликовать метод get()! Заключение Давайте посмотрим на то, что у нас получилось: Соединение с сервером приложения установлено посредством предоставляемой Tarantool master-master репликации. Из этого вытекают два полезных свойства: Если сервер приложения изменяет какие-либо данные, эти обновленные данные доставляются на все IoT-устройства в сети. Если IoT-устройство изменяет какие-либо данные, эти обновленные данные доставляются на сервер приложения. Именно эти свойства и являются решением моих проблем. Я также могу соединить мои IoT-устройства посредством master-master репликации. Таким образом устройства и облако объединяются в кластер, который можно использовать для синхронизации всех данных. Все IoT-устройства и облако синхронизированы большую часть времени, за исключением случаев, когда между ними пропадает соединение. Как только соединение будет восстановлено, все данные снова синхронизируются. Просто замечательно! Шлюз с установленным на него приложением 6LBR позволяет обмениваться данными между моими IoT-устройствами и другими IoT-устройствами. Он оборачивает каждое сообщение в MQTT-сообщение и передает его в канал UART. IoT-устройство #N с установленным на него MQTT-брокером считывает эти сообщения из канала UART. MQTT-брокер перенаправляет сообщения в Tarantool по MQTT-соединению. Tarantool считывает их, затем для каждого сообщения сервер приложений Tarantool выполняет некоторый код. IoT-устройство #N соединено со всеми остальными устройствами посредством предоставляемой Tarantool master-master репликации. Такая же репликация используется для соединения всех устройств с облаком. На этом все! Я решил поставленную задачу и очень надеюсь, что мой опыт поможет вам в ваших собственных проектах в будущем. Подытожу: я использовал Tarantool и как основной фронтенд на моих выделенных серверах, и как сервер приложений. Если вас заинтересовала данная тема, рекомендую взглянуть на другую мою статью на английском языке. Оставайтесь на связи и следите на новостями!", "image": ["https://habrastorage.org/files/d94/c70/f6f/d94c70f6fe71492a8bad91364d20c6e0.png", "https://habrastorage.org/files/97d/29e/74d/97d29e74dff84cf7a45ef55198a5a98d.png", "https://habrastorage.org/files/d1a/314/03e/d1a31403ef684e72a9b5ddceff001d43.png", "https://habrastorage.org/files/fc1/f8c/07a/fc1f8c07a6354540ad11654551e9ec5f.png", "https://habrastorage.org/files/a11/1ad/038/a111ad038a9841bd97b8885e28ee466f.png", "https://habrastorage.org/files/e24/bde/eb7/e24bdeeb75a24a1da75e66000a1e224c.png", "https://habrastorage.org/files/74d/054/962/74d054962684467abf0170097c3304d3.png", "https://habrastorage.org/files/8b2/057/643/8b205764393c4743b7bb7dda7291280f.png", "https://habrastorage.org/files/b21/bbf/03d/b21bbf03dcc3487d99b8049ccd687eb4.png"], "tag": ["iot", "tarantool", "databases", "replication"], "rating": ["+35"], "bookmarks": ["47"], "views": ["7,2k"], "comments_count": ["16"]},
{"author": ["soroka95"], "date": ["24 марта в 10:52"], "hubs": ["Разработка под iOS", "Разработка под Android", "Разработка игр", "Lua"], "type_label": [], "text": "Привет, будущий геймдевелопер! Я думаю, что многих интересует, а можно ли создать игру одному, а тем более без вложений. Вот именно об этом и пойдет речь. Я столкнулся с этим не понаслышке. Все, что написано ниже, основано на собственном опыте геймдева с нуля за 3 месяца. Начало пути. Идея и графика Все началось в декабре 2016-го года, когда я встретился с тремя бывшими одногруппниками. Мы заговорили за настоящее, кто кем работает, чем занимается, и конечно же заговорили про будущее. Так вышло, что я графический дизайнер, двое других программисты (C# и Swift), а четвертый «перспективный». Четвертый рассказывал про то, какие огромные возможности в этом мире и бла бла бла… И в этот момент меня осенило. Я за столом с двумя программистами, почему бы не объединиться и не сделать что-то свое? Вот так и появились первые мысли о геймдеве. Первую неделю после встречи мы обсуждали идеи, определились с одной и я приступил к графике. Графику делал в векторном редакторе Adobe Illustrator, чтобы в любой момент можно было изменить разрешение, так как мы еще не совсем понимали какое именно разрешение нам нужно. Набросал графику и на следующий же день один из программистов говорит, что не хочет продолжать, так как нашел занятие поинтереснее. За ним сливается и второй. И тут я понял, что у меня появилась мечта и она начинает отдаляться. Новый год — новые силы. Программирование Наступил новый год и я понял, что опускать руки не стоит и нужно самому довести начатое до конца. И сразу наткнулся на Corona SDK — кроссплатформенное решение для 2D игр. Есть возможность делать на PC, Android, при наличии Xcode и на Mac, iOS. Я не программист, по этому начал проходить туториалы прям на их сайте, очень удобно и информативно. Так я познакомился с языком программирования Lua, именно на нем придется писать, если решил использовать Corona SDK. Язык несложный, скриптовый. Lua широко используется в геймдеве для написания уровней и всяких расширений, в том числе и в игре World of Warcraft он активно используется. Статья «Lua за 15 минут» поможет быстро разобраться с языком. Прошел все туториалы и принял решение сначала делать под Android. Ибо у меня PC, а не Mac, да и устройств на Android в наличии было аж 4, в то время как яблочных девайсов у меня нет. Месяца мне хватило, чтобы с консультациями от моего хорошего друга программиста (не одногруппника) набросать функционал игры. Советы он давал ценные, по этому мы стали партнерами. Дайте больше шума. Музыка и звуки Стал вопрос о музыкальном сопровождении. Как оказалось не так то просто найти подходящий бесплатный sound для игры, особенно если ты хочешь, чтобы еще и нравилось. Недели две я просто убил на то, чтобы найти подходящий звук и музыку, параллельно доделывал интерфейс в игре. Игра все больше становилась похожа на готовый продукт. И вот я нахожу подходящие звуки, но их длительность меня не устраивала, на помощь пришел Audacity. Подрезав звуки и переделав их в wav, я получил нужные мне звуковые эффекты. Сразу после этого нашлась и музыка, это был ambient с бесплатной лицензией, который пошел на резку в Audacity и был зациклен. Таким образом музыка в игре занимает меньше мегабайта и состоит из одного трека и нескольких звуков. Важно: Бесплатные звуки и музыка должны иметь соответствующую лицензию на использование, это может быть как полностью бесплатная лицензия без указания автора, так и лицензия Creative Commons, которая позволяет бесплатно использовать, загружать и даже изменять произведения, но автора стоит указать в credits/титрах. Звон монет и шепот денег. Монетизация Стал вопрос о монетизации. Игра бесплатная, простая, без внутренних покупок, по этому оставался только вариант с рекламой. На Android, да и на iOS с этим проблем нет, к тому же Corona SDK поддерживает самые популярные рекламные плагины. Мой выбор пал на Appodeal. Он работают со всеми крупными сетями мобильной рекламы, для того чтобы показывать только самую дорогую рекламу внутри приложения. В игре использовал межстраничное объявление и видео за вознаграждение. То есть игрок сам решает, смотреть ему видео или нет, если да, то он получает вознаграждение, в моем случае он получает возможность продолжить с того же места, на котором проиграл. А вот межстраничное объявление игрок увидит после каждого проигрыша, как по мне, это не мешает игровому процессу. Игровые сервисы. Тестирование и первая публикация Игру планировал выпустить сразу на двух торговых площадках — Google Play и Amazon. На первой аккаунт разработчика стоит 25$, а на второй бесплатно. По этому начал именно с Amazon. К тому же у меня 2 планшета от Amazon и мне близка их экосистема. Для списка лидеров и достижений у Amazon есть Game Circle, у Google — Google Play Games Services. Проблем ни с одним, ни с другим не возникло, так как документации у Corona SDK по ним предостаточно. На этапе тестирования дал друзьям поклацать игру, замечания себе выписал, внес поправки, а для отслеживания ошибок использовал adb logcat. Исправил баги и 6-го марта игра увидела свет на Amazon. 5 звезд на Amazon. Создание промо ролика. Публикация на Google Play После двух положительных оценок на Amazon сразу же купил аккаунт разработчика в Google Play, цена вопроса 25$. Это пока единственные затраты на игру. Принялся за создание промо ролика для игры. Выбор пал на Adobe After Effects, так как мне близки продукты от Adobe. Честно скажу, не было опыта в создании видео, но у меня как-то быстро получилось разобраться и на видео потратил всего день. Просто очень хотелось поскорее опубликовать игру в Google Play. И вот момент истины, промо ролик готов, аккаунт куплен, осталось заполнить описание игры, нажать на кнопку и просто ждать. Спустя несколько часов я получил уведомление, что игра опубликована. Это было 19-е марта 2017-го года. Выводы Для разработки под iOS все тоже самое, но нужен Mac с Xcode, яблочные устройства для тестирования, а за аккаунт разработчика нужно платить 99 долларов каждый год, а это уже не 25$ за Google Play. По этому если все таки речь идет о геймдеве с минимальными вложениями, то либо Amazon, где вообще платить не надо, либо Google Play, с его четвертью Франклина. Так в одиночку, используя кроссплатформенный движок на простом и понятном для начинающих языке Lua и с минимальными затратами за 3 месяца можно с нуля сделать игру и выпустить ее. Верьте в себя и общайтесь с людьми, которые связаны с геймдевом, community очень помогает. Удачи в начинаниях и доводите проект до конца, ибо только так можно чему-то научиться и получить опыт. P.S. Вот, что получилось: Google Play, Amazon.", "image": [], "tag": ["геймдев", "для чайников", "corona sdk"], "rating": ["+15"], "bookmarks": ["204"], "views": ["33,1k"], "comments_count": ["28"]},
{"author": ["TM_content"], "date": ["17 февраля в 17:12"], "hubs": ["Разработка веб-сайтов", "Программирование", "Высокая производительность", "Lua"], "type_label": [], "text": "Мы вновь публикуем расшифровку доклада с конференции HighLoad++ 2016, которая проходила в подмосковном Сколково 7—8 ноября прошлого года. Владимир Протасов рассказывает, как расширить функциональность NGINX с помощью OpenResty и Lua. Всем привет, меня зовут Владимир Протасов, я работаю в Parallels. Расскажу чуть-чуть о себе. Три четверти своей жизни я занимаюсь тем, что пишу код. Стал программистом до мозга костей в прямом смысле: я иногда во сне вижу код. Четверть жизни — промышленная разработка, написание кода, который идёт прямо в продакшн. Код, которым некоторые из вас пользуются, но не догадываются об этом. Чтобы вы понимали насколько всё было плохо. Когда я был маленьким джуниором, я пришёл, и мне выдали такие двухтерабайтные базы. Это сейчас тут у всех highload. Я ходил на конференции, спрашивал: «Ребят, расскажите, у вас big data, всё круто? Сколько у вас там базы?» Мне отвечали: «У нас 100 гигабайт!» Я говорил: «Круто, 100 гигабайт!» А про себя думал, как бы аккуратненько сохранить покерфейс. Думаешь, да, ребята крутые, а потом возвращаешься и ковыряешься с этими многотерабайтными базами. И это — будучи джуниором. Представляете себе, какой это удар? Я знаю больше 20 языков программирования. Это то, в чём мне пришлось разобраться в процессе работы. Тебе выдают код на Erlang, на C, на С++, на Lua, на Python, на Ruby, на чем-то еще, и тебе надо это всё пилить. В общем пришлось. Точное количество посчитать так и не удалось, но где-то на 20 число потерялось. Поскольку все присутствующие знают, что такое Parallels, и чем мы занимаемся, говорить о том, какие мы крутые и что делаем, не буду. Расскажу только, что у нас 13 офисов по миру, больше 300 сотрудников, разработка в Москве, Таллине и на Мальте. При желании можно взять и переехать на Мальту, если зимой холодно и надо погреть спинку. Конкретно наш отдел пишет на Python 2. Мы занимаемся бизнесом и нам некогда внедрять модные технологии, поэтому мы страдаем. У нас Django, потому что в ней всё есть, а лишнее мы взяли и выкинули. Также MySQL, Redis и NGINX. Ещё у нас — много других крутых штук. У нас есть MongoDB, у нас кролики бегают, у нас чего только нет — но это не моё, и я этим не занимаюсь. OpenResty О себе я рассказал. Давайте разберёмся, о чем я буду сегодня говорить: Что такое OpenResty и с чем его едят? Зачем изобретать ещё один велосипед, когда у нас есть Python, NodeJS, PHP, Go и прочие крутые штуки, которыми все довольны? И немножечко примеров из жизни. Мне пришлось сильно урезать доклад, потому что он у меня получался на 3,5 часа, поэтому примеров будет мало. OpenResty — это NGINX. Благодаря ему мы имеем полноценный веб-сервер, который написан хорошо, он работает быстро. Я думаю, большинство из нас используют NGINX в продакшне. Все вы знаете, что он быстрый и крутой. В нём сделали крутой синхронный ввод/вывод, поэтому нам не надо ничего велосипедить подобно тому, как в Python навелосипедили gevent. Gevent — крутой, здоровский, но если вы напишите сишный код, и там что-то пойдёт не так, то с gevent вы сойдёте с ума это дебажить. У меня был опыт: потребовались целых два дня, чтобы разобраться, что же там пошло не так. Если бы кто-то бы до этого не покопался несколько недель, не нашел проблему, не написал в Интернете, и Google не нашел бы этого, то мы бы вообще свихнулись. В NGINX уже сделаны кеширование и статический контент. Вам не нужно париться, как это сделать по-человечески, чтобы у вас где-нибудь не затормозило, чтобы вы где-то дескрипторы не потеряли. Nginx очень удобно деплоить, вам не нужно задумываться, что взять — WSGI, PHP-FPM, Gunicorn, Unicorn. Nginx поставили, админам отдали, они знают, как с этим работать. Nginx структурированно обрабатывает запросы. Я об этом немножко позже расскажу. Вкратце у него есть фаза, когда он только принял запрос, когда он обработал и когда отдал контент пользователю. Nginx крут, но есть одна проблема: он недостаточно гибок даже при всех тех крутых фишках, что ребята впихнули в конфиг, при том, что можно настроить. Этой мощи не хватает. Поэтому ребята из Taobao когда-то давно, кажется, лет восемь назад, встроили туда Lua. Что он даёт? Размер. Он маленький. LuaJIT дает где-то 100-200 килобайт оверхеда по памяти и минимальный оверхед по производительности. Скорость. Интерпретатор LuaJIT во многих ситуациях близок к C, в некоторых ситуациях он проигрывает Java, в некоторых — обгоняет её. Какое-то время он считался state of art, крутейшим JIT-компилятором. Сейчас есть более крутые, но они очень тяжелые, к примеру, тот же V8. Некоторые JS-ные интерпретаторы и джавовский HotSpot в каких-то точках быстрее, но в каких-то местах всё ещё проигрывают. Простота в освоении. Если у вас, допустим, кодовая база на Perl, и вы не Booking, вы не найдёте перловых программистов. Потому что их нет, их всех забрали, а учить их долго и сложно. Если вы хотите программистов на чем-то другом, возможно, их тоже их придётся переучивать, либо находить. В случае Lua всё просто. Lua учится любым джуниором за три дня. Мне потребовалось где-то часа два, чтобы разобраться. Через два часа я уже писал код в продакшн. Где-то через неделю он прямо в продакшн и уехал. В результате это выглядит вот так: Тут много всего. В OpenResty собрали кучу модулей, как луашных, так и энджинсовских. И у вас все готовое — задеплоил и работает. Примеры Хватит лирики, переходим к коду. Вот маленький Hello World: Что здесь есть? это энджинсовский location. Мы не паримся, не пишем свой роутинг, не берём какой-то готовый — у нас уже есть в NGINX, мы живем хорошо и лениво. content_by_lua_block – это блок, который говорит, что мы отдаем контент при помощи Lua-скрипта. Берем энджинсовскую переменную remote_addr и подсовываем её в string.format. Это то же самое, что и sprintf, только на Lua, только правильный. И отдаём клиенту. В результате это будет выглядеть вот так: Но вернёмся в реальный мир. В продакшн никто не деплоит Hello World. У нас приложение обычно ходит в базу или ещё куда-то и большую часть времени ждёт ответа. Просто сидит и ждёт. Это не очень хорошо. Когда приходят 100.000 пользователей, нам очень тяжко. Поэтому давайте в качестве примера накидаем простенькое приложение. Будем искать картинки, например, котиков. Только мы не будем просто так искать, мы будем расширять ключевые слова и, если пользователь поискал «котята», мы ему найдём котиков, пушистиков и прочее. Для начала нам нужно получить данные запроса на бэкенде. Выглядит это так: Две строчки позволяют вам забрать GET-параметры, никаких сложностей. Дальше мы, допустим, из базы данных с табличкой по ключевому слову и расширению получаем обычным SQL-запросом эту информацию. Всё просто. Выглядит это так: Подключаем библиотечку resty.mysql, которая у нас уже есть в комплекте. Нам ничего не нужно ставить, всё готовое. Указываем, как подключиться, и делаем SQL-запрос: Тут немножечко страшно, но всё работает. Здесь 10 — это лимит. Мы вытаскиваем 10 записей, мы ленивые, не хотим больше показывать. В SQL про лимит я забыл. Дальше мы находим картинки по всем запросам. Мы собираем пачку запросов и заполняем Lua-табличку, которая называется reqs, и делаем ngx.location.capture_multi. Все эти запросы уходят в параллель, и нам возвращаются ответы. Время работы равно времени ответа самого медленного. Если у нас все отстреливаются за 50 миллисекунд, и мы отправили сотню запросов, то ответ у нас придёт за 50 миллисекунд. Поскольку мы ленивые и не хотим писать обработку HTTP и кэширования, мы заставим NGINX делать всё за нас. Как вы видели, там был запрос на url/fetch, вот он: Мы делаем простой proxy_pass, указываем, куда закэшировать, как это сделать, и у нас всё работает. Но этого недостаточно, нам ещё нужно отдать данные пользователю. Самая простая идея — это всё серилизовать в JSON, легко, в две строчки. Отдаём Content-Type, отдаём JSON. Но есть одна сложность: пользователь не хочет читать JSON. Надо привлекать фронтендеров. Иногда нам не хочется этого поначалу делать. Да и сеошники скажут, что если мы картинки ищем, то им без разницы. А если мы им какой-то контент выдаём, то они скажут, что у нас поисковики ничего не индексируют. Что с этим делать? Само собой, мы будем отдавать пользователю HTML. Генерировать ручками — не комильфо, поэтому мы хотим использовать шаблоны. Для этого есть библиотека lua-resty-template. Вы, наверное, увидели три страшные буквы OPM. OpenResty идет со своим пакетным менеджером, через который можно поставить ещё кучу разных модулей, в частности, lua-resty-template. Это простой движок шаблонов, близкий к Django templates. Там можно написать код и сделать подстановку переменных. В результате всё будет выглядеть примерно вот так: Мы взяли данные и срендерили шаблон опять же в две строчки. Пользователь счастлив, получил котиков. Поскольку мы расширили запрос, он на котят получил ещё и морского котика. Мало ли, может, он искал именно его, но не мог правильно сформулировать свой запрос. Всё круто, но мы же в девелопменте, и не хотим пока пользователям показывать. Давайте сделаем авторизацию. Чтобы это сделать, давайте посмотрим, как NGINX обрабатывает запрос в терминах OpenResty: Первая фаза — access, когда пользователь только пришел, и мы на него посмотрели по заголовкам, по IP-адресу, по прочим данным. Можно сразу отрубить его, если он нам не понравился. Это можно использовать для авторизации, либо, если нам приходит очень много запросов, мы можем их легко рубить на этой фазе. rewrite. Переписываем какие-то данные запроса. content. Отдаём контент пользователю. headers filter. Подменяем заголовки ответа. Если мы использовали proxy_pass, мы можем переписать какие-то заголовки, прежде чем отдать пользователю. body filter. Можем подменить тело. log — логирование. Можно писать логи в elasticsearch без дополнительного слоя. Наша авторизация будет выглядеть примерно так: Мы добавим это в тот location, который мы описали до этого, и засунем туда такой код: Мы смотрим, есть ли у нас cookie token. Если нет, то кидаем на авторизацию. Пользователи хитрые и могут догадаться, что нужно поставить cookie token. Поэтому мы ещё положим её в Redis: Код работы с Redis очень простой и ничем не отличается от других языков. При этом весь ввод/вывод что там, что здесь, он не блокирующий. Если пишете синхронный код, то работает асинхронно. Примерно как с gevent, только сделано хорошо. Давайте сделаем саму авторизацию: Говорим, что нам нужно читать тело запроса. Получаем POST-аргументы, проверяем, что логин и пароль правильные. Если неправильные, то кидаем на авторизацию. А если правильные, то записываем token в Redis: Не забываем поставить cookie, это тоже делается в две строчки: Пример простой, умозрительный. Мы конечно же не будем делать сервис, который показывает людям котиков. Хотя кто нас знает. Поэтому давайте пройдёмся по тому что можно сделать в продакшне. Минималистичный бэкенд. Иногда нам требуется в бэкенд выдать совсем чуть-чуть данных: где-то нужно дату подставить, где-то какой-то список вывести, сказать, сколько сейчас пользователей на сайте, прикрутить счётчик или статистику. Что-то такое небольшое. Минимальные какие-то кусочки можно очень легко сделать. На этом получится быстро, легко и здорово. Препроцессинг данных. Иногда нам хочется встроить в нашу страничку рекламу, причём эту рекламу мы берём API-запросами. Такое очень легко сделать именно здесь. Мы не загружаем наш бэкенд, который и так сидит тяжело работает. Можно взять и собрать здесь. Мы можем слепить какие-то JS или, наоборот, разлепить, что-то препроцессить прежде, чем отдать пользователю. Фасад для микросервиса. Это тоже очень хороший кейс, я его реализовывал. До этого я работал в компании Tenzor, которая занимается электронной отчётностью, обеспечивает отчётность примерно половины юрлиц в стране. Мы сделали сервис, там при помощи этого же механизма сделаны многие вещи: маршрутизация, авторизация и другое. OpenResty можно использовать как клей для ваших микросервисов, который обеспечит единый доступ ко всему и единый интерфейс. Поскольку микросервисы могут быть написаны так, что вот здесь у вас Node.js, здесь у вас PHP, здесь Python, здесь стоит какая-то штука на Erlang, мы понимаем, что не хотим один и тот же код везде переписывать. Поэтому OpenResty можно воткнуть на фронт. Статистика и аналитика. Обычно NGINX стоит на входе, и все запросы идут через него. Именно в этом месте очень удобно собрать. Можно что-то сразу посчитать и куда-нибудь закинуть, например, тот же Elasticsearch, Logstash или просто записать в лог и потом куда-нибудь отправить. Многопользовательские системы. Например, онлайн-игры тоже очень хорошо делать. Сегодня в Кейптауне Александр Гладыш будет рассказывать, как быстро прототипировать многопользовательскую игру при помощи OpenResty. Фильтрация запросов (WAF). Сейчас модно делать всякие web application firewall, есть много сервисов, которые их предоставляют. При помощи OpenResty можно сделать себе web application firewall, который просто и легко будет фильтровать запросы по вашим требованиям. Если у вас Python, то вы понимаете, что PHP вам точно незаинджектят, если вы, конечно, из консоли его не спауните нигде. Вы знаете, что у вас MySQL и Python. Наверное, тут могут попытаться сделать какой-нибудь directory traversal и что-нибудь заинджектить в базу. Поэтому можно отфильтровать стрёмные запросы быстро и дешево сразу на фронте. Сообщество. Поскольку OpenResty построен на базе NGINX, то у него есть бонус — это NGINX-коммьюнити. Оно очень большое, и приличная часть вопросов, которая у вас возникнет поначалу, уже решена NGINX-сообществом. Lua-разработчики. Вчера я общался с ребятами, которые пришли на учебный день HighLoad++ и услышал, что на Lua написан только Tarantool. Это не так, на Lua много чего написано. Примеры: OpenResty, XMPP-сервер Prosody, игровой движок Love2D, Lua скриптуется в Warcraft и в других местах. Lua-разработчиков очень много, у них большое и отзывчивое коммьюнити. Все мои вопросы по Lua решались в течение нескольких часов. Когда пишешь в список рассылки, буквально через несколько минут уже куча ответов, расписывают что и как, что к чему. Это очень здорово. К сожалению, не везде такое доброе душевное коммьюнити. По OpenResty есть GitHub, там можно завести issue, если что-то сломалось. Есть список рассылки на Google Groups, где можно обсудить общие вопросы, есть рассылка на китайском — мало ли, может, английским вы не владеете, а знания китайского есть. Итоги Надеюсь смог донести, что OpenResty — это очень удобный фреймворк, заточенный под веб. У него низкий порог вхождения, поскольку код похож на то, на чём мы пишем, язык довольно прост и минималистичен. Он предоставляет асинхронный I/O без коллбеков, у нас не будет лапши, как мы можем иногда написать в NodeJS. У него легкий деплой, поскольку нам нужен только NGINX c нужным модулем и наш код, и всё сразу работает. Большое и отзывчивое сообщество. Я не рассказал в деталях как делается маршрутизация, там получался очень длинный рассказ. Спасибо за внимание! Владимир Протасов — OpenResty: превращаем NGINX в полноценный сервер приложений", "image": ["https://habrastorage.org/files/594/12e/54c/59412e54c5234d478c1d6a1c65981ddf.jpg", "https://habrastorage.org/files/c69/e55/e9d/c69e55e9d0b446e8b2c91d62ad1b26dc.png", "https://habrastorage.org/files/7e3/a01/b77/7e3a01b770fe4ab0856c019d64987c5e.png", "https://habrastorage.org/files/eaf/a28/698/eafa2869865746588a93b554b09d8510.png", "https://habrastorage.org/files/b18/d81/a3c/b18d81a3c2d747de9714cef2fdca556d.jpg", "https://habrastorage.org/files/52a/905/641/52a9056413f94eb7b26bd1d8c42bf3d3.png", "https://habrastorage.org/files/d9c/a25/ee5/d9ca25ee5f1e46dab71b69ff80a5e195.png", "https://habrastorage.org/files/27c/696/9b3/27c6969b3e704fcf9ccc0426184f6d3b.png", "https://habrastorage.org/files/69c/c39/892/69cc3989288c47c59f5d856ad24bfba1.png", "https://habrastorage.org/files/50f/4e0/4bb/50f4e04bb0654336be714b62c8a83e52.png", "https://habrastorage.org/files/fec/7e0/0a7/fec7e00a7714430ca53fcb01cf48282d.png", "https://habrastorage.org/files/1f0/5da/fdb/1f05dafdbeec4958a53d4587d07b150e.jpg", "https://habrastorage.org/files/50d/209/35f/50d20935f5c5409d956e442d5e9703a7.png", "https://habrastorage.org/files/7af/761/a4e/7af761a4ef3c4a5cb60fdbadd7315d9d.png", "https://habrastorage.org/files/0bf/100/cad/0bf100cad2014e7b8f5af570417c1fe9.png", "https://habrastorage.org/files/7e7/43f/c36/7e743fc36cdc46a5a2e010937ea44567.png", "https://habrastorage.org/files/cd0/d78/9d8/cd0d789d873841cbb6740cda9f76acc2.png", "https://habrastorage.org/files/992/b4a/4a4/992b4a4a4a0c41378ba7e87c4dfd76da.png", "https://habrastorage.org/files/2a0/bbe/1f0/2a0bbe1f00724535ad91cc74d8f7473e.png"], "tag": ["Nginx", "OpenResty", "Lua", "программирование", "HighLoad++", "HighLoad++ 2016", "Владимир Протасов", "Parallels", "веб-разработка", "высокая производительность"], "rating": ["+39"], "bookmarks": ["227"], "views": ["23,8k"], "comments_count": ["28"]},
{"author": ["KsHoxton"], "date": ["28 февраля в 18:13"], "hubs": ["Разработка игр", "Разработка веб-сайтов", "Lua", "Блог компании Mail.Ru Group"], "type_label": [], "text": "В первое воскресенье марта в офисе Mail.Ru Group пройдёт международная конференция Lua in Moscow 2017. В программе — выступления автора языка Роберто Иерусалимского и лучших зарубежных и отечественных экспертов по Lua и LuaJIT. Lua — уникальный язык программирования, который используется далеко не только в индустрии компьютерных игр, но и как встроенный язык расширений в таких инструментах web-программирования, как Redis, nginx, Tarantool, OpenResty. Lua также применяется для анализа больших данных, научных вычислений. Во многих роутерах, принтерах и других подобных устройствах есть Lua. В 2014 году мы провели восьмую ежегодную конференцию по языку программирования Lua Workshop, крупнейшую по числу участников за все годы. С тех пор мы не забывали про язык программирования Lua, проводили митапы и потоки на IT-конференциях. И вот, наконец, в этом году у вас снова есть шанс лично задать вопросы автору языка, обменяться опытом с лучшими программистами и, конечно, послушать доклады про передовой опыт применения Lua и LuaJIT. Часть докладов будет на английском языке. Даже если вы ещё не пишете на языке Lua, приходите, возможно, конференция откроет вам глаза на что-то новое и интересное! 9:30 Начало регистрации 10:00 — 10:50 «Функции в Lua», Роберто Иерусалимский, PUC-Rio Функции первого класса (известные как замыкания, лямбды, анонимные функции) — качественная черта функциональных языков, однако их концепция удобна также и в императивных языках. Тем не менее, в большинстве императивных языков использование функций как значений первого класса нетривиально и используется опытными программистами. В Lua же, напротив, пользовательские функции первого класса являются строительным блоком языка. Программисты Lua постоянно получают выгоду от разнообразных свойств его функций для создания подпрограмм вроде обработки исключений, определения модулей, объектно-ориентированного программирования, а также итераторов. Более того, функции первого класса играют центральную роль в API между Lua и C. В этом докладе мы обсудим как механизм функций первого класса повлиял на дизайн Lua и бегло взглянем на его реализацию. 11:00 — 11:50 «Проблемы создания 'ещё одной' реализации Lua», Антон Солдатов, IPONWEB Классический интерпретатор Lua (aka PUC-Rio Lua) довольно быстр, и Lua сам как язык спроектирован для лёгкого встраивания в другие системы. Однако иногда всё же есть нужда в альтернативной реализации языка: например, могут быть жёсткие бизнес-требования к производительности. На первый взгляд экосистема Lua предоставляет средства для собственной реализации языка: есть руководство, описывающее язык, включая библиотеки и API. Также есть пакеты тестов соответствия (как официальные, так и сторонние). Тем не менее, работая над собственной реализацией Lua, мы столкнулись с некоторыми проблемами, которые я бы хотел обсудить в этом докладе. Особенно: Интерпретацию Руководства и интеграцию с официальным пакетом тестов; Выбор валидирующего пакета тестов из множества доступных; Обеспечения соответствия API стандартных библиотек Lua. 12:00 — 12:50 «Использование Lua в качестве языка для отказоустойчивых распределённых бэкенд-приложений», Константин Осипов, Tarantool Tarantool — СУБД и сервер высоконагруженных приложений, поэтому требования к языку программирования на борту предъявляет особенные. Надёжность и производительность — главные ценности, но ими хотелось бы обладать не в ущерб удобству и простоте использования. Lua, а точнее LuaJIT 2.1, на сегодня наш основной язык для написания приложений, но в последнее время мы также начали поддерживать Rust, Swift, C и С++. Мы имеем уникальный опыт «эксплуатации» Lua, т.к. постоянно разбираем инциденты и крэши пользователей Tarantool, происходящие как во время разработки, так и эксплуатации. В результате у нас сложилась достаточная картина о том, что именно мы хотим от идеального языка для backend'а. Мой доклад, таким образом, будет посвящён гипотетическим требованиям к «идеальному» языку: надежность: программа на языке ни при каких обстоятельствах не должна завершать хост-процесс; предсказуемость: сборка мусора и рантайм языка должны быть предсказуемыми для разработчика; безопасность — синтаксис языка должен быть безопасен на этапе исполнения. Это касается как использования необъявленных переменных, так и системы типов, в частности поведении при переполнении или делении на 0. Сможет ли таким языком стать Lua? 13:00 — 13:50 «Каменистый путь к mcode», Хавье Гуэрра Гиральдес, Cloudflare LuaJIT способен выполнять Lua на ошеломительных скоростях, однако часто трудно понять, что он делает и когда. Это приводит к созданию мифов и карго-культу. Мы покажем шаг за шагом путешествие от исходного кода Lua до окончательно исполняемого машинного кода, используя Loom как инструмент визуализации и изучения. 14:00 — 15:00 Обед 15:00 — 15:50 «Самолёт построим сами! Опыт прототипирования инструментов для онлайн-маркетинга с использованием Lua», Дмитрий Потапов, LogicEditor Сейчас существует достаточно много средств анализа эффективности онлайн-рекламы – Google Analytics, Yandex.Metrika и др. Для управления и автоматизации контекстной рекламой инструментов не меньше: R-broker, K50, Alytics и др. Эти инструменты вполне неплохо справляются со своими задачами. В каких случаях разработка собственного инструментария может иметь смысл? Как может выглядеть этот инструментарий, в какой последовательности его разрабатывать, какие сторонние наработки могут оказаться полезными? На эти и другие вопросы автор и попробует ответить на примере собственного опыта. 16:00 — 16:50 «Тяжёлый труд написания нативных плагинов для кросс-платформенного игрового движка», Сергей Lerg, Spiral Code Studio Lua — прекрасный язык, он позволяет делать сложные вещи весьма просто. В кросс-платформенных движках для игр одна Lua-функция может скрывать за собой сотни строк нативного кода (C++/Java/Obj-C), что позволяет разработчику игры сфокусироваться на конечном продукте. В этом докладе я покажу, как я делаю нативные плагины для игрового движка Corona SDK, как разные реализации одних и тех же вещей на разных платформах превращаются в прекрасный единообразный API на стороне Lua. 17:00 — 17:50 «Как сделать жизнь Lua-разработчика лучше и приятнее?», Артём Зотов, IPONWEB IPONWEB разрабатывает платформенные решения для рынка Online Advertising и предлагает их клиентам по модели SaaS. Бизнес-логика реализуется на языке Lua, поэтому IPONWEB ищет и нанимает Lua-разработчиков. Проблема: поиск на HH.ru по вакансиям с ключевым словом Lua дает примерно 700 резюме. Сравните с результатом при ключевых словах: Perl: 9000 резюме; Python: 14 000 резюме; PHP: 55 000 резюме. На рынке труда очень мало разработчиков с опытом разработки на Lua. Бизнес IPONWEB в последние годы растет очень активно и компании нужно нанимать все новых и новых Lua-разработчиков. Что же делать? Создавать идеальные условия для работы и профессионального роста. Как мы это делаем? Об этом и будет моя презентация. 18:00 — 18:50 Время вопросов и ответов Ждём вас на Lua in Moscow 2017! Вход бесплатный. Регистрация обязательна. Адрес: офис Mail.Ru Group, Ленинградский пр., 39, стр. 79.", "image": ["https://habrastorage.org/files/ffc/24d/aa0/ffc24daa026a49a0b1e28c57b207a5c4.png", "https://habrastorage.org/files/876/c4a/db0/876c4adb0d754d44885218b3a4c5ab17.png", "https://habrastorage.org/files/c88/60a/e98/c8860ae98c624f9ab476ba3ba63c717f.png", "https://habrastorage.org/getpro/habr/post_images/a27/061/7e8/a270617e8fe044d68f3b86ea35cf9684.png", "https://habrastorage.org/getpro/habr/post_images/a27/061/7e8/a270617e8fe044d68f3b86ea35cf9684.png", "https://habrastorage.org/getpro/habr/post_images/472/8f2/400/4728f2400c2b7271677ab4194fc039ce.png", "https://habrastorage.org/getpro/habr/post_images/a27/061/7e8/a270617e8fe044d68f3b86ea35cf9684.png", "https://habrastorage.org/files/8a4/716/730/8a47167303bb4c4c9cd6bc402c596e5a.png", "https://habrastorage.org/getpro/habr/post_images/472/8f2/400/4728f2400c2b7271677ab4194fc039ce.png", "https://habrastorage.org/getpro/habr/post_images/a27/061/7e8/a270617e8fe044d68f3b86ea35cf9684.png", "https://habrastorage.org/getpro/habr/post_images/472/8f2/400/4728f2400c2b7271677ab4194fc039ce.png", "https://habrastorage.org/files/2da/961/aed/2da961aed6b64c329808076d1e5afdb7.png"], "tag": ["mail.ru", "lua"], "rating": ["+33"], "bookmarks": ["7"], "views": ["4,2k"], "comments_count": ["6"]},
{"author": ["codesign"], "date": [" 5 апреля в 13:50"], "hubs": ["Высокая производительность", "Анализ и проектирование систем", "Perl", "Lua", "Блог компании Mail.Ru Group"], "type_label": [], "text": "Многие уже наслышаны о производительности СУБД Tarantool, её возможностях и особенностях. Например, у него есть классное дисковое хранилище — Vinyl, кроме того, он умеет работать с JSON-документами. Но в многочисленных публикациях обходят стороной одну важную особенность. Обычно БД рассматривают просто как хранилище, но всё же отличительная черта Tarantool — это возможность писать код внутри и очень эффективно работать с этими данными. Под катом рассказ, как мы строили одну систему почти полностью внутри Tarantool, написанный в соавторстве с Игорем igorcoding Латкиным. Все вы сталкивались с Почтой Mail.Ru и, наверное, знаете, что в ней можно настроить сбор писем из других почтовых ящиков. Для этого нам не нужно просить у пользователя логин и пароль от стороннего сервиса, если поддерживается протокол OAuth. В этом случае для доступа используются OAuth–токены. Кроме того, в Mail.Ru Group есть множество других проектов, которым также нужна авторизация через сторонние сервисы, и которым необходимо выдавать OAuth–токены пользователей для работы с тем или иным приложением. Разработкой такого сервиса по хранению и обновлению токенов мы и занимались. Наверное, все знают, что представляет собой OAuth–токен. Напомним, чаще всего это структура из трёх-четырёх полей: { \"token_type\" : \"bearer\", \"access_token\" : \"XXXXXX\", \"refresh_token\" : \"YYYYYY\", \"expires_in\" : 3600 } access_token, с помощью которого вы можете осуществлять действие, получить информацию о пользователе, скачать список его друзей и так далее; refresh_token, с помощью которого вы можете получать новый access_token, причём сколько угодно; expires_in — временная отметка либо окончания срока действия токена, либо иное заранее заданное время. Если вы придёте с access-токеном с истёкшим сроком действия, у вас не будет доступа к ресурсу. Рассмотрим теперь приблизительную архитектуру сервиса. Представим, что есть некоторые фронтенды, которые просто кладут в наш сервис токены и читают их, и есть отдельная сущность, называемая рефрешерами. Задача рефрешера — ходить в OAuth-провайдер за новым access_token примерно в тот момент, когда закончится его срок действия. Структура базы тоже довольно проста. У нас есть два узла БД (master и slave реплики). Вертикальная черта представляет собой условное разделение дата-центров. В одном дата-центре стоит master со своим фронтендом и рефрешером, а в другом — slave со своим фронтендом и рефрешером, который ходит в master. Какие возникают сложности? Основная проблема заключается во времени (один час), в течение которого живёт токен. Если посмотреть на проект, то возникает мысль: «Разве это highload-масштабы — 10 млн записей, которые надо рефрешить в течение часа? Если поделить одно на другое, посмотреть, мы получаем RPS порядка 3000». Проблемы начинаются в тот момент, когда что-то перестаёт рефрешиться, например, какой-нибудь maintenance базы, или она упала, или упала машина — всякое случается. Дело в том, что если наш сервис, мастер-база, по какой-то причине не работает 15 минут — мы получаем 25 % outage, т.е. четверть наших данных не валидна, не обновлена, ею нельзя пользоваться. Если сервис лежит 30 минут, то без обновления уже половина данных. Час — нет ни одного действующего токена. Предположим, база лежала час, мы её подняли, и нужно все 10 млн токенов очень быстро обновить. А это уже не 3000 RPS, это вполне себе высоконагруженный сервис. Надо сказать, что изначально все нормально обрабатывалось, но спустя два года после запуска мы добавили разной логики, дополнительные индексы, стали добавлять вторичную логику — в общем, у Tarantool кончился процессор. Это было неожиданно, но ведь любой ресурс можно израсходовать. В первый раз нам помогли админы. Поставили самый мощный процессор, который нашли, это позволило нам расти ещё полгода, но за это время надо было как-то решить проблему. Нам попался на глаза новый Tarantool (система была написана на старом Tarantool 1.5, который за пределами Mail.Ru Group практически не встречается). В Tarantool 1.6 на тот момент уже была master-master репликация. И первое, что пришло в голову: давайте поставим в три дата-центра по копии БД, между ними запустим master-master репликацию, и всё будет прекрасно. Три мастера, три дата-центра, три рефрешера, каждый работает со своим мастером. Можем уронить один или два, вроде бы всё будет работать. Но какие здесь потенциальные проблемы? Основная проблема, заключается в том, что мы в три раза увеличиваем количество запросов на OAuth-провайдер. Мы рефрешим практически одни и те же токены, причём столько раз, сколько у нас реплик. Это совсем не дело. Очевидное решение: сами ноды должны каким-то образом решать, кто из них будет в данный момент лидером (т.е. вести рефреш токенов лишь с одной реплики). Выбор лидера Существует несколько консенсус-алгоритмов. Первый из них — Paxos. Довольно сложная штука. Нам не удалось нормально разобраться, как на его основе сделать что-то простое. В итоге мы остановились на Raft. Это очень простой консенсус-алгоритм, в котором происходит выбор лидера, с которым мы можем работать, пока не будет выбран новый лидер при разрыве соединения или по другим обстоятельствам. Вот так мы это сделали: В Tarantool из коробки нет ни Raft, ни Paxos. Но мы берем готовый модуль, который есть в поставке, — net.box. Этот модуль позволяет нам соединять узлы между собой по схеме full mesh: каждая нода подключается ко всем остальным. А дальше всё просто: мы поверх этих подключений реализуем выбор лидера, который описан в Raft. После этого каждая нода начинает обладать свойством: она либо лидер, либо фолловер, либо не видит ни лидера, ни фолловера. Если вы думаете, что реализовать Raft сложно, вот пример кода на Lua: local r = self.pool.call(self.FUNC.request_vote, self.term, self.uuid) self._vote_count = self:count_votes(r) if self._vote_count > self._nodes_count / 2 then log.info(\"[raft-srv] node %d won elections\", self.id) self:_set_state(self.S.LEADER) self:_set_leader({ id=self.id, uuid=self.uuid }) self._vote_count = 0 self:stop_election_timer() self:start_heartbeater() else log.info(\"[raft-srv] node %d lost elections\", self.id) self:_set_state(self.S.IDLE) self:_set_leader(msgpack.NULL) self._vote_count = 0 self:start_election_timer() end Здесь мы делаем запросы к удалённым серверам, на другие реплики Tarantool, подсчитываем количество голосов, которые мы получили с ноды. Если набрался кворум, за нас проголосовали, мы становимся лидером и начинаем heart-beat — оповещаем остальные ноды о том, что мы живы. Если мы проиграли выборы, то инициируем их вновь. Через некоторое мы сможем проголосовать или быть выбранными. После получения кворума и определения лидера, мы можем направить наши рефрешеры во все ноды, но при этом сказать им работать только с лидером. Таким образом мы получаем нормальный трафик. Так как задания раздаёт одна нода, на каждый рефрешер уйдёт где-то одна треть.Только здесь мы можем спокойно потерять любого из мастеров — случатся перевыборы, рефрешеры переключатся на другую ноду. Но, как и в любой распределённой системе, с кворумом возникают проблемы. «Заброшенная» нода Если потерялась связность между дата-центрами, то нужен механизм, который заставляет систему продолжать жить, а также механизм, который должен восстановить целостность системы. Эту проблему решает Raft. Допустим, ушёл дата-центр Dataline. Получается, что стоявшая там нода становится «заброшенной» — она не видит других узлов. Остальная часть кластера видит, что нода потерялась, происходят перевыборы, лидером становится новый узел в кластере, скажем, верхний. И система продолжает работать, потому что между нодами по-прежнему сохранялся консенсус, т.к. больше половины нод видят друг друга. Основной вопрос: что происходит с рефрешером, который находится в ушедшем дата-центре при потере связности? В спецификации Raft нет отдельного названия для такого узла. Обычно нода, не имеющая кворума и связи с лидером, бездействует. Но ведь он всё ещё может ходить в сеть, самостоятельно обновлять токены. Обычно токены обновляются в режиме связности, но может быть можно обновлять токены рефрешером, который подключен к «заброшенной» ноде? Вначале было непонятно, есть ли смысл обновлять токены? Не будет ли излишних операций обновления? Этим вопросом мы занялись в процессе реализации системы. Первая мысль — у нас же консенсус, кворум, и если мы потеряли кого-то из кворума, то обновлений не выполняем. Но потом появилась другая идея. Посмотрим на реализацию master-master в Tarantool. Предположим, в определённый момент существует две ноды, обе master. Есть переменная, ключ Х, значение которого 1. Допустим, в одно и то же время, пока репликация не дошла до этой ноды, мы одновременно изменяем этот ключ на два разных значения: в одной ноде ставим 2, в другой — 3. Далее ноды обмениваются репликационными логами, то есть значениями. С точки зрения консистентности, такая реализация master-master — это какой-то ужас, да простят меня разработчики Tarantool. Если нам нужна строгая консистентность — это не работает. Однако, вспомним наш OAuth-токен, который состоит из двух важных частей: refresh-токена, который, условно, живёт бесконечно, и access-токена — живёт один час. Но при этом наш рефрешер несёт функцию refresh, которая из refresh-токена всегда может получить любое количество access-токенов. И все они будут действовать в течение часа с момента выдачи. Рассмотрим схему: две ноды нормально работали с лидером, обновили токены, получили первый access-токен. Он отреплицировался, теперь этот access-токен есть у всех. Случился разрыв, фолловер стал «заброшенной» нодой, у него нет кворума, он не видит ни лидера, ни других фолловеров. При этом мы разрешаем нашему рефрешеру обновлять токены, которые живут на «заброшенной» ноде. Если там не будет сети, схема работать не будет. Но если это простой сплит — сеть порвалась, — то ничего страшного, эта часть будет работать автономно. После того, как разрыв связи закончится и нода присоединится, то либо пройдут перевыборы, либо произойдёт обмен данными. При этом второй и третий токен — одинаково “хорошие”. После воссоединения кластера очередная процедура обновления выполнится только на одной ноде, и она реплицируется. То есть на какое-то время наш кластер разделяется, и каждый обновляет по-своему, а после воссоединения мы возвращаемся к нормальным консистентным данным. Это даёт нам следующее: обычно для работы кластера нужно N/2 + 1 активных узлов (в случае трёх нод — это два). В нашем же случае для работы системы достаточно хотя бы одного активного узла. Наружу будет идти ровно столько запросов, сколько нужно. Мы говорили про проблему увеличения количества запросов. На время сплита или даунтайма, мы можем себе позволить, чтобы жила хотя бы одна нода. Мы будем её обновлять, будем складывать данные. Если это предельный сплит, то есть разделены все ноды и у всех есть сеть, то мы получим то самое утроение количества запросов на OAuth-провайдера. Но благодаря кратковременности события — это не страшно, и мы не предполагаем постоянно работать в режиме разделения. Обычно система находится в кворуме, связности, и вообще все ноды работают. Шардинг Осталась одна проблема — мы упёрлись в потолок по CPU. Очевидное решение: шардинг. Допустим, есть два шарда — базы данных, каждая из них реплицируется. Есть некая функция, которой на вход приходит какой-то ключ, по этому ключу мы можем определить, в каком шарде лежат данные. Если мы шардируемся по e-mail, то часть адресов хранится в одном шарде, часть — в другом, и мы всегда знаем, где лежат наши данные. Существует два подхода к реализации шардинга. Первый — клиентский. Выбираем функцию консистентного хеширования, возвращающую номер, шарда, например, CRC32 ключа, Guava, Sumbur. Эта функция одинаковым образом реализуется на всех клиентах. У этого подхода есть несомненное преимущество: БД вообще ничего не знает про шардинг. Вы подняли базу, она стандартно работает, а шардинг где-то сбоку. Но есть и серьезный недостаток. Во-первых, клиенты довольно толстые. Если вы хотите сделать новый, то нужно добавить в него логику шардинга. Но самая страшная проблема в том, что одни клиенты могут работать по одной схеме, а другие — по другой. При этом сама база ничего не знает о том, что вы по-разному шардитесь. Мы выбрали другой подход — шардинг внутри базы данных. В этом случае её код становится сложнее, но зато мы можем использовать простые клиенты. Любой клиент, подключающийся к этой базе, идёт в любую ноду, там выполняется функция, которая вычисляет, с какой нодой нужно связаться, и какой передать управление. Клиенты проще — база сложнее, но при этом она полностью отвечает за свои данные. К тому же самое сложное — это решардинг. Когда база отвечает за свои данные, решардинг делать намного проще, чем когда у вас есть клиенты, которых вы ещё и не можете обновить. Как мы это сделали? Шестиугольники — это Tarantool’ы. Возьмём тройку нод, назовём шардом номер один. Поставим точно такой же кластер и назовём шардом номер два. Соединим все ноды друг с другом. Что это дает? Во-первых, у нас есть Raft, где внутри тройки серверов мы знаем, кто лидер, кто фолловер, каково состояние кластера. Благодаря новым связям шардинга мы теперь знаем состояние чужого шарда. Мы прекрасно знаем, кто является лидером во втором шарде, кто является фолловером, и так далее. В общем случае, мы всегда знаем, куда перенаправить пришедшего на первый шард пользователя, если ему нужен не первый шард. Рассмотрим простые примеры. Допустим, пользователь запрашивает какой-то ключ, который лежит на первом шарде. Он приходит в узел из первого шарда. Т.к. он знает, кто является лидером, запрос перенаправляется в лидера, тот в свою очередь, получает или пишет ключ, и ответ затем возвращается пользователю. Допустим теперь, что пользователь приходит в ту же ноду, и ему нужен ключ, который лежит на самом деле на втором шарде. То же самое: первый шард знает, кто является лидером во втором, идёт в эту ноду, получает или пишет данные, возвращает пользователю. Очень простая схема, но с ней есть сложности. Основная проблема: не слишком ли много соединений? В схеме, когда каждая нода соединена с каждой, получается 6*5 — 30 соединений. Ставим ещё один шард — получаем уже 72 соединения в кластере. Многовато. Мы решаем эту проблему так: просто ставим парочку Tarantool’ов, только называем их уже не шардами или базами, а прокси, которые будут заниматься исключительно шардированием: вычислять ключ, выяснять, кто является лидером в том или ином шарде, а сами Raft-кластеры останутся замкнутыми в себе и будут работать только внутри самого шарда. Когда клиент приходит на прокси, она вычисляет — какой шард ему нужен, и, если ему нужен лидер, — перенаправляем на лидера. Если неважно кто — перенаправляем на любую ноду из этого шарда. Сложность получается линейной, зависящей от количества узлов. Если у нас будет три шарда по три узлам в каждом, то мы получим в разы меньше соединений. Схема с прокси рассчитана на дальнейшее масштабирование, когда шардов становится больше двух. При двух шардах мы имеем одинаковое количество соединений, но с ростом количества шардов мы заметно экономим на соединениях. Список шардов хранится в конфиге Lua, и чтобы получить новый список, просто перезагружаем код, и всё работает. Итак, мы начали с master-master, реализовали Raft, прикрутили к нему шардинг, потом прокси, переписали всё это. Получился кирпичик, кластер. Наша схема стала выглядеть довольно просто. Остаются наши фронтенды, которые только кладут или забирают токены. Есть рефрешеры, которые обновляют токены, забирают refresh-токен, отдают в OAuth-провайдер, кладут новый access-токен. Мы говорили, что у нас есть ещё вторичная логика, из-за которой кончились ресурсы процессора. Давайте перенесём её на другой кластер. К такой вторичной логике в основном относятся адресные книги. Если есть токен пользователя, то ему соответствует адресная книга этого пользователя. И данных по количеству там столько же, сколько и токенов. Чтобы не исчерпать ресурсы процессора на одной машине, нужен, очевидно, такой же кластер, опять реплицироваться и так далее. Мы ставим ещё пачку других рефрешеров для обновления уже адресных книг (это более редкая задача, поэтому мы не обновляем адресные книги вместе с токенами). В итоге, объединив два таких кластера, мы получили такую достаточно простую архитектуру всей системы: Очередь обновления токенов Зачем мы городили свою очередь? Можно же было взять что-то стандартное. Дело в нашей модели обновления токенов. После получения токен живёт один час. Когда подходит время окончания его действия, он должен быть обновлён. Это дедлайн-очередь: токен должен быть обновлён до определённого времени. Предположим, случился outage, кратковременный или нет, но у нас есть некоторый объём токенов с истёкшим сроком действия. Если мы будем их обновлять, то устареет ещё какое-то количество. Мы, конечно, всё догоним, но лучше было бы сначала обновить те, что вот-вот умрут (через 60 сек), а потом с оставшимися ресурсами обновлять те, которые всё равно уже умерли. В последнюю очередь мы обновляем более дальний горизонт (5 минут до смерти). Чтобы реализовать такую логику на чём-то стороннем, придётся попотеть. В случае с Tarantool это реализуется очень просто. Рассмотрим простенькую схему: есть tuple, где лежат данные Tarantool, у него есть какой-то идентификатор ID, по которому есть первичный ключ. И чтобы сделать очередь, которая нам нужна, мы просто добавляем два поля: статус и время. Статус обозначает состояние токена в очереди, время — то самое expire time, или какое-нибудь другое. Возьмём две основные функции из очереди — put и take. Задача put — принести и положить данные. Нам дают какую-то полезную нагрузку, put сам выставляет статус, время и кладёт данные. Появляется новый tuple. Приходит take, смотрит на индекс. Создаёт итератор, начинает в него смотреть. Выбирает ждущие задачи (ready), проверяет, пришло ли время их брать, или они устарели. Если задач нет, take переходит в режим ожидания. Помимо встроенного Lua в Tarantool есть ещё примитивы синхронизации между файберами — каналы. Любой файбер может создать канал и сказать: «Я здесь жду». Любой другой файбер может этот канал разбудить и передать в него сообщения. Функция, которая чего-то ждёт — освобождения задач, прихода времени или ещё чего-то, — создаёт канал, особым образом его маркирует, помещает куда-то, и дальше ждёт на нём. Если нам принесут токен, который нужно срочно обновить, допустим, put, то он отправит notify в этот канал. У Tarantool есть одна особенность: если какой-то токен случайно зарелизится, его кто-то взял take’ом на refresh или просто берёт задачу, то можно отслеживать обрывы соединений клиентов. Мы запоминаем в session stash, какому соединению какую задачу выдали. Мы ассоциируем, что с этой сессией были связаны такие-то задачи. Предположим, процесс refresh падает, просто рвётся сеть — мы не знаем, обновит он токен или нет, сможет он его положить обратно или нет. У нас срабатывает дисконнект, который находит в сессии все задачи и автоматически их высвобождает. При этом высвобожденная задача через тот же канал может передать задачу другому put, он её быстро возьмёт и обработает. За этой схемой кроется не очень много кода, на самом деле: function put(data) local t = box.space.queue:auto_increment({ 'r', --[[ status ]] util.time(), --[[ time ]] data --[[ any payload ]] }) return t end function take(timeout) local start_time = util.time() local q_ind = box.space.tokens.index.queue local _,t while true do local it = util.iter(q_ind, {'r'}, { iterator = box.index.GE }) _,t = it() if t and t[F.tokens.status] ~= 't' then break end local left = (start_time + timeout) - util.time() if left <= 0 then return end t = q:wait(left) if t then break end end t = q:taken(t) return t end function queue:taken(task) local sid = box.session.id() if self._consumers[sid] == nil then self._consumers[sid] = {} end local k = task[self.f_id] local t = self:set_status(k, 't') self._consumers[sid][k] = { util.time(), box.session.peer(sid), t } self._taken[k] = sid return t end function on_disconnect() local sid = box.session.id local now = util.time() if self._consumers[sid] then local consumers = self._consumers[sid] for k,rec in pairs(consumers) do time, peer, task = unpack(rec) local v = box.space[self.space].index[self.index_primary]:get({k}) if v and v[self.f_status] == 't' then v = self:release(v[self.f_id]) end end self._consumers[sid] = nil end end Put просто кладёт в space данные, которые пользователь захотел положить в очередь, указывает статус и текущее время, если это простая FIFO-очередь, по которой будет индекс, и возвращает задачу. С take чуть посложнее, но тоже просто: заводим итератор и ждём появления новой задачи. Функция taken просто помечает задачу взятой, но самое главное — она запоминает, кто что взял. На on_disconnect мы можем высвободить все задачи, взятые конкретным пользователем, конкретное соединение. Возможны ли альтернативы? Конечно. Мы могли взять любую БД. При этом нам всё равно пришлось бы построить очередь для логики работы с внешней системой, с обновлениями, и так далее. Мы не можем просто обновлять токены по запросу, у нас тогда будет непрогнозируемая нагрузка. Нам всё равно нужно поддерживать систему живой, но тогда мы бы клали отложенные задачи в очередь. Нам нужно было бы следить за консистентностью (наличие записей в базе и в очереди). Нам всё равно пришлось бы сделать отказоустойчивую очередь с кворумом. К тому же, если мы помещаем одновременно данные и в память, и в очередь, которая, скорее всего, при наших нагрузках понадобилась бы in memory, то мы бы потребляли больше ресурсов. А в нашем случае БД одновременно и хранит токены, и за логику очереди мы заплатили двумя байтами, плюс ещё пятью. Итого — плюс 7 байт на tuple, и есть логика очереди. В любом другом варианте очереди мы бы потратили намного больше, вплоть до двукратного увеличения потребления памяти. Подведём итог Для начала мы решили нашу проблему с outage, она возникала регулярно. Внедрение вышеописанной системы позволило избавиться от этой неприятности. Мы получили возможность горизонтально масштабироваться за счёт шардинга. Снизили количество соединений с N2 до линейной зависимости, попутно улучшили логику очереди под нашу бизнес-задачу: обновляем то, что мы ещё можем обновить в случае каких-то задержек. Они возникают не только по нашей вине: те же Google, Microsoft, и другие сервисы могут что-то выкатить у себя на OAuth-провайдере, и у нас возникает куча необновлённых токенов. Делайте расчёты в БД непосредственно рядом с данными, это очень удобно, производительно, масштабируемо и гибко. И вообще Tarantool прикольный. Спасибо.", "image": ["https://habrastorage.org/files/268/083/ffd/268083ffd2fe4328a5c0b6c62fa66d02.jpg", "https://habrastorage.org/files/059/f34/405/059f34405aa143ee9656158540a3a43d.png", "https://habrastorage.org/files/22c/a56/09f/22ca5609fc4c41ae96cf6b1c3093bbb4.png", "https://habrastorage.org/files/f28/0a0/fbc/f280a0fbcde24463b91fe78863044722.png", "https://habrastorage.org/files/a1c/29e/820/a1c29e820aae4673b45d3823dd35af5d.png", "https://habrastorage.org/files/6fb/136/004/6fb13600401743c8aa58c6a3935462b6.png", "https://habrastorage.org/files/42e/547/03c/42e54703c2a34a5a80a4c7ba8936d82b.png", "https://habrastorage.org/files/bfc/234/a14/bfc234a140334cec870c071d90e9c46c.png", "https://habrastorage.org/files/217/227/c99/217227c9910948bdbc8577d968ddcfcf.png", "https://habrastorage.org/files/3a1/7f5/804/3a17f580438d47fb99bebd31853b70aa.png", "https://habrastorage.org/files/5a5/012/c9d/5a5012c9dc91467989a19918276486eb.png", "https://habrastorage.org/files/cfe/389/f11/cfe389f115704b1c855c39ae18c841cd.png"], "tag": ["mail.ru", "tarantool", "raft"], "rating": ["+52"], "bookmarks": ["58"], "views": ["7,4k"], "comments_count": ["2"]},
{"author": ["zloidemon"], "date": ["20 апреля в 11:34"], "hubs": ["Разработка веб-сайтов", "Высокая производительность", "Анализ и проектирование систем", "Lua", "Блог компании Mail.Ru Group"], "type_label": [], "text": "В современном мире информационных технологий у всех — и у крупных, и у небольших компаний — существует большое количество различных API. И отказоустойчивость, несмотря на многие best practices, чаще всего не позволяет гарантировать 100%-й возможности корректно обрабатывать запросы клиентов, а также восстанавливаться после сбоя и продолжать обработку запросов, утерянных из-за сбоя. Эта проблема возникает даже у больших игроков в интернете, не говоря уже о не очень крупных компаниях. Я работаю в компании Calltouch, и наша основная цель — добиться отказоустойчивости сервисов и получить возможность управлять данными и запросами, которые клиенты совершали в API-сервис. Нам нужна возможность быстро восстанавливать сервис после сбоя и обрабатывать запросы к сервису, у которого возникли проблемы. Начинать обработку с момента отказа. Всё это позволит приблизиться к состоянию, когда почти невозможно потерять запросы клиентов на нашей стороне. Разбирая предложенные на рынке решения, мы открыли для себя превосходную производительность и практически безграничные возможности по управлению данными и их обработке — с очень незначительными требованиями к техническим и финансовым ресурсам. Предыстория В Calltouch существует сервис API, куда поступают запросы клиентов с данными на построение отчётов в веб-интерфейсе. Эти данные очень важны: они используются в маркетинге, и их потеря может повлечь за собой непредвиденную работу сервиса. Как и у всех, иногда после выкладки или добавления новых возможностей у сервиса возникают проблемы, на некоторое время может произойти отказ в работе. Поэтому нужна возможность очень быстро взять и обработать те запросы с данными, что не были доставлены в сервис API в момент сбоя. Одной лишь балансировкой с бэкапом не обойтись по ряду причин: Объём памяти, необходимый для сервиса, может требовать нового оборудования. Стоимость оборудования сейчас высока. От ошибки с killer request никто не застрахован. Довольно простая задача (хранение запросов и быстрый доступ к ним) порождает высокие издержки для бюджета. В связи с этим мы решили провести исследование, каким образом сейчас можно сохранить все входящие запросы с очень быстрым доступом к ним. Исследование Было несколько вариантов, как хранить входящие данные. Первый вариант Сохранять запросы с данными, используя логи nginx, и складывать в какое-то место. Если возникнут проблемы, сервис API обратится к данным, которые где-то сохранены, и после сделает необходимую обработку. Второй вариант Сделать дублирование запросов HTTP в несколько мест. Плюс написать дополнительный сервис, который будет куда-то складывать данные. Конфигурирование веб-сервера для сохранения данных через логи для последующей обработки имеет свои минусы. Такое решение не очень дешёвое, а скорость доступа к данным будет крайне небыстрой. Понадобятся дополнительные сервисы для работы с файлами логов, агрегации и хранения данных. Плюс потребуется большой объём финансовых затрат — на внедрение новых сервисов, обучение сотрудников эксплуатации, вероятную закупку нового оборудования. И самое главное, если такого решения ранее не было, то придётся найти и время на внедрение. По этим причинам мы почти сразу отказались от первого варианта и начали исследовать возможности реализовать второй вариант. Реализация Мы выбирали между nginx, goreplay и lwan. Первым отпал lwan, так как goreplay умеет сразу всё, что нам надо. Осталось лишь выбрать nginx с @post_action или goreplay. Goreplay был эталоном для этой схемы, но мы решили остановиться и поразмыслить о запросах: где и как их лучше хранить. О хранении можно было особо не задумываться до определённого момента. Нам потребовалась обратная связь между уже обработанными и ещё не обработанными данными. В API, для которого мы делаем дублирование запросов, не предусматривались ID в запросах с клиентской стороны. И возникла такая ситуация: понадобилась возможность подставлять дополнительные данные во входящий запрос. Это позволило бы получить обратную связь между обработанными и необработанными данными, ведь в базу попадут все данные, а не только необработанные. Затем каким-то образом нужно разбираться со всеми входящими данными. Чтобы разделаться с ID запросов, мы решили добавлять на стороне веб-сервера заголовок с UUID и проксировать такие запросы к API — чтобы сервис API после обработки изменял/удалял те запросы, которые мы дублируем в базе данных. На этом моменте мы отказываемся и от goreplay в пользу nginx, так как nginx поддерживает множество модулей, включая возможность записи в различные базы данных. Это позволит упростить схему обработки данных и уменьшить количество вспомогательных сервисов при решении данной технической задачи. Не придётся тратить время на изучение дополнительных языков и дорабатывать goreplay для соответствия требованиям. Наиболее простым вариантом было бы взять модуль для nginx, который может писать в какую-нибудь базу данных всё содержимое входящих запросов. Дополнительного кода и программирования в конфигах не очень бы хотелось. Самым гибким и подходящим для нас оказался модуль для Tarantool, им можно проксировать все данные в Tarantool без каких-либо дополнительных действий. В качестве примера приведём простейшую конфигурацию и небольшой скрипт на Lua для Tarantool, в котором будут логироваться все тела входящих запросов. Взаимодействие сервисов отображено на схеме ниже. Для этого нам требуется nginx с набором модулей и Tarantool. Дополнительные модули к nginx: nginx_upstream_module nginx-uuid4-module Пример конфигурации апстрима в nginx для работы с Tarantool: upstream tnt { server 127.0.0.1:3301 max_fails=1 fail_timeout=1s; keepalive 10; } Конфигурация проксирования данных в Tarantool с использованием post_action: location @send_to_tnt { tnt_method http_handler; tnt_http_rest_methods all; tnt_pass_http_request on pass_body parse_args pass_headers_out; tnt_pass tnt; } location / { uuid4 $req_uuid; proxy_set_header x-request-uuid $req_uuid; add_header x-request-uuid $req_uuid always; proxy_pass http://127.0.0.1:8080/; post_action @send_to_tnt; } Пример процедуры в Tarantool, которая принимает входящие данные из nginx: box.cfg { log_level = 5; listen = 3301; } log = require('log') box.once('grant', function() box.schema.user.grant('guest', 'read,write,execute', 'universe') box.schema.create_space('example') end) function http_handler(req) local headers = req.headers local body = req.body if not body then log.error('no data') return false end if not headers['x-request-uuid'] then log.error('header x-request-uuid not found') return false end local s, e = pcall(box.space.example.insert, box.space.example, {headers['x-request-uuid'], body}) if not s then log.error('can not insert error:\\n%s', e) return false end return true end Решением можно считать небольшой размер кода на Lua и довольно простую конфигурацию nginx. Часть с API здесь учитывать нет смысла, именно её необходимо делать в любом варианте реализации. Можно легко расширить эту схему master-master репликацией в Tarantool и сделать балансировку нагрузки на несколько нод, используя nginx или twemproxy. Поскольку post_action отправляет данные в Tarantool на несколько миллисекунд позже, чем запрос приходит в API и обрабатывается, в схеме есть один нюанс. Если API работает так же быстро, как Calltouch, то придётся сделать несколько запросов на удаление или тайм-аут перед запросом в Tarantool. Мы выбрали несколько запросов вместо тайм-аутов, чтобы наши сервисы работали без задержек, так же быстро, как и ранее. Заключение В заключение можно добавить тот факт, что всего лишь nginx и модуль nginx_upstream_module совместно с Tarantool позволяют достичь невероятной гибкости и простоты в работе с http-запросами, высокой скорости доступа к данным без нарушения работы основных сервисов, значительных перемен при внедрении в существующую инфраструктуру. Охват задач — от создания сложных статистик до обычного сохранения запросов. Не говоря о том, что можно использовать как обычный веб-сервис и реализовать API на базе данного модуля для nginx и Tarantool. Как развитие на будущее в Calltouch отмечу возможность создания интерфейса, в котором можно почти мгновенно получить доступ по каким-то фильтрам к различным данным. Использовать реальные запросы на тестах вместо синтетической нагрузки. Производить отладку приложений при возникновении проблем — и для повышения качества, и для устранения ошибок. При возможности иметь столь высокую доступность данных и гибкость в работе можно повышать количество сервисов и их качество незначительной суммой расходов на внедрение Tarantool в различных продуктах.", "image": ["https://habrastorage.org/files/656/391/54f/65639154fc194c6589bf230e85c46cc1.jpg", "https://habrastorage.org/files/c74/a83/75f/c74a8375f7334a4fbad98e335eea7899.png"], "tag": ["tarantool", "calltouch"], "rating": ["+24"], "bookmarks": ["33"], "views": ["4,6k"], "comments_count": ["15"]},
{"author": ["Migrator"], "date": [" 7 марта в 11:38"], "hubs": ["Разработка для интернета вещей", "Программирование микроконтроллеров", "Lua"], "type_label": [], "text": "Замечательно жить на берегу горного озера, среди девственной, природы. Дышать только чистым, наполненным ароматом трав воздухом. Но мало у кого это получается. И в мегаполисе, дома и в офисе можно достигнуть максимально возможного качества воздуха. Для этого в первую очередь надо видеть и понимать, что нас окружает? Каким воздухом мы дышем? Нам уже стали привычны термометры, барометры, приборы показывающие влажность. Но эти приборы ничего нам не говорят о качестве окружающего воздуха. А значит мы будем слушать советы, которые не всегда верны, руководствоваться слухами, не зная наверняка, правильно ли мы поступаем. Один из таких мифов – что в городах отвратительный воздух, грязный и ядовитый. И вместо кислорода сплошные выхлопы от автомобилей. Мы воспринимаем это как данность, и не пытаемся исправить ситуацию, даже там, где способны это сделать, в собственном доме, или офисе. Даже те, у кого есть маленькие дети, или проблемы с аллергией, прикладывают свои усилия в слепую, не контролируя результатов. Есть много полезных приборов позволяющих увеличить качество воздуха в нашем доме — увлажнители, ионизаторы, мойки воздуха, приточные вентиляции и фильтры. Но этого недостаточно. Нужен прибор которым вы могли-бы непосредственно померять качество воздуха в вашем доме. Что бы Вам было понятно и очевидно чем Вы дышите. Как температура на градуснике. Что может дать подобный прибор? Многие думают что в мегаполисе воздух грязный именно на улице, где машины и заводы. А в помещении воздух чище. Но это совсем не так. Достаточно померять. Человек выдыхает в 100 раз больше СО2 чем вдыхает. И в герметично закрытом помещении, тем более, если присутствует несколько человек, воздух становится удушливым очень быстро. В доме много мебели и отделочных материалов, выделяющих токсичные вещества. В квартире быстро скапливается пыль, которая может нанести серьезный вред Вашему здоровью. Воздух в закрытом помещении в 4-8 раз грязнее чем на улице, и в 8-10 раз токсичнее. И Вы можете это померять и увидеть, если у вас есть соответствующие приборы. И понять как часто вам стоит проветривать помещение, в любую погоду. Один из серьезных загрязнителей воздуха это пыль. Переносчик инфекций, любимая среда для клещей-сапрофитов и серьезный аллерген — пыль загрязняет воздух сильнее всего. В доме, где есть аллергики, рекомендуют радикальные меры: гардины и портьеры поменять на жалюзи, убрать паласы, книги, декоративный текстиль и плюшевые игрушки. И даже мягкую мебель поменять на аналоги в кожаной обивке. Книги, сувениры, всякую мелочь – хранить под стеклом. И конечно важно знать что Ваши усилия не пропадают даром и количество пыли в доме минимально. А это тоже можно померять и увидеть. Опасность таит и домашняя обстановка, мебель, лаки, краски, ДСП, МДФ, некоторые пластики могут выделять фенолы, формальдегиды и т.д. Совершено не важно, какой цены мебель из ДСП — все равно в воздух «полетят» вредные для организма соединения. Но и с этой бедой можно эффективно бороться, в том числе проветриванием помещения. Просто надо видеть врага в лицо. Измерять и контролировать. Собственно то, что я предлагаю — Прибор для контроля качества, основных параметров окружающего воздуха. который я сделал для себя. И делюсь с вами его конструкцией. Прибор доступен для самостоятельной сборки, любому кто мало-мальски умеет держать в руке паяльник. В продолжении и развитии прошлой темы датчика СО2, я усовершенствовал прибор и предлагаю вашему вниманию новую версию, теперь уже комплексного мониторинга качества воздуха. В прибор было добавлено еще 2 датчика. Датчик пыли PMS5003 и датчик формальдегида ZE08-CH20. Так же прибор обзавелся часами DS3231 и научился подавать звуки MP3-TF-16P. Были выкинуты датчик температуры и влажности. От них было мало толку. Из-за того, что начинка нагревается показания этих датчиков сильно отличались от реальности. Основа прибора как и прежде контроллер ESP8266 dev kit 1 и датчик СО2 MH-Z19. Так же как в первой версии прибора датчик подключен по ШИМ. Для подключения остальных датчиков, экрана(все это висит на одних контактах) и модуля издающего звуки был использован аналоговый коммутатор 74HC4052. Контроллер последовательно подключается к датчику формальдегида и пыли. После этого переключается на экран и выводит информацию. Если наступает необходимость подать звуки, контроллер переключает коммутатор на звуковой модуль. Датчики пыли, формальдегида и звуковой модуль общаются с контроллером посредством UART. В момент опроса датчиков, или воспроизведения звуков, UART контроллера переключается на альтернативные контакты и в этот момент невозможно общение по USB с компьютером. В данной модели я использовал большой 2,8” экран, разрешением 240x320 точек. С интерфейсом SPI на базе контроллера ILI9341. Никакого управления, кроме кнопки включения на приборе нет. Просто включаешь в розетку( в приборе встроен блок питания на 5v) и можно наблюдать за показаниями. На экран выводится следующая информация: В верхнем левом углу часы с датой и месяцем. С право от часов выводится показания датчика формальдегида в µg/mᶟ. Следующий ряд, это показания датчика пыли. Тут 3 значения. Первое пыль диаметром меньше 1мкм, дальше частицы меньще 2,5 мкм и справа частицы до 10 мкм. Значения выводятся в µg/mᶟ. Под показаниями датчика пыли выведена строчка мелких цифр. Это для особо любознательных, тут перечислены значения счетчика частиц пыли разных фракций. Данные даны — количество частиц на 1л воздуха. Ниже график измерений содержания в воздухе углекислого газа СО2, приблизительно за последние полчаса. В самом низу текущее значение концентрации СО2 в ppm. Справа светофорчик, сигнализирующий о опасности, или безопасности данной концентрации СО2. Зеленый сигнал говорит о том что концентрация меньше 900 ppm и хорошем качестве воздуха, желтый о душной обстановке и концентрации от 900 до 1500 ppm. Красный сигнал показывает что концентрация углекислого газа выше 1500ppm и это опасно для здоровья и плохо сказывается на самочувствии. Когда уровень концентрации СО2 достигает 900ppm из прибора раздается чихание. Если уровень поднимается выше 1500ppm прибор «кашляет». На лицевой стороне прибора имеется наклейка, на которой расписаны какие параметры прибора что обозначают и каковы нормальные, высоки и опасные концентрации газов и пыли. Датчики: Датчик СО2 MH-Z19 — Недиспергирую- инфракрасный датчик (или датчик NDIR) представляет собой простой спектроскопического датчик используемый в качестве детектора углекислого газа. Предел измерений до 5000ppm нижний предел около 400ppm(естественный уровень СО2 в атмосфере). Паспортная точность 50ppm. Время отклика около 30 секунд. При подаче питания первую минуту полторы выдает максимальные, или минимальные показания, потом включается и выдает реальные данные. Информация с датчика получается по ШИМ. В момент считывания контроллер измеряет скважность сигнала на выхоже датчика и по формуле преобразует его в уровень СО2. Датчик пыли PMS5003. NDIR датчик пыли измеряющий концентрацию пыли с разбиением отдельно на 3 фракции 1, 2.5 и 10 микрон. Так же имеет счетчик частиц пыли разделенный на 6 фракций. Точность заявлена 10%. Датчик используется в активном режиме. Это значит что он сам автоматически через установленные промежутки времени посылает информацию в UART. Когда необходимо получить информацию с датчика, контроллер подключается к нему по средствам коммутатора и ожидает очередной посылки данных. Датчик формальдегида ZE08-CH2O Электрохимический датчик термостабилизированный. Этот датчик так же используется в активном режиме. Он самостоятельно, каждую секунду посылает данные в UART и когда контроллер переключает на него коммутатор, происходит считывание данных. Для извлечения различных звуков и звуковой сигнализации о состоянии воздуха используется миниатюрный mp3 плеер управляемый по UART — MP3-TF-16P. Данная плата имеет на борту считыватель микро SD карты, на которую записываются звуковые файлы в mp3 формате. Также имеется усилитель мощности и может быть подключен динамик на 8ом. Выбор и воспроизведение файлов записанных на sd карточку управляется по UART с контроллера устройства. В программу встроена защита от оповещения в ночное время. После 22:00 и до 8:00 звуковой сигнал не подается. Для вывода на экран времени и даты используется модуль часов DS3231, который работает по протоколу I2C. Заявленная точность 2 минуты в год. Для переключения основного контроллера ESP8266 между датчиками, экраном и звуковым модулем используется аналоговый коммутатор 74HC4052. Это сдвоенный коммутатор на 4 линии. ESP8266 использует для UART выводы D9, D10 но мы не можем использовать эти выводы, так как они подключены к встроенному на плату контроллера адаптеру USB. К счастью есть возможность переключать выходы UART на альтернативные контакты D7, D8. Но эти же контакты использует шина ISP по которой контроллер подключен к дисплею. Для того, что бы разобраться с этим зоопарком и используется коммутатор. Он имеет 2 входа и по 4 выхода. В один момент каждый вход может быть подключен к одному из 4 выходов. К каждому выходу подключен датчик, или дисплей, или звуковой модуль. По управляющим пинам контроллер выбирает к какому устройству нужно подключиться в данный момент. При выводе на экран контроллер подключается к дисплею, при считывании данных к датчику, а при воспроизведении звуков к mp3 плееру. Так же в приборе используется вентилятор, который продувает закрытый корпус воздухом, что бы датчики адекватно реагировали на изменения атмосферы вокруг прибора. Скоростью вентилятора управляет контроллер, так как если ее не снижать вентилятор слишком сильно гудит. Общий цикл опроса датчиков и вывода на экран информации составляет 5 секунд. Схема устройства: Монтажная плата: → Файл прошивки → Файл скриптов: → Тут пошаговая инструкция как собирать прибор → Тут инструкция по прошивке", "image": ["https://habrastorage.org/getpro/habr/post_images/600/6bf/d8d/6006bfd8d4d36041bb0cad3261c600d7.jpg", "https://habrastorage.org/getpro/habr/post_images/e8a/60c/cac/e8a60ccac7de113b810d1944b5b6e7e3.jpg", "https://habrastorage.org/getpro/habr/post_images/574/69f/b62/57469fb62e9aaa16776089128c69a812.jpg", "https://habrastorage.org/getpro/habr/post_images/cbd/80c/a10/cbd80ca102d9c7cbdea368fe01d20495.jpg", "https://habrastorage.org/getpro/habr/post_images/faa/cb0/c7e/faacb0c7ec64976ee604549c4fe46551.jpg", "https://habrastorage.org/getpro/habr/post_images/a40/04b/1cc/a4004b1cc99ffe49bb9fee8a484e4476.jpg", "https://habrastorage.org/getpro/habr/post_images/ea1/081/5cf/ea10815cfd5bf0d7378ac874563957f9.png", "https://habrastorage.org/getpro/habr/post_images/00b/9cc/b75/00b9ccb75c0af72cdb1d737da1d72a2d.png", "https://habrastorage.org/getpro/habr/post_images/4c3/7c4/40f/4c37c440f9e6fbbc3ae9ad816a2eda0f.jpg"], "tag": ["со2", "экология", "климат в офисе"], "rating": ["+40"], "bookmarks": ["201"], "views": ["18,6k"], "comments_count": ["91"]},
{"author": ["yegorf1"], "date": ["21 мая 2016 в 12:04"], "hubs": ["Разработка игр", "Lua", "Java", "C"], "type_label": ["Tutorial"], "text": "Всем доброго времени суток! Возникла потребность встроить рекламу в свою игру на Love2D. Решил показывать баннер после выигрыша игрока и тут появились сложности: банер вызывается Java кодом приложения, а выигрыш определяется в Lua коде. Связывает их код на Си, туториалов, как добавлять свои методы в движок не было, и пришлось копаться в коде самостоятельно. Репозиторий Love2D для Android лежит вот тут. С чего начать? Начать я решил с изучения метода love.system.vibrate() – метод, который появляется при использовании Love2D на андроид, а значит его где-то добавляют также, как я хочу добавить рекламу. Если открыть класс GameActivity, то там можно найти метод vibrate, который мы ищем, и вот тут стоит объяснить, как происходит вызов Java кода из Lua. Когда приложение только запускается, для каждого модуля Love2D создается экземпляр класса модуля и экземляр класса связки (объект, который привязывает Сишный объект к переменной Lua). У объекта связки для каждого метода, который нужно интегрировать в Lua есть свой маленький метод и список, в котором указано какой метод в Lua сопостовляется сишной связке. Выглядит это так: // Список связок static const luaL_Reg functions[] = { { \"getOS\", w_getOS }, { \"getProcessorCount\", w_getProcessorCount }, { \"setClipboardText\", w_setClipboardText }, { \"getClipboardText\", w_getClipboardText }, { \"getPowerInfo\", w_getPowerInfo }, { \"openURL\", w_openURL }, { \"vibrate\", w_vibrate }, { 0, 0 } }; extern \"C\" int luaopen_love_system(lua_State *L) { // Эземпляр модуля System *instance = instance(); if (instance == nullptr) { instance = new love::system::sdl::System(); } else instance->retain(); // Итоговая связка WrappedModule w; w.module = instance; w.name = \"system\"; w.type = MODULE_ID; w.functions = functions; w.types = nullptr; return luax_register_module(L, w); } Так же замечу, что дополнительные методы, которые добавлены для андроида, хранятся в отдельном классе, который лежит в папке ./jni/love/src/common/ и называется android. Добавляем свой метод Сначала создадим статичный метод в классе GameActivity: private static GameActivity instance; @Override protected void onCreate(Bundle savedInstanceState) { instance = this; // ... } // ... // Важно, чтобы метод был статичным, потому что доступ к // экземпляру класса получить будет сложнее public static void showAd() { Toast.makeText(instance, \"Ad example\", Toast.LENGTH_LONG).show(); } Теперь создадим метод в модуле love.system. Я выбрал этот модуль, потому что внедряю рекламу, но использовать именно system не обязательно. Можно даже создать свой модуль, в зависимости от того, что вам нужно. Сначала нужно написать главную часть метода в классе android. Объявляем: // ./jni/love/src/common/android.h bool openURL(const std::string &url); void showAd(); void vibrate(double seconds); И создаем: // ./jni/love/src/common/android.cpp void showAd() { // Получаем среду исполнения Java JNIEnv *env = (JNIEnv*) SDL_AndroidGetJNIEnv(); // И класс, в котором мы создали статичный метод jclass activity = env->FindClass(\"org/love2d/android/GameActivity\"); // Теперь сам метод jmethodID show_ad_method = env->GetStaticMethodID(activity, \"showAd\", \"()V\"); // И вызываем его env->CallStaticVoidMethod(activity, show_ad_method); env->DeleteLocalRef(activity); } При получении идентификатора метода третим параметром мы указываем, что возвращает метод и какие параметры принимаем. Если ваш метод будет принимать аргументы, то в скобках их нужно перечислить. Если ваш метод возвращает значение, то также нужно будет изменить V на соответствующую букву. Так, чтобы описать вот такой метод: bool isGreater(double a, double b) { return a > b; } Будет использоваться следующая строка: (DD)Z. Подробнее можно прочитать вот тут. Добавляем метод showAd в сам модуль: // ./jni/love/src/modules/system/System.h /** * Shows ad */ virtual void showAd() const; Ну и сам код: // ./jni/love/src/modules/system/System.cpp void System::showAd() const { #ifdef LOVE_ANDROID love::android::showAd(); #endif } Немного клея Теперь осталось все это соединить с помощью связки. Добавляем соответсвующий метод в класс связки: int w_showAd(lua_State *L) { instance()->showAd(); return 0; } // Ну и список связок конечно же static const luaL_Reg functions[] = { { \"getOS\", w_getOS }, { \"getProcessorCount\", w_getProcessorCount }, { \"setClipboardText\", w_setClipboardText }, { \"getClipboardText\", w_getClipboardText }, { \"getPowerInfo\", w_getPowerInfo }, { \"openURL\", w_openURL }, { \"vibrate\", w_vibrate }, { \"showAd\", w_showAd }, { 0, 0 } }; Собираем все это по туториалу с самого начала. Добавляем код в луа (love.system.showAd()) и проверяем: Вуаля. Заключение С помощью подобных манипуляций можно встраивать рекламу, управлять светодиодом, камерой и вообще делать много полезных вещей с помощью игры, что местами бывает очень полезно для интересных игровых задумок. Спасибо за прочтение (:", "image": ["https://habrastorage.org/files/3f4/c7c/f44/3f4c7cf4491a479ebf0d1aba4907392a.PNG", "https://habrastorage.org/files/dc7/527/4c4/dc75274c4b9d4e1bb19d8318c38190dc.png"], "tag": ["gamedev", "love2d", "game development", "jni", "luajit"], "rating": ["+6"], "bookmarks": ["32"], "views": ["8,5k"], "comments_count": ["11"]},
{"author": ["akalend"], "date": ["13 октября 2016 в 00:38"], "hubs": ["Высокая производительность", "Анализ и проектирование систем", "Lua"], "type_label": [], "text": "В современном WEB Конструировании очень часто возникают задачи, когда необходимо оповестить пользователя о каком-нибудь событии: пришло новое сообщение, изменился курс на бирже или статус заказа, с конвертировался видео-контент или подскочила температура больной бабушки. Есть несколько вариантов решения такого класса задач. Наиболее оптимальное и распространенное решение – это подписка на события. Как это реализуется в нагруженных проектах? Предположим, что мы разрабатываем сервис брокерской конторы, в которой обслуживаются тысячи клиентов. Для того, чтоб узнать состояние курса акций на бирже или узнать кол-во свободных мест в отелях, нам необходимо обратиться к одному или нескольким внешнем сервисам. Так как, внешний сервис отвечает с задержкой, а у нас тысячи клиентов, то в случае, если мы будем делать запросы на прямую из WEB приложения и ждать ответа от сервиса, то в результате всё повиснет. Поэтому, нам приходиться делать, так называемый, отложенный запрос. Наше WEB приложение сразу возвращает пользователю сформированную HTML страницу без результата, на которой показывается заставка, что запрос выполняется, а результат приходит чуть позже, по мере его исполнения. Как это происходит? Перед началом формирования HTML страницы, наше WEB приложение кладёт в очередь данные. Демон, или вызываемая по крону задача, просматривает очередь и забирает из неё данные. Далее, на основании этих данных, она формирует запрос и отправляет его внешнему сервису (картинка 1). Вроде бы, всё в этой схеме хорошо – работает без задержек. Но нам нужна обратная связь.Конечному пользователю необходима та информация, которую он запрашивал. И вот, эту информацию мы получили в нашем крон скрипте. Теперь её необходимо переправить пользователю. Тут нам поможет паттерн Издатель-Подписчик. Многим, кто использует JavaScript известна эта схема: Подписчик (Subscriber) подписывается на некоторый канал, а при свершении некоторого события, Издатель (Producer) в этот канал отправляет сообщение. В качестве такого механизма уведомлений можно использовать много разных решений: Redis, RabbitMQ, Tarantool, MsMQ, ZMQ, Kafka (брокера сообщений). Так как у нас ряд сервисов уже был завязан на Redis, мы решили не вводить новые сущности. Как бы вы это использовали? Тут найдется несколько вариантов, но специалисты сразу в три горла заявят “Для связи WEB страницы и сервера надо использовать websockets”. Не буду спорить, да, на сегодня – это наиболее продвинутая технология моментального общения WEB-клиента и сервера. Рассмотрим серверную сторону. Ни для кого не открою секрета, что уже, как несколько лет как nginx умеет проксировать websockets. Если у нас в качестве бэкенда используется php-fpm, то на каждый запущенный WEB-клиент, у нас должен быть запущен PHP процесс. Тут возникает проблема 10К, когда на 10К запросовбудет висеть 10К процессов. Банально не хватит памяти. Как один из вариантов, можно использовать node.js. Это, как раз его класс задач, где используются долгоиграющие не блокируемые соединения. А можно обойтись без него? Ведь, не хотелось бы вводить новую сущность, тем более на неё возлагаем очень простую задачу. Чем сложнее архитектура, тем больше точек отказа и меньше вероятность безотказной работы. У нас уже был положительный опыт внедрения модуля nginx-lua (Более подробнее про nginx-lua можно почитать тут и тут). А может ли он выполнить эти функции? В общем, в итоге получилась вот такая картина (картинка 2): Оказывается это не так сложно. Дополнительно к lua-nginx-module подключаем lua-resty-redis и lua-resty-websocket. Для этого, в отличие от lua-nginx-module ни чего собирать не надо, а лишь все исходные коды модулей, которые находятся в директории lib переписать в папку: /usr/share/nginx/lua/lib и подключить директивой в контексте http (конфигурационный файл nginx.conf): http { lua_package_path \"/usr/share/nginx/lua/lib/?.lua;;\"; ... } Далее, в конфигурационном файле nginx.conf (или подключаемом конфиге для нашего виртуального хоста) определяем location /ws: location /ws { content_by_lua_file /path/to/file/websocket_server.lua; } Сам файл websocket_server.lua не такой уж и сложный, выкладывать тут частями — смысла не вижу. Его полную версию можно найти на github. Для проверки есть тестовый консольный клиент, который можно доработать и запустить в несколько тысяч экземпляров с разным тайм-аутом и проверить на практике. Данная версия клиента диалоговая, из консоли вводится наименование канала, и если в канал направляется публикация, то она моментально поступает на клиент. Клиент имеет тайм-аут 5 мин. Надеюсь, данная фича кому-нибудь пригодится.", "image": ["https://habrastorage.org/files/946/80a/6ec/94680a6ecc0246498ffa260fa64d149d.png", "https://habrastorage.org/files/fea/ae8/0d5/feaae80d5ece4953945c47f5f660d269.png"], "tag": ["nginx", "lua", "lua-nginx-module", "highload", "высоконагруженные приложения", "архитектура"], "rating": ["+11"], "bookmarks": ["70"], "views": ["7,1k"], "comments_count": ["11"]},
{"author": ["kostja"], "date": ["25 августа 2016 в 20:06"], "hubs": ["Разработка игр", "Lua", "Блог компании Mail.Ru Group"], "type_label": [], "text": "2 сентября 2016 года в офисе Mail.Ru Group пройдёт очередной Lua Meetup — встреча, посвящённая языку программирования Lua и его экосистеме. Анонсированы два доклада (о них вы сможете подробнее прочитать под катом), но мне бы хотелось написать о другой причине, по которой на встречу нужно прийти. В мире очень много языков программирования, и новые языки появляются чуть ли не каждую неделю. Как писал классик, «все счастливые семьи похожи друг на друга, каждая несчастливая семья несчастлива по-своему». Интересуясь исключительно мейнстримовыми языками программирования, мы лишаем себя ощущения контраста, и, как следствие, осознанности в выборе. Lua ни в какой мере не является «несчастливым» языком, но это однозначно язык, стоящий в стороне от мейнстрима. У Lua прекрасный синтаксис и очень легковесная реализация. Мало кто знает, что язык создан в 1993 году — настолько современно он смотрится. Что же мешает ему стать таким же популярным как Python или Go? Выясняется, что язык программирования — это не только синтаксис и виртуальная машина. Это в первую очередь сообщество, его дружелюбность и энергия. А также, что немаловажно, энергия создателей языка, желание управлять и развивать сообщество. А ещё очень важна поддержка от гигантов индустрии. Lua — пример языка, который развивается несмотря на отсутствие такой поддержки. Яркие события в сообществе происходят регулярно: OpenResty, Kong, Torch — из относительно established-проектов, боты для Telegram и фреймворки для их создания — из совсем нового. Программа встречи: — «LuaJIT изнутри», Николай Заварицкий, Mail.Ru Group LuaJIT — один из самых быстрых интерпретаторов для динамических языков программирования. Спикер проверит справедливость этого утверждения, сравнит производительность Lua, Python и JS, «заглянет под капот» и покажет, как устроен байткод в LuaJIT. Расскажет в деталях, как работает JIT-компилятор в LuaJIT, как находить хотспоты в программах на Lua, почему код не JIT-ится и что с этим делать. — «Механизмы для пользовательской автоматизации профессиональных веб-приложений на Lua», Александр Гладыш, ТАИС Сложные профессиональные приложения мигрируют из десктопа в веб. Часто в них требуется предоставить пользователю возможность автоматизировать свою работу, писать «макросы». Спикер расскажет об опыте использования Lua в качестве макроязыка для профессионального веб-приложения. На митапе помимо докладов хотелось бы поговорить о том, как дальше развивать язык Lua — экосистему luarocks, синтаксис, фреймворки для создания приложений. Начало в 19:00. Адрес: Ленинградский пр-т, 39, стр. 79. Участие бесплатное, но регистрация обязательна. Ждем вас!", "image": ["https://habrastorage.org/files/ab9/71d/c9a/ab971dc9aaf543dba181e899891c4ff7.jpg", "https://habrastorage.org/files/7bf/77c/4c1/7bf77c4c136f483a8bad947106093394.jpg"], "tag": ["lua", "meetup", "luajit", "mail.ru"], "rating": ["+35"], "bookmarks": ["6"], "views": ["5,2k"], "comments_count": ["12"]},
{"author": ["RussDragon"], "date": ["23 января в 14:16"], "hubs": ["Разработка игр", "Программирование", "Алгоритмы", "Lua"], "type_label": ["Tutorial"], "text": "Предисловие На написание статьи меня сподвигло практически полное отсутствие материалов на русском языке про алгоритмы генерации лабиринтов. На Хабре, из того, что вообще есть по теме, можно отметить две статьи: раз и два. Ценность и пользу из которых несет лишь вторая. В первой – просто перевод формального алгоритма и небольшое его пояснение. Что, конечно, неплохо, но очень скудно и не вызывает желания изучать тему дальше. Если моя статья Вам понравится, я продолжу писать о различных алгоритмах. Мы рассмотрим два самых примитивных и простых случая – генерация двоичного дерева и Сайдвиндер, который, по своей сути, просто чуть измененная версия двоичного дерева с одним заметным плюсом. ОСТОРОЖНО ТРАФИК. Дам один совет – не подглядывайте в код до тех пор, пока вы не напишите свою реализацию. Вы получите гораздо больше удовольствия и пользы от исправления багов и поиска ошибок, чем если просто переведете с одного языка на другой. Серьезно. Прислушайтесь к совету. Вы, верно, потратите больше времени, но оно стоит стоит. У меня, например, из-за пары ошибок появился очень забавный генератор «инопланетных» текстов, который можно использовать в различных Sci-Fi играх для создания текста. Надеюсь, Вы изучаете тему для себя и никуда не спешите. P.S.: Я буду использовать термин «смещение», предполагая английский bias. Т.е. пристрастие алгоритма к направленности в какую-либо сторону. Например, правое смещение – алгоритм генерирует лабиринты с длинными правыми проходами. Раскраска лабиринтов происходит относительно расстояния от крайнего левого угла поля до некоторой клетки. Чем дальше от начальной координаты – тем темнее будет цвет. Идеальный лабиринт – такой лабиринт, в котором одна клетка связана с другой одним единственным путем. Иначе говоря, остовное дерево. Про LuaКогда я только начинал закапываться в тему лабиринтов, я не предполагал, что в итоге буду писать статью и выбрал язык, на котором у меня есть возможность не тратить слишком много времени на рендер и архитектуру и заниматься исключительно логикой. В итоге, между C++ и Lua, выбор пал на Lua и Love2D. Не стоит переживать, если Вы с Луа незнакомы. Незнание языка никак не помешает Вам понять реализацию, благодаря простоте синтаксиса. Если Вы хотя бы немного умеете программировать, 80% кода не вызовет у Вас проблем с пониманием. Остальные 20% — language specific, про которые я всегда буду писать вначале статьи, объясняя их работу. Первое, что мне следует сказать: Lua имеет лишь одну структуру данных – таблицы – ассоциативный массив, при помощи которого мы создаем нужные нам структуры. К примеру, классы, множества, обычные массивы, стаки, очереди и тому подобное. Обращаться к ним мы может либо с помощью строчных-ключей, либо с помощью индексов. Так же, таблицы не ограничивают нас в хранении только одного типа данных в одном объекте и работают подобно структурам в C/C++. Такой код абсолютно корректен: ourStructure = {} ourStructure[“BeautyKey”] = 42 ourStructure[42] = “UltimateAnswer” ourStructure[1] = false Присваивание nil удалит поле: ourStructure[42] = nil Второе: Lua не имеет скрытого механизма копирования таблиц. Код, приведенный ниже, не будет копировать и создавать нового объекта SomeNewArray, он лишь скопирует в него ссылку на объект SomeArray, и, следовательно, будет изменять его точно так же, как если Вы передадите значение через неконстантную ссылку или указатель в C/C++: someArray = {} someArray[1] = 42 someArray[2] = “ReferencesTest” someNewArray = someArray someNewArray[1] = “42 Is Gone, Now Only the Garbage-String here” И третье, для тех, кто хорошо знаком с Lua: Да, я знаю, что в некоторых местах код избыточен. И то, что в некоторых местах всё можно было бы упростить метаметодами тоже. Следует учитывать то, что код писался в первую очередь для того, чтобы разобраться с алгоритмами, а не для использования в реальном проекте. К тому же, отсутствие избытка специфических для языка функций позволяет выкладывать код в том виде, в котором он есть, без нагромождений комментариев. Алгоритм двоичного дерева Описание: Самый первый и самый простой алгоритм в понимании, который я рассмотрю. Его суть заключается в том, чтобы проложить путь в случайном направлении из каждой клетки поля: в моей реализации либо наверх, либо вправо (зависит от выбранного Вами смещения). Мы обрабатываем только 1 клетку за единицу времени, следовательно, мы можем генерировать лабиринты бесконечного размера, сохраняя лишь конечный результат (лабиринт) без необходимости хранить какую-либо побочную информацию. Такой способ генерации имеет два побочных эффекта: 1. Лабиринты обладают сильным диагональным смещением и отсутствием тупиков в его направлении. Посмотрите на скриншоты выше и Вы увидите, что каждый из коридоров стремится к правой верхней клетке, и, как итог, имеет ровно один путь к ней, и нигде на пути нет тупика: 2. Два пустых коридора по сторонам лабиринта. Когда алгоритм «прокапывается» до конца строки/столбца, ему не остается выбора, кроме как продолжить путь в одном единственном направлении, создавая пустые «границы». К слову, название не просто так совпадает со структурой данных. Результат его работы – случайное двоичное дерево, в котором из каждой клетки (вершины) есть ровно 1 путь по направлению к корню (родительской вершине), и, соответственно, ровно 1 путь к любой другой клетке. Как следствие, любая клетка имеет не более 3 соединений со своими соседями. Формальный алгоритм (для северо-восточного смещения): Выбрать начальную клетку; Выбрать случайное направление для прокладывания пути. Если соседняя клетка в этом направлении выходит за границы поля, прокопать клетку в единственно возможном направлении; Перейти к следующей клетке; Повторять 2-3 до тех пор, пока не будут обработаны все клетки; Пример работыЗеленое – текущая рассматриваемая клетка, красное – фронт, клетки, в которые можно переместиться. Начинаем с координаты (0;0). Наверх в этом ряду пойти не можем, так как иначе выйдем за границы лабиринта. Идем вправо до упора, по пути снося все стены. Всё, тупик. Идти некуда. Перемещаемся на следующий ряд и видим, что теперь есть возможность пойти наверх и вправо. Кидаем монетку и выбираем… Верх. Убираем стену и переходим к следующей клетке. Отлично. Случай подсказывает нам идти направо. Убираем стену и перемещаемся в следующую клетку. Выбора у нас нет, налево пойти не можем, значит, убираем стену сверху и идем на следующий ряд. Монета убеждает нас пойти направо. Что же, слушаемся. Убираем стену и переходим к слеудующей клетке. Прокатившись метр, наш несчастный кусок металла падает и говорит, что пора идти наверх. Сносим стену, шагаем к следующей клетке, и, так как она крайняя в этом ряду, убираем стену сверху. Лабиринт закончен. Плюсы: Простая реализация; Высокая скорость работы; Возможность генерировать бесконечные лабиринты; Минусы: Низкая сложность рисунка; Сильное смещение по диагонали; Отсутствие тупиков по смещению; Однообразность сгенерированных лабиринтов; Реализация local mod = {} local aux = {} aux.width = false aux.height = false aux.sx = false aux.sy = false aux.grid = false function aux.createGrid (rows, columns) local MazeGrid = {} for y = 1, rows do MazeGrid[y] = {} for x = 1, columns do MazeGrid[y][x] = {bottom_wall = true, right_wall = true} -- Wall grid end end return MazeGrid end -- Binary Tree North-East variant function mod.createMaze(x1, y1, x2, y2, grid) aux.width, aux.height, aux.sx, aux.sy = x2, y2, x1, y1 aux.grid = grid or aux.createGrid(aux.height, aux.width) aux.binarytree() return aux.grid end function aux.binarytree() for y = aux.sy, aux.height do for x = aux.sx, aux.width do if y ~= aux.sy then if math.random(0, 1) == 0 then if x ~= aux.width then aux.grid[y][x].right_wall = false else aux.grid[y-1][x].bottom_wall = false end else aux.grid[y-1][x].bottom_wall = false end else if x ~= aux.width then aux.grid[y][x].right_wall = false end end end end end return mod Алгоритм «Sidewinder» Описание: Алгоритм с непереводимым названием Sidewinder по своей работе очень похож на алгоритм двоичного дерева, в том отличии, что в нём нет характерного смещения по диагонали, одного пустого коридора и клетки мы рассматриваем не по отдельности, а множествами. Лабиринты получаются с преимущественно вертикальным или горизонтальным смещением (в зависимости от реализации), с отсутствием тупиков в их направлении. В сравнении со своим более примитивным собратом, смещение не так заметно и больше похоже на «спираль», которая плавно сменяет вертикальные и горизонтальные коридоры. Что касается побочных эффектов, то Sidewinder создает только один пустой коридор на одной стороне, вместо двух. Начиная создание множеств с первого ряда поля, у нас отсутствует возможность прокопать путь наверх, так как мы находимся в самом крайнем вертикальном положении и попытка пойти выше приведет к выходу за границы поля. Но и если мы будем организовывать множества без выхода по вертикали, мы создадим несколько изолированных друг от друга областей. Для примера: 9 клеток первого ряда можно поделить на три множества, между которыми расположены стены. Каждое множество второго ряда будет прокапывать путь к одному из трех «блоков» выше. Третий ряд проложит путь к «блокам» второго. И так до конца поля. В итоге, у нас получатся 3 разветвленные, изолированные друг от друга вертикальные области, что не подходит для идеального лабиринта, в котором из каждой точки поля есть ровно 1 путь в любую другую. Формальный алгоритм (для стандартного смещения): Выбрать начальный ряд; Выбрать начальную клетку ряда и сделать её текущей; Инициализировать пустое множество; Добавить текущую клетку в множество; Решить, прокладывать ли путь направо; Если проложили, то перейти к новой клетке и сделать её текущей. Повторить шаги 3-6; Если не проложили, выбираем случайную клетку множества и прокладываем оттуда путь наверх. Переходим на следующий ряд и повторяем 2-7; Продолжать, пока не будет обработан каждый ряд; Пример работыКрасные клетки – члены множества. Мы начинаем с первого ряда и видим, что выше нас – выход за пределы поля. Сносим все стены и идем сразу во второй ряд, создаем пустое множество. Так, а вот тут интереснее. Давайте добавим в множество первые две клетки ряда. Выбираем одну из этих клеток и убираем относящуюся к ней верхнюю стенку в первый ряд. Обнуляем множество, добавляем в нее следующую клетку ряда. В этот раз ни с кем не объединяем, просто прокладываем путь наверх прямо из этой единственной клетки. Повторяем наши действия. Обнуляем множество, переходим в следующую клетку, добавляем её… А так как она осталась последней в ряде, то так же убираем стену сверху и идем в ряд ниже. А теперь сразу объединяем три первые клетки в одно множество. Случайно выбираем клетку, в нашем случае, вторую и убираем стену сверху к предыдущему ряду. Ну, тут у нас опять нет выбора, убираем стену наверху и идем на ряд ниже. На этот раз, самую перваую клетку мы сделаем единственной. Убираем стену к предыдущему ряду и идем дальше, в следующую клетку. Предположим, что захотели в конце объединить три клетки. И снова нам приглянулась средняя клетка из множества, из которой и убираем стену наверх. Всё, наш лабиринт готов. Плюсы: Возможность генерировать бесконечные лабиринты; Только 1 пустой коридор; Более сложный рисунок, в отличии от алгоритма двоичного дерева; Минусы: Более запутанная реализация; Отсутствие тупиков по смещению; Сильное вертикальное смещение; Реализацияlocal mod = {} local aux = {} aux.width = false aux.height = false aux.sx = false aux.sy = false aux.grid = false function aux.createGrid (rows, columns) local MazeGrid = {} for y = 1, rows do MazeGrid[y] = {} for x = 1, columns do MazeGrid[y][x] = {bottom_wall = true, right_wall = true} end end return MazeGrid end function mod.createMaze(x1, y1, x2, y2, grid) aux.height, aux.width, aux.sx, aux.sy = y2, x2, x1, y1 aux.grid = grid or aux.createGrid(y2, x2) aux.sidewinder() return aux.grid end function aux.sidewinder() local cx = aux.sx --[[ cx – координата начала множества по x. У нас нет надобности создавать отдельный массив для сета, так как его элементы всегда располагаются строго в ряд ]] for y = aux.sy, aux.height do for x = aux.sx, aux.width do if y ~= aux.sy then if math.random(0, 1) == 0 and x ~= aux.width then aux.grid[y][x].right_wall = false else aux.grid[y-1][math.random(cx, x)].bottom_wall = false if x ~= aux.width then cx = x+1 else cx = aux.sx end end else if x ~= aux.width then aux.grid[y][x].right_wall = false end end end end end return mod Эпилог Надеюсь, Вам понравилась статья и Вы почерпнули новые знания о примитивной процедурной генерации лабиринтов. Я выбрал два самых простых в реализации и работе алгоритма, чтобы новичкам было проще «пощупать» тему и понять, хотят ли они изучать её дальше. Мне важно знать, интересны ли такие статьи людям на Хабрахабре и стоит ли продолжать их писать. Для читателей у меня есть еще минимум 9 классических алгоритмов, которые стоит рассмотреть. Какие-то представляют из себя случайное блуждание по полю, как, например, алгоритм Прима или Уилсона, какие-то требуют больше ресурсов для работы, так как работают с графами, например, Эллер и Крускал, а какие-то выдерживают золотую середину. Но и это не конец – у меня в рукаве есть такие вещи, как: полярные (круглые) лабиринты, генерация лабиринтов на различной сетке (гексы, треугольник и пр.), маскинг лабиринтов в надписи и формы, 2.5Д лабиринты и 3Д, теория лабиринтов, статистическое сравнение алгоритмов, комбинированные алгоритмы генерации. В конце концов, у нас есть еще огромное множество вариаций типов лабиринтов. Например, сейчас мы рассматриваем идеальные алгоритмы, в которых из каждой точки есть ровно один путь в любую другую. Но ведь есть еще и те, которые позволяют одной клетке иметь несколько путей для любой другой! Например, Quake, Doom и прочие шутеры в только-только зарождающемся жанре использовали такие алгоритмы для генерации уровней, по некоторым слухам. Поэтому, если Вам понравилась статья, тема, и Вы хотите видеть их дальше – то, пожалуйста, напишите об этом в комментарии. Так же, буду очень рад любой критике, как в техническом плане, так и в лингвистическом и стилистическом.", "image": ["https://habrastorage.org/files/f95/53e/b6f/f9553eb6f4a3413481f66a89a8759e9d.png", "https://habrastorage.org/files/1b0/5e0/f47/1b05e0f47a7942389eef48eec6fea19e.png", "https://habrastorage.org/files/77e/0e3/dcd/77e0e3dcd78748ee86a7969bc104645e.png", "https://habrastorage.org/files/35c/76c/92a/35c76c92a18c4d318dc415cde6443dec.gif", "https://habrastorage.org/files/df9/1e6/2a0/df91e62a01d6467985ece549f8919c90.gif", "https://habrastorage.org/files/2ca/dc9/d72/2cadc9d7214045acaeee915e30f7fa23.png", "https://habrastorage.org/files/6f2/d9b/e11/6f2d9be110f7482d949940c8e5f13e06.png", "https://habrastorage.org/files/63a/67c/2dc/63a67c2dc1f24f7eacdd387bd82cd0e8.png", "https://habrastorage.org/files/5b9/63e/8cd/5b963e8cdb04457e8647e70269103aee.png", "https://habrastorage.org/files/f44/ad9/f98/f44ad9f9855043f49b0cb70a6cb482b7.png", "https://habrastorage.org/files/880/f69/003/880f69003276475dac6f3c444f388238.png", "https://habrastorage.org/files/daf/a13/6ac/dafa136acebb41f79ffa9a9f7ba496ee.png", "https://habrastorage.org/files/f17/559/c5a/f17559c5a797438bbd28d39874403e95.png", "https://habrastorage.org/files/1b0/ce0/82f/1b0ce082f5e0410ab00fab729bd9ea1b.png", "https://habrastorage.org/files/c06/086/b41/c06086b41af94896abc16bc13f5e45c7.png", "https://habrastorage.org/files/596/3dc/b56/5963dcb567344522bbc274d3fce17be6.png", "https://habrastorage.org/files/322/cbb/810/322cbb810a4142e3acb57dda8bf91603.png", "https://habrastorage.org/files/263/6f5/ad2/2636f5ad26b14b4bb95f1e2a4ebe6a59.png", "https://habrastorage.org/files/210/119/4f5/2101194f5abc40d69cd70dcd629cbec7.png", "https://habrastorage.org/files/2ef/18c/13a/2ef18c13aaaf42e8834a61e827bc6046.png", "https://habrastorage.org/files/b7d/851/357/b7d851357374412cbb4aeb2d2f035389.png", "https://habrastorage.org/files/f76/e47/074/f76e4707441c42c7bc85c79554a14d65.gif", "https://habrastorage.org/files/d8b/680/72a/d8b68072a6b6471393d288fa5e6fd38f.gif", "https://habrastorage.org/files/102/2a3/a9e/1022a3a9e3384f01aa161bdbe30fd2c1.png", "https://habrastorage.org/files/68e/627/bae/68e627bae0ea4d8a85d03fb9392349ee.png", "https://habrastorage.org/files/6e7/bf4/5aa/6e7bf45aaf70424c86e24ed85b01d80c.png", "https://habrastorage.org/files/e43/067/e32/e43067e32c744bb6a3150f4a149063a1.png", "https://habrastorage.org/files/932/2c2/060/9322c206053248d1a39c6c4c12393d40.png", "https://habrastorage.org/files/040/566/9c7/0405669c718c4cfa88b9f771ef0a39a6.png", "https://habrastorage.org/files/335/4d7/4d3/3354d74d31b54681860ac490874f0574.png", "https://habrastorage.org/files/867/90f/66c/86790f66c8c1433aae695925843ae65d.png", "https://habrastorage.org/files/85a/332/6ab/85a3326ab79147b19435da9e0f64a641.png", "https://habrastorage.org/files/2cd/3d9/2cd/2cd3d92cd8bc4846ab8185275e5e99b6.png", "https://habrastorage.org/files/660/b8d/a55/660b8da559ba4e3fb9eec20894d8839d.png", "https://habrastorage.org/files/ae3/348/21f/ae334821ff984b7dbc47404afa5c724c.png", "https://habrastorage.org/files/993/b8e/d5d/993b8ed5d3824143bb8a41400eecfa67.png", "https://habrastorage.org/files/484/db2/b85/484db2b855d748e8a62d21f888e8a91a.png", "https://habrastorage.org/files/e37/8cc/6ae/e378cc6ae1704d97b5e6d276510460b1.png", "https://habrastorage.org/files/ee5/c1f/8dc/ee5c1f8dcdb8411e9de155bd198f2be2.png"], "tag": ["Lua", "процедурная генерация", "лабиринты", "програмирование", "алгоритмы"], "rating": ["+68"], "bookmarks": ["314"], "views": ["21,2k"], "comments_count": ["35"]},
{"author": ["Jaguarhl"], "date": ["15 декабря 2016 в 13:26"], "hubs": ["Разработка игр", "Lua", "C++"], "type_label": [], "text": "История разработки одной фанатской компьютерной игры Fallout: The X-Project и попытки сделать из неё «конфетку» Предупрежу сразу, вы не увидите в этой статье каких-то актуальных и современных знаний, да и в целом, я не стану в ней уделять много внимания техническим аспектам. Объясню почему: сама по себе игра разрабатывалась в период с 1998 по 2008 год, а наиболее активно — где-то с 2004 по 2007. Если честно, то я и в 2005-м понимал, что будущего у игры нет. Но хотел просто её закончить. Иначе зачем столько времени и усилий потратил на проект? К тому же, я был не один, и нельзя допускать, чтобы чужие усилия были потрачены впустую. Ответственность. Но не будем отходить в сторону. Кому будет полезна статья? В первую очередь таким же ребятам, каким я был сам, учась в институте. Мечтателям, желающим создать свою игру мечты. Начнём благословясь Хотя нет, эта игра не была той самой «мечтой», конечно же. Но на момент решения о её разработке, я думал, что смогу быстро закончить проект (ага-ага!) и привлечь внимание таких же, как и я. «Надежды юноши питают...» Конечно, я играл в Fallout. Тот самый, от Black Isle и Interplay, оставшихся теперь лишь в анналах истории. Двумерный, изометрический. С отвратным русским переводом. Но это был взрыв. Крышеснос. Потому при выборе проекта, я решил использовать именно данную тему. Второй Fallout уже вышел, а про 3-й пока никто даже не заикался (на момент задумки). Игрушка предполагалась фанатской, рассчитанной только на русскоязычных игроков, и не предполагала извлечение прибыли. Только опыта. Коим я здесь и делюсь. Кстати, позже вышла еще Fallout Tactics, из которой было позаимствовано не мало графики для игры. И звуков. Впрочем, тягалось всё и из обоих оригинальных фоллаутов. Почему текстовый квест? Опять же, потому что графики требуется по минимуму. Художников не было, никаких бирж фриланса еще не существовало (а то, подозреваю, я бы еще и вложился), и только один 3D-моделлер был найден на gamedev.ru каким-то чудом. Он сделал коротенький intro при начале новой игры. За что ему отдельное спасибо! И так, некоторый бэкграунд создания игры я обозначил. Поехали дальше! Выбор языка и платформы На момент начала изучения мной GameDev'а, стандартом в нём был C++. А для C++ IDE — MS Visual Studio. Его я и стал изучать и использовать. Для работы с графикой и медиа — MS DirectX, и его части DirectDraw и DirectSound. С 3D у меня с самого начала не задалось, да и в данном проекте он был совсем не к месту. Но и сам по себе DirectX не столь удобная штука, потому я нашел библиотечку NukeDX, которая позволяла работать с DX гораздо удобнее (читайте, это как libGDX сейчас для Java). Правда, NukeDX уже на момент начала работы с ним приказал долго жить. Но всё, что я хотел — в нём уже было и работало. То, что игра будет для настольного ПК на Windows – на тот момент не вызывало никаких сомнений. Ноутбуки стоили гораздо дороже ПК, а о планшетах можно было только почитать в заумных обзорах. Android и смартфоны были только в зародыше, в секретных подвалах лабораторий. А Linux воспринимался исключительно как консольное серверное решение. Хотя не скрою, году так в 2010-м появилась мыслишка «а не запихнуть ли под Windows Pocket всё это дело»? С названием операционки могу наврать, но суть понятна, думаю. Идея как появилась, так и пропала — пришлось бы переписывать весь код и переделывать графику. И о скриптах замолвим слово Поскольку я делал текстовую Role-Playing Game, которая изначально подразумевает нелинейность прохождения (о, это была модная штука тогда!), то надо было как-то заложить возможность манипуляции игровыми данными без перекомпиляции проекта каждый раз. Да и в целом, было крайне интересно попробовать самому прикрутить скриптовый движок к игре. Скриптовый движок должен был решать следующие задачи: взаимодействие с переменными игры (получение / модификация) и функциями; не требовать предварительной компиляции кода; не нагружать игру. Из всех удовлетворяющих данным требованиям выбор пал на Lua. Почему конкретно он — сейчас уже не вспомню. Язык точно использовался уже в крупных проектах. Да и сейчас используется (насколько я в курсе, в том же WoW, например). Библиотека свободно распространяемая, примеры были. И я Lua прикрутил. Набираем воздуха в лёгкие и задерживаем дыхание перед прыжком Всё замечательно, с платформой и инструментарием я определился. Теперь надо подумать, как идею превратить в нечто осязаемое. Поскольку на тот момент я уже делал какие-то простенькие программки с помощью Microsoft Foundation Classes, то с их же помощью решил написать и сценарный редактор для игры. Рассудив, что игра состоит из последовательности сцен (в нашем случае описываемых текстом), а переход на следующую сцену зависит от выбора варианта ответа, то я создал следующую структуру сценария: Как видно на скриншоте, в сцене присутствует, помимо текста описания и вариантов выбора, еще и много других данных. Например, текущая дата (по игровому времени). И смотря на это сейчас, я уже вижу, что следует исправить. Помимо времени, мы еще отображаем картинку сцены. В редакторе она задаётся номером. А в игре отображается в левом верхнем углу. И спрайт, как вы уже догадались, соответствует данному номеру. Так же есть название сцены (Location). Воспроизводимый для сцены музыкальный файл. И варианты действий со ссылками на соответствующую сцену. И вот здесь немного поговорим об интерактивности. Думаю, внимательные читатели заметили поле Event, в котором что-то вписано. Всё верно, это скрипт, выполняемый при переходе на данный экран. На первом экране это всего лишь добавление в журнал игрока новых задач: AddQuest(1, \"Вспомнить собственное имя, или, хотя бы кличку\"); AddQuest(1, \"Найти доктора\"); С точки зрения программы мы вызываем в Lua доступные ей функции приложения с теми параметрами, которые нам нужны. А теперь еще два момента: 1) У каждого варианта ответа есть поле Condition. Через тот же Lua мы можем проверить какие-то игровые переменные, и на основе этой проверки либо выводить вариант ответа, либо его скрыть. 2) Каждый вариант ответа может иметь свой выполняемый скрипт. То есть, если мы выбираем какой-то вариант, то он может повлечь за собой определённое действие. Например, вызов экрана боя. Или проигрывание звука. Или переход на какой-то конкретный экран, если выполняется условие. И т.п. Вот такими нехитрыми способами я решал вопрос интерактивности и взаимодействия пользователя с миром игры. А хранится всё в файле scenario.dat, в структуре данных. Сохраняется на диск с помощью механизма сериализации того же MFC. Ну и прикола ради, во время сохранения кодируется. Ныряем Хорошо, не очень удобный, но хоть как-то работающий редактор сценариев я сделал. Теперь пора запустить игру. И вот тут… Да как бы не так! Тут было много муторной работы в Photoshop с выцепленной графикой. Но с точки зрения программирования ничего особо сложного не было. На первый взгляд. Не буду погружаться в излишние детали, но первая серьёзная задача, которая передо мной возникла — это искусственный интеллект. Если для логических задачек всё можно было вынести в скрипты, то вот с боёвкой я решил закопать всё жестко в коде. И это был интересный, но времязатратный момент разработки игры. Конечно, великий рандом здесь рулит. Но надо было сделать хоть какое-то подобие осмысленности борьбы со стороны компьютера. А вот сама по себе модель боя была позаимствована от некогда крайне популярного «Бойцовского клуба», или просто БК. И адаптирована под Fallout. Выбираешь, куда бить, наносишь удар и получаешь аналогичный ответ. Но это ладно. А для прохождения некоторых заданий (квестов) требуется инвентарь. И вот здесь я реально встрял на месяцок — другой. Нет, сам по себе инвентарь — штука не сложная. Даже наоборот. Встрял я на написании drug&drop для него. Правда, сейчас я помню только, что он вызвал много неприличных слов! Когда поборол проблему с перетаскиванием предметов, то оставались лишь мелкие детали, вроде просмотра голодисков (holodisk), отображения журнала заданий и т.п. мелочи. Надо проверять дно, чтобы не встретиться с камнем Но… был уже 2008 год. Вышел и прошел с аншлагом Fallout 3 – эдакий The Elder Scrolls в мире Пустоши. Поколение геймеров давно сменилось, и те, на кого был рассчитан текстовый квест Fallout: The X-Project уже либо перестали играть совсем, либо потеряли всякий интерес к подобного рода играм. Но я ничуть не жалею о полученном опыте, ведь я доказал себе, да и всем остальным, следующие вещи: Можно написать программу не обладая изначально никакими знаниями в области программирования, и не обучаясь по данной специальности где-либо. Даже в одиночку можно создать компьютерную игру, за которую не будет стыдно (привет GameMaker'у и иже с ним). Разрабатывая игры, получаешь массу удовольствия! А еще на собственном опыте выяснил, что: У проекта обязан быть deadline! Перед тем, как что-то начинать делать, надо очень внимательно изучить, понадобится ли это кому-то, кроме тебя самого. Банальность, но это грабли, на которые все продолжают и продолжают наступать. Система контроля версий — это просто супер-вещь! ООП — это еще круче, чем система контроля версий. Читать большие тексты мало кто любит. Но уж если предстоит читать тексты, то надо делать чтение УДОБНЫМ! В моём случае стиль победил удобство, что оказалось большой ошибкой. Необходимо продумывать каналы распространения еще ДО начала работы над проектом. Найти соратников, которые будут не только трепаться языком, но и что-то делать вполне реально. Но не просто. Совмещать несколько позиций команды в одном человеке — не продуктивно. Постоянное переключение между задачами негативно сказывается на скорости работы. Создавать игру в рамках готового сеттинга (вселенной) проще, чем делать с 0. На этапе проектирования уже стоит убирать лишнее. Всё равно не войдёт в финальный релиз, но время съест. Так, например, в игре отсутствует перемещение между городами (карта мира), хотя изначально она предполагалась. Компьютерная игра — это сплав различных ингредиентов. Поэтому тут либо нужны все специалисты, либо ты должен уметь всё это делать сам. Рано или поздно упорство вознаграждается. Но чтобы это не было поздно, см. п.1 А еще этот волшебный момент, когда твоя игра компилируется без ошибок, запускается, и в ней всё именно так, как ты и задумывал. Это волшебство, ради которого стоит тратить свои усилия! Хозяйке на заметку Приводить список литературы не стану, т. к. он уже давно не актуален. → А вот поковырять исходные коды, при желании, можно на Гитхабе → Сама игра, если любопытно", "image": ["https://habrastorage.org/files/4b6/924/27e/4b692427e8734240966e2a46926b960a.jpg", "https://habrastorage.org/files/3f0/2db/348/3f02db348b7c4719a5601d71da12debb.jpg", "https://habrastorage.org/files/39a/f0d/172/39af0d1725ac4af6ac8eba94316ac57c.jpg", "https://habrastorage.org/files/094/540/f47/094540f476974142af75070270aec411.jpg", "https://habrastorage.org/files/bab/425/192/bab42519249e450a97252d7f4d744a5d.jpg"], "tag": ["опыт разработки игры", "gamedev", "gamedevelopment", "gamedesign", "выводы"], "rating": ["+61"], "bookmarks": ["133"], "views": ["32,5k"], "comments_count": ["69"]},
{"author": ["habit"], "date": ["28 июля 2016 в 16:10"], "hubs": ["Тестирование игр", "Lua", "Блог компании ua-hosting.company"], "type_label": ["Перевод"], "text": "Представьте себе ситуацию: в игре персонаж, который представился членом одной из популярных и известных гильдий, подходит к Вам и обещает редкие крутые элементы, редких животных (на которых Вы можете путешествовать) оружие и т.п. Скорее всего такой перс не имеет ни редких элементов, ни специальных кодов для них. В итоге жертва не получает правильный код или какой-либо редкий предмет. Злоумышленник смог убедить ничего не подозревающего игрока ввести всего одну команду в диалоговом окне. /run RemoveExtraSpaces=RunScript Интерфейс WoW (например, строка меню, окно чата и другие 2D графические элементы) и также дополнения написаны на языке Lua. Обе стороны строки — RemoveExtraSpaces и также RunScript — легальные функции и часть WoW Lua API. Но введение этой строки кода в диалоговом окне изменяет поведение интерфейса WoW. Что делает эта команда на самом деле? /run — команда для интерпретации следующего текста как сценария Lua. RemoveExtraSpaces — встроенная функция, которая удаляет ненужные пробелы из текста. RunScript — функция, которая выполняет текст в качестве кода Lua (аналогично команде /run) Чем это опасно? Функция RemoveExtraSpaces вызывается каждый раз, когда игрок получает новое сообщение. Указанная выше команда /run заменяет функцию RemoveExtraSpaces на функцию RunScript, которая изначально существует в программном обеспечении. После того, как исходная функция переписывается, каждое новое сообщение чата интерпретируется как Lua код и сразу же выполняется. Сценарий выглядит следующим образом. Неосторожный игрок вводит в своем диалоговом окне вредоносную строку кода, потому что его убедили слова нападавшего. Но вместо того, чтобы получить редкие предметы, он становится жертвой. Ничего не подозревающий игрок собирается отправить вредоносную строку кода Злоумышленник отправляет сообщение в чате жертве Полученное сообщение интерпретируется как Lua код и затем выполняется То, что было показано выше, является довольно безвредным примером этой уязвимости, доказательства концепции. Но на самом деле — это означает, что злоумышленник теперь может удаленно контролировать интерфейс жертвы. Это очень похоже на поведение троянов, которые изображают из себя что-то полезное и затем выполняют свою вредоносную функцию. В реальном случае, вместо того, чтобы создавать сообщения с текстом «Test», злоумышленники запускает другой сценарий, пример которого будет приведен ниже. Временное скрытие и сохранение команды После того как жертва открыла бэкдор в свой интерфейс, злоумышленник отправляет следующее сообщение: Атакующий устанавливает новый канал передачи данных В случае, если команда была выполнена, сообщение, которое показано выше, не будет видно жертве, но будет выполнено немедленно. Тот факт, что функция чата больше не работает может показаться подозрительным и жертва, возможно, попробует перезапустить игру. Злоумышленник действует достаточно быстро, чтобы решить эту проблему. Отправив команду, показанную выше, которая устанавливает новый канал связи, они снова восстанавливают нормальную работу чата не вызывая подозрений. Для того, чтобы понять цель этой команды, нужно знать что в WoW есть возможность общаться с помощью скрытого канала (локально и удаленно). Этот канал установлен через использование событий “CHAT_MSG_ADDON”. Сценарий создает фрейм (строка 2), к которому можно установить различные свойства. Сценарий регистрирует события CHAT_MSG_ADDON с конкретным префиксом (строка 6 и 25). Только тот, кто знает выбранный префикс, может тайно управлять интерфейсом жертвы. Это все равно что пароль для бэкдор. Каждый раз, когда угнанный интерфейс получает CHAT_MSG_ADDON, событие с секретным префиксом, код будет выполняться тихо и без ведома жертвы. Вывод: пока злоумышленник не решит Вам показать, что происходит, Вы, к сожалению, про это не узнаете. Даже при том, что речь идет о дополнениях, которые могут связаться через скрытый канал, у жертвы не обязательно должны быть установлены дополнения, чтобы атаки прошла успешно. Какой вред может быть причинен? В виду того, что злоумышленник будет иметь полный доступ к интерфейсу жертвы, он может собрать полную информацию про него. Но взломщик не сможет собрать какую-либо подробную информацию о других игроках. В WoW игроки имеют возможность делится/продавать предметы друг другу. Если злоумышленник знает местонахождение персонажа жертвы и находится в пределах досягаемости, он может удаленно открыть окно торговли и передать себе золото, предметы и все, что можно передать. Практически ограбить жертву. Описанный сценарий демонстрирует социальную атаку на ряду с технической. Теперь хакер может с помощью жертвы отправлять убедительные сообщение ее друзьям, коллегам и другим игрокам, с которыми тесно общается персонаж, тем самым увеличивая количество захваченных персонажей. Как можно себя защитить? Ответ простой и очевидный: не нужно вводить такого рода команду или любую другую, которая будет предложена даже Вам давнишним другом. В данном примере мы говорили об атакующем персонаже в игре, кто принадлежал к популярной гильдии. Но по факту он не принадлежал к этой гильдии. Он выбрал известную гильдию и скопировал имя, заменив “L” на “I”. Возможно, Вы уже знакомы с такими методом фишинг-атак. Кроме того, будьте осторожны при загрузке дополнений используйте защищенные и популярные веб-сайты, сохраните свои дополнения, чтобы их можно было в любой момент заменить. Возможно, что некоторые из этих обновлений могут уже содержать вредоносный код. Подобная проблема была замечена в 2014, когда так называемый “ElvUI Backdoor” был обнаружен в одном из дополнений. Сам глюк может быть исправлено только Blizzard. Они должны убедиться, что перезапись такой функции будет невозможен в дальнейшем. Blizzard уже выпустили предварительный релиз для предстоящего дополнения «Legion». В данном дополнении они учли обсуждаемый тут сценарий и добавили предупреждение перед отправкой сообщения, которое содержит вредоносный характер. Выбор “Yes” отключает сообщение навсегда, даже перезапуск не вернет его – по этой причине вопрос нельзя считать решенным. Чтобы повторно активировать данное сообщение, нужно вручную удалить одну строку кода в конфиг-файле. Код, который должен быть удален:SET AllowDangerousScripts \"1\" Файл: config-cache.wtf Путь: World of Warcraft\\WTF\\Account\\\\", "image": ["https://habrastorage.org/files/557/543/f88/557543f887f24ca49432fbe431077546.png", "https://habrastorage.org/files/dea/5bc/4db/dea5bc4dbff84c17a761bee8eafcbd74.png", "https://habrastorage.org/files/ed6/b98/6fd/ed6b986fdce4421ea6dcb65b97cdc203.png", "https://habrastorage.org/files/700/dcb/74f/700dcb74f56746eba86a6c81e069d1ed.png", "https://habrastorage.org/files/2a1/7ed/75c/2a17ed75c18447b3b676c50bfe8fe65c.png", "https://habrastorage.org/files/033/8a8/abe/0338a8abeaf445908d297015a5457ce9.png", "https://habrastorage.org/files/790/991/026/79099102677348da80d8fca59b7fb489.png"], "tag": ["World of Warcraft", "бэкдор", "баги", "взлом", "игры", "Blizzard"], "rating": ["+67"], "bookmarks": ["63"], "views": ["72,4k"], "comments_count": ["42"]},
{"author": ["Wolf_Black"], "date": ["22 декабря 2016 в 21:02"], "hubs": ["Разработка игр", "Lua"], "type_label": [], "text": "ВажноЭтот туториал рассчитан на людей, у которых есть опыт программирования на Lua, если нет, то отправляйтесь исправлять ситуацию. Но он отлично подойдет и для тех, кто никогда не программировал на Lua. Что такое Corona SDK? Corona SDK — это кроссплатформенный игровой движок, использующий Lua для описания игровой логики. Позволяет экспортировать приложения под различные платформы, в том числе и мобильные. Возможность экспорта под такие платформы: Windows Mac OS iPhone/iPad Android tvOS Начнем! Регистрируемся на официальном сайте, скачиваем Corona SDK, с установкой проблем возникнуть не должно. После установки, запускаем ярлык «Corona Simulator», который должен появиться на рабочем столе. Откроется менеджер проектов и специальная консоль. Нажимаем «New project». Вводим название проекта, остальное оставляем, как есть, нажимаем на «OK». Должно открыться такое окно. И папка проекта в проводнике. Приступаем к программированию Я использую «Notepad++» для редактирования кода, но подойдет любой, другой текстовый редактор. Открываем файл «main.lua». После открытия, вы увидите, что-то вроде этого. Я буду использовать эти изображения, которые я нарисовал в программе «Graphics Gale». Нужно закинуть их в корень папки проекта. Игрок. Трава. Для начала, подключим физику, загрузим изображения и назначим координаты для игрока. local physics = require(\"physics\") physics.start() -- запускаем физику. player = display.newImage(\"player.png\") -- загружаем изображение. player.x = 100 player.y = 100 -- меняем координаты игрока. physics.addBody(player,\"dynamic\") -- включаем физику для игрока, \"dynamic\" объекты - действуют за законами гравитации. Нажимаем Ctrl + S, если вы все сделали правильно, игрок начнет падать вниз. Добавим землю grass_block={} -- массив блоков for i=0,5 do grass_block[i]=display.newImage(\"grass.png\") grass_block[i].x=grass_block[i].x+i*64 grass_block[i].y=player.y+100 physics.addBody(grass_block[i],\"static\") -- \"static\" объекты - игнорируют гравитацию. end Результат: Заключение Вот такой вот получился краткий урок. В следующем уроке, я расскажу, как сделать управление игроком, добавлю фон, и расскажу тонкости настроек для мобильных платформ.", "image": ["https://habrastorage.org/files/c03/dd2/f6c/c03dd2f6caac4713993bb4fa5ac85a5d.png", "https://habrastorage.org/files/c5e/8fb/3f5/c5e8fb3f5ba34e52af44715afbbf5b13.jpg", "https://habrastorage.org/files/79a/5fb/1db/79a5fb1db96b47de839b595cb8d07033.jpg", "https://habrastorage.org/files/4e2/8b0/a7d/4e28b0a7d91c4422baa93b0250d8a901.jpg", "https://habrastorage.org/files/539/64c/81e/53964c81e27a422da8607a8fcc977fe3.jpg", "https://habrastorage.org/files/729/b93/784/729b93784423451da294256ec03a033c.jpg", "https://habrastorage.org/files/219/76f/682/21976f6820794c568dd6cbf78ec32c87.png", "https://habrastorage.org/files/921/7a0/be1/9217a0be1a6d4c90bb9802542cff32f3.png", "https://habrastorage.org/files/dd8/b78/cc0/dd8b78cc0a76432abf25ed423df41f31.jpg", "https://habrastorage.org/files/ad6/06c/ee4/ad606cee4aa246c29994cfae2746e63f.jpg"], "tag": ["lua", "corona sdk", "gamedev"], "rating": ["+22"], "bookmarks": ["45"], "views": ["6,7k"], "comments_count": ["12"]},
{"author": ["Ovoshlook"], "date": ["28 декабря 2016 в 11:41"], "hubs": ["Lua", "Asterisk"], "type_label": [], "text": "В Asterisk 2 типа трансферов: — слепой: после набора нужного сотрудника переводящий сразу отваливается. — расширенный: возможность поговорить с тем, кому перевод предназначен, принять callback. Мне понадобилось совместить простоту первого и функционал второго. Без AMI/ARI/AGI. Без костылей. Велосипед под катом. Сразу оговорюсь почему не использовал интерфейсы, которые уже есть: это не очень удобная штука, когда речь заходит о стеке Asterisk, например (да и вообще не люблю я их). Но это так. Лирическое отступление. Поехали далее. Указатели (расшифровки, или как там еще можно сказать. Для простоты короче): Переводящий — тот кто переводит Принимающий — тот кто принимает перевод Сценарий: проверить, а доступен ли вообще оператор которому должен прийти перевод звонка. Если недоступен — проиграть переводящему сообщение об этом и вернуть назад звонок если оператор доступен, положить трубку переводящему и отправить звонок на принимающего если принимающий занят (разговаривает например), предложить пользователю подождать или вернуться к переводящему если принимающий не отвечает, вернуться к переводящему* Инструменты Asterisk, которые мне понадобились: features.conf. С него и начну. Так как у меня появляется собственное событие, которое должно быть произведено по нажатию на определенную клавишу (DTMF) во время разговора, то тут самое место использовать features.conf с его возможностью создавать свои события и определять на них свои действия Мое событие называется customTransfer и выглядит так (описание того как создаются кастомные события есть в features.conf и на wiki.asterisk.org. Не буду расписывать): customTransfer => #,self,GoSub(customTransfer,#,1),default То есть по нажатию на # вызываем GoSub и уходим в контекст диалплана. Тут оговорюсь что использую lua, поэтому далее буду писать функции которые вызываю Для тех кто не знает, то в lua контекст определяется в таблице extenions и может указывать на функцию которую надо выполнять: extensons={ [\"customTransfer\"]={ [\"#\"]=customTransfer --название функции } } Функция выглядит так ( Комменты описывают, что к чему и рекомендованы к прочтению для понимания) function customTransfer(context,extension) --[[ считываю номер, на который делается перевод ]] app.Read(\"TRANSF\",nil,10,nil,1,5) if channel.READSTATUS:get() == \"OK\" then -- [[ Проверяю доступен ли абонент, на которого я делаю перевод. я использую другой сервер регистрации, но при использовании именно Asterisk как сервера регистрации наличие пользователя можно проверить так.]] app.chanIsAvail('SIP/'..chan.TRANSF:get()) if channel.AVAILCHAN:get()~='' then --[[ запоминаю кто сделал перевод (переменную канала CALLED_NUMBER я создал когда принимал входящий звонок (здесь ее нет). В ней лежит номер, на который поступил звонок (то есть перевод работает с тем кто принял звонок, а не с тем кто его инициировал)). Кладу во внутренюю БД Asterisk (можно redis, можно вообще все что угодно). Делаю это потому, что ChannelRedirect создаст новый канал, и уже не увидит переменных, созданных в этом канале. ]] channel.DB('transferedBy/'..channel.BRIDGEPEER:get()):set(channel.CALLED_NUMBER:get()) -- [[перевожу на новый канал, который уже в свою очередь обработает соединение и отправит в нужный контекст, который в свою очередь вызовет необходимую точку. То есть, по сути я имитирую сценарий создаваемый функцией трансфер (кэп тут)]] app.ChannelRedirect(channel.BRIDGEPEER:get(),'redirectSetup',channel.TRANSF:get(),1) --[[ закрываю канал того, кто переводил, так как он мне уже не нужен (автоматически кладу трубку)]] app.Hangup() else --[[ если считать номер не удалось, информирую об этом ПЕРЕВОДЯЩЕГО и соединяю переводящего и ожидающего пользователя. Переводящий может попробовать перевести еще раз]] app.NoOp(\"user unavailible\") app.Playback(channel.UNAVAILIBLEONTRANSFER:get()) end else --[[ если пользователь недоступен, проигрываю сообщение ПЕРЕВОДЯЩЕМУ и соединяю переводящего и ожидающего пользователя. Переводящий может попробовать перевести еще раз]] app.NoOp(\"user unavailible\") app.Playback(channel.UNAVAILIBLEONTRANSFER:get()) end end После того как канал был брошен в transfer и была выполнена проверка, его необходимо направить на принимающего пользователя. В контексте 'redirectSetup' настраивается вход в данную функцию (аналогично предыдущему) Сама функция выглядит следующим образом function redirectSetup(context,extension) app.NoOp(\"trying to redirect to \"..extension) --[[ Эта переменная канала мне понадобится чтобы отправить звонок обратно, если принимающий пользователь не возьмет трубку, например или будет занят. Я храню ее в переменной канала так как в моем случае она путешествует по функциям диалплана и в общем то переменные канала это удобный способ хранить глобальные для канала переменные. В общем то ничто не мешает сохранить ее в переменной lua]] channel.__TRANSFEREDBY:set(channel.DB('transferedBy/'..channel.CHANNEL:get()):get()) --[[ В базе данных эта переменная больше не понадобится, поэтому мы можно ее удалить ]] channel.DB_DELETE('transferedBy/'..channel.CHANNEL:get()):get() --[[ Далее я отправляю вызов в основную функцию моего диалплана для обработки соединения, вместо нее вполне может быть просто app.Dial на необходимый extension ]] main(context,extension) end последний шаг — это организация возврата звонка при неответе/занятости абонента или по какой либо еще причине. Я думаю уже многие поняли что делать это нужно с помощью переменной TRANSFEREDBY Свой диалплан полностью выкладывать не буду. Приведу пример маленькой функции, чтобы не вводить в заблуждение — назову ее main. function main(context,extension) app.Dial(\"SIP/\"..extension) if channel.DIALSTATUS:get()~=\"ANSWER\" then app.Playback(\"olala\") app.Dial(\"SIP/\"..channel.TRANSFEREDBY:get()) end end Касательно возможностей данной организации: у меня диалплан в купе с данной функцией организован таким образом, что проверяет не только доступность локального номера, но и наличие мобильного номера, закрепленного за абонентом. Если абонент занят, предлагает ему оставаться на линии дожидаясь ответа или выйти из режима ожидания и перезвонить обратно тому, кто перевел (некий микс очереди и IVR), предлагает абоненту вернуться к тому кто перевел, если звонок на сотовый отправил на голосовую почту (у многих операторов данная услуга ничем не отличается от поднятой трубки. Они просто шлют 200 ответ и потом несут ересь...). последнее организовано тоже через customFeature. В общем-то все это достигается путем линейного программирования и включения головы. Вроде все. С наступающим тоагисчи Адекватных клиентов, и хороших исполнителей вам.", "image": [], "tag": ["asterisk", "voip", "lua", "программирование", "ip-pbx", "ip-атс", "велосипед"], "rating": ["+11"], "bookmarks": ["58"], "views": ["5,9k"], "comments_count": ["2"]},
{"author": ["olegbunin"], "date": ["22 сентября 2016 в 13:54"], "hubs": ["Высокая производительность", "NoSQL", "Lua", "Блог компании Конференции Олега Бунина (Онтико)"], "type_label": [], "text": "Аникин Денис ( danikin, Mail.Ru) Сегодня я расскажу, как сэкономить на базах данных огромные деньги, например, миллион долларов, как это сделали мы. Для начала вопрос: почему чаще используют именно базы данных, а не файлики? Базы данных – это хранилище, более структурированное, чем файл, и обладающее рядом некоторых фич, которых у файла нет. Там можно делать запросы, там есть транзакции, индексирование, таблицы, устойчивые, более-менее надежные хранилища. На самом деле, базы данных – это более удобно, чем файлы. Представьте, у вас есть приложение, оно работает с базой данных, оно нагружает эту базу данных пока только на чтение, т.е. там не очень большое количество записей, но большое количество селектов. В конечном итоге, у вас база данных перегружается и не может справляться с нагрузкой. Что обычно в таких случаях делают? Еще один сервер. Это репликация. Т.е., по сути, вы доставляете реплики ровно в таком количестве, чтобы они держали вашу нагрузку. Вы всю нагрузку на чтение уводите на реплики. Соответственно, нагрузку на запись вы оставляете на мастере. Эта схема может, в принципе, масштабировать нагрузку на чтение практически до бесконечности. Дальше у нас происходит нагрузка на запись. И нагрузка на запись, опять же, достигает какого-то предела, когда база данных уже не может ее держать. Поможет в данном случае репликация? Нет. Какая бы не была репликация – мастер-слейв или мастер-мастер – она не поможет нагрузке на записи, потому что каждая запись должна пройти на все сервера. Даже если там мастер-мастер, значит, сколько у вас идет суммарно запросов на весь ваш кластер, ровно столько же пойдет на каждый из серверов, т.е. вы этим ничего не выиграете. Какие есть еще идеи? Шардинг. На самом деле, шардингом можно решить проблему нагрузки на запись и масштабировать почти до бесконечности. Есть много разных способов шардинга – можно резать по базам данных, можно резать по таблицам, можно резать внутри одной таблицы. Способов – миллион. Каждый использует тот способ, который ему удобней. По сути, у вас получается такой двухмерный кластер из баз данных, т.е. у вас много-много шардов и у каждого несколько реплик. Вы доставляете шарды, реплики, и варьируете совершенно любую нагрузку. Но дальше у вас происходит проблема. Ваша следующая проблема – это ваш босс. Что ему в этом может не нравиться? Вроде как, все работает, все шардируется, реплицируется, но что ему не нравится? Деньги. Ему все нравится, кроме того, что это стоит очень дорого, потому что вы доставляете, доставляете, доставляете сервера, и он за это платит. Вы ему говорите: «Чувак, ты не понимаешь, у меня тут технология, у меня тут шардинг, репликация… Оно масштабируется бесконечно – это очень крутая система». Он вам говорит: «Да-да, но мы теряем деньги, если так пойдет дальше, у нас просто не будет денег, чтобы покупать сервера баз данных. Нам придется закрыться». Что же делать? На самом деле, нагрузка на базу данных часто бывает устроена так, что какие-то элементы данных на чтение нагружаются очень-очень сильно – они называются «горячие данные». Кэширование – это то, что частично решает нашу проблему. Вы можете убрать часть реплик и таким образом чуть-чуть удовлетворить вашего босса. Кстати говоря, вы получаете и лучший лейтенси, т.е. запросы отрабатывают быстрее, потому что кэш работает быстрее, чем базы данных. Но… какая есть проблема? Проблема несогласованности – одна из самых больших проблем, которая есть с кэшем. Это самая первая проблема, которая тут же видна. Смотрите, у вас приложение отдельно пишет в кэш, например, в Memcached и отдельно пишет в базу. Т.е. кэш не является репликой базы, кэш является отдельной сущностью. Тут нарисованы стрелочки между кэшем и базой, которые на самом деле виртуальны, т.е. никакой репликации между ними нет. Все делается на уровне приложения. Соответственно, это приводит к несогласованности данных. И, кстати, у вас все еще остается шардинг, потому что кэш записи не оптимизирует, потому что в кэше нельзя ничего хранить, через него все пролетает насквозь в базу данных. Ну, не насквозь, а сбоку от него, но пролетает. Тут картинка, чтоб показать вам, что вы можете писать сначала в базу, потом в кэш, или сначала в кэш, потом в базу. В обоих случаях у вас будет несогласованность. Смотрите: вы пишете данные в кэш, после этого ваше приложение благополучно падает и в базу их записать не успевает. Приложение поднимается и работает с теми данными, которые уже в кэше, а в базе данных их нет, но никто про это не знает. Когда кэш перезагружается (а он когда-нибудь перезагружается), вы получаете из базы данных при пустом кэше устаревшие данные. Как ни странно, если писать в обратном порядке – сначала в базу, потом в кэш, будет ровно такая же проблема: записали в базу, приложение упало, в кэше старые данные, все работает со старыми данными, кэш перезагрузился, потянул из базы новые данные, как бы другую ветку данных, которые не целостные, которые не соответствуют тем изменениям, которые были сделаны поверх другой копии… Т.е. с кэшем есть как минимум две проблемы: нет целостности данных, и вам все еще нужен шардинг. Какие есть еще проблемы с кэшем? Какие вы кэшем внесли проблемы в тот момент, когда ваш босс начал сердиться? Проблема такая: кэш – это не база данных. У вас до кэша была база данных, там были запросы, транзакции, и все эти штуки из кэша почти все пропадают, у вас приложение работает уже с кэшем. Индексы и таблицы остаются, не во всех кэшах есть вторичные индексы, не во всех кэшах есть таблицы, но как-то криво-косо поверх key-value и то и другое можно поддержать, поэтому мы считаем, что эти свойства соблюдены, а остального всего нет. Теперь по поводу проблемы нецелостности данных. Что с ней сделать? Как сделать так, чтобы данные обновлялись и в кэше и в базе целостно? Умный кэш. Что такое умный кэш? На самом деле, многие из вас, скорее всего, это делают – это, по сути, кэш, который сам общается с базой данных. Т.е. это не отдельный демон Memcached, а какой-то ваш самописный демон, который внутри себя все кэширует и сам пишет в базу. Приложение в базу не пишет, оно работает полностью через кэш. Это решает проблему нецелостности, потому что кэш сначала пишет в базу, а потом пишет в себя. Если он в базу не записал, отдал ошибку – все хорошо. Это конечно не хорошо, но данные целостные. После того, как кэш записал в базу, он в себя запишет данные обязательно, потому что он пишет в память, такого, чтобы данные не записались в память практически никогда не бывает. Вернее, бывает, когда на сервере бьется память и в этот момент все падает, и все равно вы теряете весь кэш, по крайней мере, целостность данных не теряется. Но есть один кейс, когда даже при таком умном кэше данные можно потерять. Приложение пишет в кэш, кэш пишет в базу, база внутри себя применяет эту запись, дальше она отдает ответ кэшу, и в этот момент рвется сеть. Кэш считает, что запись в базу не прошла, в себя данные не пишет, отдает пользователю ошибку. После этого кэш начинает работать с теми данными, которые есть в нем, а после его перезагрузки он подцепляет из базы данных опять устаревшие данные. Это редкий кейс, но такое тоже бывает. Т.е. умный кэш не решает до конца проблему нецелостности данных. И вам все еще нужен шардинг. Шардинг – это когда у вас есть база данных, которая на одном сервере, и вы ее просто режете. Вы ее режете на кусочки и эти кусочки укладываете по разным серверам, физическим серверам. Это уменьшает нагрузку на запись, потому что нагрузка на запись идет на конкретный кусочек. Т.е. у вас, по сути, все CPU, например, всех серверов участвуют в обработке этой нагрузки, а не CPU только одного сервера. Шардинг у вас все равно остается, а вы помните, что ваш босс не любит шардинг, потому что это очень дорого, потому что много-много серверов и у каждого еще реплики. Итак, нецелостность данных, к сожалению, остается с кэшем, шардинг все еще нужен, свойств баз данных нет. Какая еще очень неприятная проблема с кэшем есть? Холодный старт. Это супер неприятная проблема, когда кэш поднимается с нуля, чистый, голый, без данных… Он бесполезен, также как машина, полностью заваленная снегом – в нее вначале нужно залезть, а еще ее нужно завести. Холодный старт полностью убивает кэш, все запросы напрямую летят в базу данных. Приходится делать действие, которое, опять же, ваш босс не одобряет, но что поделаешь? Приходится доставлять реплики только для того, чтобы прогреть кэш. На самом деле, этот слой реплик – для каждого вашего шарда вы доставляете по реплике – только для того, чтобы прогреть кэш. Вы не можете эти сервера отключить или выкинуть, когда кэш прогрет, потому что вдруг сервер с кэшем перезагрузится ночью? Все равно все должно работать ночью, эти сервера должны тут же пойти в нагрузку и обеспечивать прогрев кэша. Кэш прогрелся, и они уже не нужны, но опять их никуда не деть. Четыре проблемы с кэшем: Вопрос: как прогреть кэш? Кэш всегда должен быть прогрет, чтобы он имел смысл. Через базу данных его прогревать как-то не аккуратненько, потому что много-много реплик, и они все его греют-греют – слишком дорого они его греют. Персистенс – правильное слово. Кэш лучше просто не охлаждать, его нужно персистить, потому что кэш – хорошее и быстрое решение, за исключением нескольких проблем, включая проблему холодного старта, включая то, что он иногда недогрет, так пусть он будет всегда согрет. Как, например, в Сибири некоторые люди не глушат машины, чтобы они были всегда заведенные, потому что иначе ты ее потом не заведешь – примерно из той же оперы. Какой самый простой способ персистента для кэша? Это просто dump данных. Т.е., на самом деле, мы каждый раз, может быть, в минуту, или, например, раз в 5 минут дампим весь кэш полностью на диск, прямо целиком. Как вам это решение? Отстой, потому что теряется консистентность. Вы раз в 5 минут дампите, у вас как бы сервер поднимается, и он теряет свое изменение за 5 минут. Через базу данных их прогревать нельзя, и даже непонятно, откуда эти изменения взять. И это не единственная проблема. Вторая проблема – это то, что по IOPS’ам будет плохо, т.е. постоянно будете нагружать диск. Дампами, дампами и еще раз дампами, постоянными. Чем вы хотите иметь более целостные данные, тем чаще будете дампить. Какой-то не очень приятный путь. Как лучше персистить кэш? Лог. Нужно просто вести лог. Т.е. зачем нам дампить, давайте вести лог, давайте каждое изменение кэша будет логироваться на диск, каждое. Если вы думаете, что это медленно (всегда есть мнение, что кэш – это что-то такое быстрое, а когда там появляется диск, то это становится как-то медленно), так вот, на самом деле, это не медленно, потому что даже самый обычный крутящийся магнитный диск, не SSD, пишет со скоростью 100 Мб/с, последовательно пишет. Если размер транзакции, скажем, 100 байт, то это 1 млн транзакций в секунду. Это неимоверная скорость, которая удовлетворит почти всех присутствующих в этой аудитории, может быть даже меня. Поэтому даже один диск с этой задачей вполне справляется, но есть другая проблема, что этот лог разрастается очень сильно, потому что, например, идет 10 инсертов, потом 10 делитов тех же самых данных, они должны все схлопнуться, а в логе они не схлопываются. Или идет 100 апдейтов одного и того же элемента данных, опять же нужен только последний, а в логе хранятся все. Как эту проблему решить? Сшепшоты делать. Нужно соединить два этих метода – Dump и Log воедино. Т.е. мы раз в неделю дампим, или когда нам этого хочется, а все остальное время только пишем лог. В дамп мы еще запоминаем id последней примененной записи из лога или последней записи из лога, которая в этом снепшоте еще есть. И когда у нас сервер перезагружается, мы поднимаем с диска dump, восстанавливаем его в памяти и сверху накатываем тот кусок лога, который после этой записи. Все, кэш восстановлен и прогрет сразу. Кстати, этот прогрев происходит быстрее, чем из базы данных. Вот такого рода прогрев при перезагрузке потом полностью попадет в диск, потому что это линейное чтение файла – 100 Мб/с. Даже на магнитных дисках это очень быстро. Все, проблема холодного старта решена, но это только одна проблема, к сожалению. Хотя кэш прогрет, есть еще 3 проблемы. Давайте подумаем, как решить первые две – проблемы неконсистентности и шардинга? Идея использовать кэш как базу данных – это очень правильное направление. Действительно, зачем нам в этом месте наша основная база данных? MySQL или Oracle – зачем она нам нужна? Давайте подумаем. Нужна, наверное, для 2-х вещей: мы считаем, что база данных надежно хранит данные, не как кэш, а надежно, т.е. там, наверное, есть какая-то магия; то, что в базе данных есть репликация. У кэшей обычно репликации нет. Соответственно, кэш сервера вышел из строя или просто перезагрузился, и пока он не поднимет все с диска, это быстрее, чем прогрев, но все равно будет down time – это тоже плохо, а репликации там нет. По первому пункту – надежное хранение. Если разобраться, то что хранит база данных? База данных хранит горячие и холодные данные – это по сути все, что она хранит. Горячие данные – это обычно маленькие-маленькие и очень-очень горячие, которым 10-100 тысяч RPS, а холодные данные – это такие большие и холодные, к ним очень мало обращений. Всегда получается так, что холодные данные большие, а горячие – маленькие. Это закон жизни. По сути, вы реплицируете и шардируете вашу базу данных в большом количестве копий только лишь для того, чтобы обрабатывать этот маленький кусочек горячих данных, потому что к остатку холодных данных нет большого количества запросов, он нормально себя чувствует. Но вы все это реплицируете только ради горячих данных. Зачем мы делаем все это копирование? Мы можем, наверное, копировать только горячие данные? Но и тут та же самая проблема – ведь нагрузка идет именно на горячие данные и поэтому, если вы будете реплицировать и шардировать только их, проблема никуда не исчезнет, вам нужно ровно столько же серверов, чтобы обработать всю эту огромную нагрузку. И ваш босс все еще злой, потому что у вас все еще есть шардинг. На самом деле, мы говорим, что базы данных надежно хранят данные, но наш кэш сейчас тоже надежно хранит данные, потому что у него есть транзакшн лог – файл, в который пишутся все изменения. Это не что иное, как лог транзакции, это то же самое, что есть у любой базы данных, это ровно то, за счет чего обеспечивается надежное хранение в любой базе данных, никакой магии, и у кэша есть то же самое. Репликации нет. Это, конечно, плохо, но давайте подумаем, почему кэш не может быть первичным источником данных? Потому что нет репликации? Хорошо, мы ее сделаем. Почему еще кэш не может быть первичным источником данных? Потому что он не обладает свойствами баз данных? Мы тоже можем это сделать, мы можем все эти свойства баз данных поддержать, и кэш будет ими обладать. Помните картинку «Кэш – это не база данных»? Кэш может быть базой данных. Он может всеми этими свойствами обладать. В кэше нужно держать только горячие данные, куда идет много-много обращений, потому что вы шардируете и реплицируете эти холодные данные вместе со всей базой только для того, чтобы обслужить горячие данные. Но если вы будете только горячие данные шардировать, это проблему не решит, потому что это все равно упирается в количество запросов на горячие данные, т.е кэш может быть базой данных. Собственно, что мы и сделали, и назвали эту базу данных Tarantool. Мы разработали специальную базу данных для горячих данных, которая является кэшем, но при этом у него есть персистенс, транзакции (такие же, как у взрослых баз данных), репликация, у него даже есть хранимые процедуры. Т.е. все основные свойства базы данных у Tarantool’а есть. И поэтому мы его используем как первичный источник для горячих данных. Мы эти данные не дублируем нигде. У нас Tarantool, у него есть реплика, эти данные бэкапятся, как и для любой базы данных, но они не дублируются нигде, ни в каких других базах данных. Это такой всегда горячий кэш с персистентом и со свойствами баз данных, т.е. он все эти проблемы решает. По сути, нам не нужны сейчас все эти сотни серверов с шардингом и с репликами, у нас просто наша задача разделилась, Мы просто используем правильный инструмент для правильной задачи, т.е. холодные данные хранятся в хранилище. Например, в SQL хранилищах, которые были созданы десятки лет назад именно для холодных данных, потому что тогда не было такого количества запросов в секунду на данные, никто про это не думал. А горячие данные хранятся в том хранилище, которые специально задизайнено для горячих данных в Tarantool. Тут, в принципе, на слайде все написано – наш путь, через который мы прошли, но факт в том, что для большинства задач были достаточны 2 инстанса всего Tarantool – один мастер, второй – реплика, потому что нагрузка, которая идет на одну из баз данных, на один инстанс, она, скорее всего, обеспечит всю вашу полосу нагрузки, которая шла раньше на весь ваш кластер SQL серверов. И еще тут один психологический момент – не очень хочется уходить из уютного мира баз данных в неуютный новый мир кэшей. В базе данных транзакции и т.д. Тогда, когда ваш босс злой, вы доставили кэш и как-то сразу стало неуютно. И как раз Tarantool возвращает этот уют, т.е. он, мало того, что решает проблемы неконсистанси и холодного старта. Он, как бы, возвращает вас в мир баз данных для горячих данных. Теперь кейс в почте Mail.ru. Кейс был такой: нам нужно было хранить профили пользователей. Профили пользователей – это такие маленькие кусочки информации – от 500 байт до 1 Кб на пользователя. Мы изначально стали для этого дела использовать MySQL. И стали дублировать всю нагрузку на профили, которые у нас до этого лежали в старом хранилище, на чтение и на запись на ферму из MySQL. Мы поставили ферму из 16-ти MySQL, все пошардили заранее и туда пустили нагрузку. И оказалось, что на 1/8 от всей нашей нагрузки эти 16 серверов уперлись в полки. В основном, они уперлись в полку по процессору. Мы пытались их тюнить так и сяк, но по факту, все, что мы достигли – это 16 серверов на 1/8 нагрузки, т.е. на весь кластер, на всю нагрузку потребовалось бы 128 MySQL серверов. Мы подумали, что это дороговато – это больше 1 млн. долларов. И мы просто поставили несколько серверов с Tarantool и туда пустили всю нагрузку. В тестовых целях, дублировали. И оказалось, что они без проблем ее тянут целиком. Даже одного сервера было достаточно. Поставили просто 4, потому что мастер, реплика + еще пара, на всякий случай. Мы обычно перезакладываемся всегда по нагрузке. Собственно, вот она экономия миллиона долларов – просто мы в 60 раз снизили количество серверов, которое нам нужно. При этом даже пользователю стало лучше, потому что кэши обычно работают с лучшим лэйтенси. У нас суммарно в облаке и почте больше 120 инстансов Tarantool, серверов прямо с Tarantool, которые используются для разных фич, для очень большого количества фич. Если бы мы все это хранили в MySQL или в любом другом SQL, то это были бы сотни миллионов долларов, просто, если экстраполировать имеющиеся цифры. Мораль моего всего выступления: нужно использовать правильный инструмент, для правильной работы, т.е. нужно использовать базы данных для холодных данных и кэши с персистентом, как Tarantool, для горячих данных. И сэкономить на этом 1 млн. долларов. Тут краткое Summary о том, что мы сделали. Мы шардировали, реплицировали, уперлись в деньги, стали кэшировать, потеряли консистенси и еще кое-что… Сделали персистент кэш, это не база данных, но он может быть базой данных, отделили горячие от холодных данных, холодные – в MySQL, горячие – в Tarantool, спасли 1 млн. долларов и, как бонус, получили лучший юзер експириенс, потому что все стало быстрее. Контакты » anikin@corp.mail.ru » danikin » Блог компании Mail.ru Этот доклад — расшифровка одного из лучших выступлений на конференции разработчиков высоконагруженных систем HighLoad++. Сейчас мы активно готовим конференцию 2016 года — в этом году HighLoad++ пройдёт в Сколково, 7 и 8 ноября. В этом году Денис подал заявку под названием \"Почему Tarantool такой оптимальный?\". Обещается срыв покровов :) Константин Осипов так прокомментировал этот доклад — «он такой быстрый, потому что ни делает НИЧЕГО!» :) Послушаем, поспорим! Весь Программный комитет HighLoad++ продолжает дружно рекомендовать платформу Tarantool. Это одна из замечательных наших (российских) разработок и, как минимум, заслуживает внимания. Также некоторые из этих материалов используются нами в обучающем онлайн-курсе по разработке высоконагруженных систем HighLoad.Guide — это цепочка специально подобранных писем, статей, материалов, видео. Уже сейчас в нашем учебнике более 30 уникальных материалов. Подключайтесь!", "image": ["https://habrastorage.org/getpro/habr/post_images/c16/2c8/293/c162c82937e82b6bbfcee6318da298cd.jpg", "https://habrastorage.org/getpro/habr/post_images/308/ab6/0df/308ab60df7fc8c989a2f29b83bbb3c38.png", "https://habrastorage.org/getpro/habr/post_images/b24/fd6/337/b24fd63373089599c83908e41a729257.png", "https://habrastorage.org/getpro/habr/post_images/9ef/5ab/2b1/9ef5ab2b11efe551ac1c34c1399746e2.png", "https://habrastorage.org/getpro/habr/post_images/5f7/b85/729/5f7b85729cf597981951c576f97641d7.png", "https://habrastorage.org/getpro/habr/post_images/3ee/0b8/bb3/3ee0b8bb3c2de496dbc3b6466637fb72.png", "https://habrastorage.org/getpro/habr/post_images/900/cb6/3ec/900cb63ecb24dcb23d4afacf8e3a9e25.png", "https://habrastorage.org/getpro/habr/post_images/98d/ef0/67e/98def067e0c220b632bcc10262a5346d.png", "https://habrastorage.org/getpro/habr/post_images/8d7/a3e/279/8d7a3e2797b839c5802028fdeb14f7b9.png", "https://habrastorage.org/getpro/habr/post_images/8c1/079/aab/8c1079aaba2ca3872f2a393e41d9f1a8.png", "https://habrastorage.org/getpro/habr/post_images/883/1fc/d74/8831fcd741959f6c2b9bc818701caa89.png", "https://habrastorage.org/getpro/habr/post_images/4b4/c1d/755/4b4c1d7555e58f082f93b9666863ce7c.png", "https://habrastorage.org/getpro/habr/post_images/481/0ca/962/4810ca962658e8ca85fcd673f1755a23.png", "https://habrastorage.org/getpro/habr/post_images/c80/c62/b7f/c80c62b7f816fe0b1fe41fdf9305ba86.png", "https://habrastorage.org/getpro/habr/post_images/31b/5af/305/31b5af3059b2d6c276e67d57574da5e2.png", "https://habrastorage.org/getpro/habr/post_images/d9f/727/d9a/d9f727d9a704c57c2e5b0a8a586bed84.png", "https://habrastorage.org/getpro/habr/post_images/113/de1/153/113de1153d268e519436bdc0b0131498.png", "https://habrastorage.org/getpro/habr/post_images/a50/85d/5af/a5085d5af3fac5ef4eb87a446aa30ef5.png", "https://habrastorage.org/getpro/habr/post_images/bc6/df5/6b3/bc6df56b3145f35810bd0f3bdb9d841a.png", "https://habrastorage.org/getpro/habr/post_images/822/051/942/8220519429025c9003a5b91f8fb3744e.png", "https://habrastorage.org/getpro/habr/post_images/565/a16/ec1/565a16ec1f79d24d0559f89705be8833.png", "https://habrastorage.org/getpro/habr/post_images/d7f/90f/9f7/d7f90f9f71c8f872b4d49e2556e985da.png", "https://habrastorage.org/getpro/habr/post_images/c9d/d80/02a/c9dd8002ac76a00ef032ef7f2847fd1e.png", "https://habrastorage.org/getpro/habr/post_images/a07/def/cf8/a07defcf84590b229002837b05339639.png", "https://habrastorage.org/getpro/habr/post_images/655/633/e10/655633e10f48e15b5b7521ffcdd228e1.png", "https://habrastorage.org/getpro/habr/post_images/dc7/c0a/976/dc7c0a976606a20873f5c9a13c85125b.png", "https://habrastorage.org/getpro/habr/post_images/d7a/5c4/9d1/d7a5c49d1739e52ffa63f4a5f8eb07d5.png", "https://habrastorage.org/getpro/habr/post_images/1ca/32f/d99/1ca32fd9978c63794d150cc6b98767c4.png", "https://habrastorage.org/getpro/habr/post_images/ffe/146/fbb/ffe146fbb36294e3b17d88be78c5aa11.png", "https://habrastorage.org/getpro/habr/post_images/0f1/994/f0f/0f1994f0f092636d865717a374a531d6.png", "https://habrastorage.org/getpro/habr/post_images/610/3b6/90c/6103b690c6c0e326d6a3968e337ef57b.png", "https://habrastorage.org/getpro/habr/post_images/7da/c0f/3ef/7dac0f3ef55e6135376115f56ccd7873.png", "https://habrastorage.org/getpro/habr/post_images/bf6/1a5/7a9/bf61a57a9200f4f188031a639853dd07.png", "https://habrastorage.org/getpro/habr/post_images/8d0/e91/60d/8d0e9160d5d6f0609b0b986aff0cdaa5.png", "https://habrastorage.org/getpro/habr/post_images/1c0/d49/4b4/1c0d494b4dbb2d72ca9168d91cf97dc5.png", "https://habrastorage.org/getpro/habr/post_images/18a/94a/96b/18a94a96b76db59ef4efa2b6e112153d.png", "https://habrastorage.org/getpro/habr/post_images/28b/e6d/bf0/28be6dbf088c54929fb56068bd6ebd10.png"], "tag": ["highload", "tarantool", "денис аникин"], "rating": ["+61"], "bookmarks": ["245"], "views": ["23,9k"], "comments_count": ["56"]},
{"author": ["vovkos"], "date": ["27 декабря 2016 в 15:13"], "hubs": ["Программирование", "Lua", "C++", "C"], "type_label": [], "text": "Под данным изречением-мемом, взятым с замечательной картинки Владимира Филонова, поставит свою подпись каждый человек, имеющий хотя бы отдалённое отношение к программированию. Весь вопрос, как? Как именно документировать-то? Нижележащий текст преследует несколько целей: Дать краткий обзор (читай — немного погундеть на тему) неудовлетворительного состояния инструментария, применимого к хтоническим чудовищам мира C/C++; Предложить своё альтернативное решение (бесплатно-без-СМС-и-регистрации — проект некоммерческий и выложен на GitHub под MIT-лицензией); Призвать сообщество пообщаться на тему и собрать идеи; Пригласить присоединиться к разработке проекта на GitHub. Сразу оговорюсь, что хотя проект создавался в первую очередь как альтернатива, а точнее, дополнение Doxygen для сишных и плюсовых API, архитектурно он в равной степени пригоден и для других языков. Это позволяет создавать порталы документации разноплановых библиотек — сами библиотеки могут быть написаны на разных языках, а в документации будет единство стиля во внешнем виде и поведении. Мотивация По большому счёту, подходов к документированию API и библиотек — плюсовых или нет — ровно два. Первый, это писать всё ручками. Даже неважно в чём — в Help & Manual, RoboHelp, Word или другом редакторе. Несмотря на то, что этот традиционный способ всем понятен и по-прежнему широко используется, я глубоко убеждён что он в корне неверен. Дело в том, что он порождает документацию, которая всё время местами нерелевантна и отстаёт от объекта документации. Поддержка согласованности между созданными раздельно, а зачастую ещё и разными людьми, документацией и постоянно эволюционирующим API библиотеки — не эволюционируют только умершие или замороженные продукты! — это колоссальная задача, лишь немногим более лёгкая написания первичной документации. Второй, \"правильный\" подход, состоит в том, чтобы генерировать документацию по исходникам автоматически. Специально обученный парсер пробегает по исходникам, вычленяет особым образом оформленные комментарии с документацией и строит структуру дерева публичных объявлений API. После этого генерируется документация в нужном формате — меня, как, полагаю, и большинство, в первую очередь интересует HTML и PDF. Основным преимуществом данного подхода является гарантированная когерентность объявлений в исходниках API и в конечной документации. Даже при полном отсутствии в исходниках содержательных комментариев с собственно \"документацией\", в конце мы будем иметь прекрасный снимок состояния API библиотеки, с возможностью \"попрыгать\" по объявлениям и описаниям типов, и т.д. Итак, с вашего позволения, я сконцентрируюсь на \"правильном\" подходе с автогенерацией. Какие варианты у нас имеются тут? Увы, для документации C/C++ на данный момент имеется и реально используется печально мало: Doxygen да QDoc. И с этими двумя тоже далеко не всё гладко. Doxygen — первый по-настоящему успешный проект по вытаскиванию комментариев из кода на плюсах и превращению оных в HTML-документацию с гиперссылками, картинками графов наследования, вызовов и т.д. В отличие от своего прямого родителя — первопроходца Doc++, так никогда и не получившего достаточного распространения, Doxygen сейчас — это де-факто стандарт документирования кода на C/C++. И всё это было бы замечательно, если бы не два \"но\": Стандартный генерируемый доксигеном HTML, как бы это помягче сказать… не обременён элегантностью. Конечно, тут есть место субъективизму. Я вполне допускаю, что в мире существуют не столь придирчивые люди, которых доксигеновский выхлоп полностью устраивает (рискну предположить, однако, что профессиональных дизайнеров среди них не окажется). Но даже если умолчальный доксигеновский HTML и устраивает кого-то с визуальной точки зрения (а серьёзно, есть такие, кому он и вправду нравится эстетически? напишите в комментариях!), очень часто хочется поменять и настроить что-то выходящее за рамки подкручивания CSS — например, упечь объявления в <pre> и расставить отступы и пробелы в соответствии с принятым в данной конкретной библиотеке coding-style. Это подводит нас ко второй, более фундаментальной проблеме Doxygen: Doxygen за свою долгую жизнь так и не отрастил настоящую, модульную настраиваемость. Да, есть Doxyfile с кучей переменных, есть возможность менять HTML шапки и CSS, но архитектурно — всё захардкожено в монолитное C++ ядро! Причём захардкожен как front-end, а именно, парсеры исходников, так и back-end — генераторы HTML, PDF, RTF и другого (среди которого, слава небесам, есть и XML). QDoc по умолчанию выдаёт гораздо, гораздо более симпатичный HTML, чем Doxygen. К сожалению, если требуется что-то не по умолчанию, то QDoc страдает всё той же врождённой деревянностью, что и Doxygen (растущей, понятно, из той же самой ж... захардкоженности и парсера, и генератора в монолитное плюсовое ядро). В дополнение к своей деревянности, QDoc, в отличие от Doxygen, имеет всего лишь один входной парсер — для QT-диалекта C++ (со всеми Q_OBJECT, Q_PROPERTY, foreach, и т.д. жёстко трактуемыми как ключевые слова). И при этом, — что уж совсем ни в какие ворота, — не умеет генерировать PDF! Альтернатива Предлагается заменить один инструмент конвейером. Вместо Doxygen -> (HTML, PDF, ...) … будем использовать следующий pipeline: Doxygen -> (XML) -> -> Некий-Мост -> (reStructuredText) -> -> Sphinx -> (HTML, PDF, ...) Что оставляем старого? Разработчики знают как и уже привыкли документировать C/C++ код с помощью Doxygen-комментариев: /*! \\brief This is a brief documentation for class Foo. This is a detailed documentation for class Foo. ... */ class Foo { // ... } Зачем изобретать новый синтаксис? Будем писать документацию так же, как и раньше! Doxygen умеет вытаскивать документацию из исходников и класть её вместе с деревом объявлений в XML базу данных. Прекрасно! Это будет нашим front-end. Ещё легче ответить на вопрос о том, что использовать в качестве back-end — конечно, Sphinx. Sphinx заслуженно получил колоссальное распространение как инструмент написания технической документации. Он выдаёт весьма вкусно выглядящий HTML с поддержкой полноценных тем (а не просто CSS!), умеет склеивать всё в одну HTML-простыню, генерировать документацию в PDF, EPUB и множестве других форматов — и всё это из коробки! Но что самое главное, он полностью настраиваем с помощью Python-скриптов, причём их можно применять как для тюнинга внешнего вида, так и для расширения входного языка (каковым для Sphinx является reStructuredText) — а именно, дописывать свои директивы и потом использовать их в документации. Осталось подружить Doxygen и Sphinx. Строим мост Замечу, что я не первый, кто пытался построить мост между Doxygen и Sphinx. Относительную известность приобрёл проект breathe, написанный на Python как расширение для Sphinx. В настоящий момент проект не слишком активно ковыряется отвёрточкой, и, увы, из коробки не пригоден для серьёзных задач. Архитектурно он устроен следующим образом: он парсит XML-выхлоп доксигена и создаёт узлы reStructuredText дерева в памяти напрямую. Я же решил пойти несколько другим путём. Doxyrest — так называется наш мост — парсит доксигеновские .xml файлы, а затем отдаёт распарсенный XML и набор файлов-шаблонов в шаблонизатор (string template engine, template processor). Шаблонизатор генерирует файлы с reStructuredText, и уже эти .rst файлы передаются в Sphinx-back-end для получения окончательной документации в заданном формате. Основная фишка — конечно же, использование шаблонизатора. Это позволяет полностью настраивать структуру документации: менять порядок и группировать документируемые объекты (классы/функции/свойства и т.д.), настраивать стиль объявлений (где и как использовать отступы, пробелы, переносы строк и т.д.), использовать логику произвольной сложности для включения или не включения данного конкретного объекта в документацию, и так далее — и всё это без перекомпиляции, просто правкой входных шаблонов! Но главное — подход с шаблонизатором позволяет применять Doxyrest для абсолютного большинства любых других языков, и в частности, разнообразных DSL — для которых никто и никогда не будет делать специализированных систем документации. Doxygen не умеет парсить ваш язык? Взяли компилятор языка, добавили туда генерацию Doxygen-подобного XML по уже имеющемуся AST, затем исправили шаблоны выходных .rst файлов — чтобы объявления в документации были с нужным синтаксисом, — и всё! Ваш язык теперь можно документировать с помощью Doxygen-комментариев и получать на выходе красивую Sphinx-документацию. В настоящий момент для шаблонизации используется язык Lua (просто потому что у меня уже была готовая и отлаженная библиотечка Lua string templates), но в теории ничто не мешает добавить поддержку и других языков шаблонизации. Выглядят и работают шаблоны как-то так: Title ===== %{ if false then } This text will be excluded.. %{ end -- if for i = 1, 3 do } * List item $i %{ end -- for } На выходе будем иметь: Title ===== * List item 1 * List item 2 * List item 3 Примеры использования Лучше один раз увидеть, чем сто раз услышать. Посему, вместо заключения я решил просто привести ссылки на результат работы Doxyrest в применении к различным языкам: Jancy Standard Library Reference (язык Jancy) Jancy C API Reference (язык C) IO Ninja API Reference (язык Jancy) AXL Library Reference (язык C++) Несмотря на незаконченность содержательной части документации по ссылкам выше (собственно описания классов, функций и т.д.), всего этого должно быть достаточно для демонстрации работоспособности метода. Страничка проекта на GitHub: http://github.com/vovkos/doxyrest Проект выложен под одной из самых нестрогих лицензий в мире — The MIT License. Смотрите, пробуйте, присоединяйтесь к разработке. А я с удовольствием отвечу на все вопросы в комментариях.", "image": ["https://habrastorage.org/files/11c/a6c/b46/11ca6cb46335472bb4ebe4a67512e884.png"], "tag": ["документация", "api", "c", "c++", "lua"], "rating": ["+13"], "bookmarks": ["67"], "views": ["9,9k"], "comments_count": ["42"]},
{"author": ["Migrator"], "date": ["20 мая 2016 в 15:08"], "hubs": ["Разработка для интернета вещей", "Программирование микроконтроллеров", "Lua"], "type_label": [], "text": "Все началось с того что я работаю в офисе, где как водится нет нормальной вентиляции. Зато есть много народу, кому-то все время жарко, другим постоянно дует. Для контроля качества воздуха в помещении знать температуру недостаточно. Даже с кондиционером часто бывает прохладно, но душно. Спертый воздух. Оказалось, на это больше всего влияет концентрация со2. Когда я узнал стоимость готовых приборов хотел от этой идеи отказаться. Но случайно увидел описание оптического датчика концентрации со2 MH-Z19. Цена конечно тоже не маленькая, но все-таки близко к разумным пределам. И руки давно чесались по паяльнику. В качестве контролера использовать решил ESP8266. Во первых дешево, во вторых что бы передавать информацию на компьютер, свой и любого желающего в комнате. После того как собрал и оттестировал первый вариант, с программой-монитором на компьютере, решил добавить экран. Во первых это красиво. Во вторых, во многих случаях удобно. Устройство построено на модуле ESP8266 NodeMcu Lua wi-fi. Для него была написана программа на скриптовом языке LUA. Прошивку для интерпретатора Lua под мое устройство сгенерил на on-line сервере nodemcu-build.com. Выбрал там только те модули, которые мне были необходимы для создания проекта. Дальше я взялся за сборку устройства. Подключил датчики температуры. ds18b20. Они работают по интерфейсу 1-wire: Затем собственно датчик углекислого газа MH-Z19. Он может использовать два интерфейса ШИМ и UART. Я решил сперва попробовать ШИМ, и в результате он меня удовлетворил по надежности и точности показаний. И подключил дисплей по шине ISP: Была написана вот такая программа под Windows. На Delphi XE8: Используемый мной контролер имеет встроенный модуль WIFI, который рассылает полученную с датчиков информации как UDP broadcast пакеты по всей сети офиса. И пользователи у которых стоит программа монитор, получают информацию о состоянии воздуха в помещении и предупреждения, если ситуация становится критической. А теперь собственно впечатления. Прибор оказался намного полезней и интереснее чем я ожидал. Во первых больше нет проблем с проветриванием, никто не возмущается, так как у всех выскакивает предупреждение и они довольно хорошо согласуются с личными ощущениями. Ну и просто наблюдения показали что в солнечный день уровень со2 значительно ниже чем в пасмурный и дождливый, утром загрязненность воздуха выше чем днем. С первого взгляда можно понять что делать, проветривать, если зашкаливает со2, или включить кондиционер, если повышенная температура. Датчик температуры на улице хорошо показывает получится ли охладить проветриванием, или только кондиционер. Стало очевидным и понятным, что творится в комнате и как в этом жить. Был случай когда решили проветрить, открыли окно, и тут же закрыли его, датчик буквально зашкалило, И дома прибор оказался очень полезным, особенно в детской комнате, тем более что за показаниями можно следить удаленно через WiFi. В результате все это выглядит примерно так: Тут ссылки на исходники и все что необходимо для повторения данной конструкцииUSB драйвер для Windows: www.silabs.com/products/mcu/Pages/USBtoUARTBridgeVCPDrivers.aspx Программа для прошивки ESP8266: github.com/nodemcu/nodemcu-flasher Прошивка MCU lua: drive.google.com/file/d/0B4KYGXb6-nxpOUdXdTFpcjlFZXM/view Тут можно взять скрипты lua: drive.google.com/file/d/0B4KYGXb6-nxpeGNNbGM0U2g2dEU/view ESPlorer для загрузки скриптов на esp8266 и отладки: esp8266.ru/esplorer/#download Windows приложение написано на Delphi XE8. Тут исходники: drive.google.com/file/d/0B4KYGXb6-nxpei1RUWhHVXV5aTQ/view Необходимы дополнительные компоненты: JEDI: wiki.delphi-jedi.org/index.php?title=JEDI_Code_Library sourceforge.net/projects/jvcl/files SDL Delphi Component Suite: www.lohninger.com/sdlindex.html Скомпилированная программа для windows: drive.google.com/file/d/0B4KYGXb6-nxpUmVXcElLektOQXM/view На моем сайте можно получить дополнительную информацию по этому прибору и более расширенной версии", "image": ["https://habrastorage.org/getpro/habr/post_images/852/c81/b8c/852c81b8c710e1056277f63284980f4a.jpg", "https://habrastorage.org/getpro/habr/post_images/c3e/7ea/7d8/c3e7ea7d88e9bc7aabc54a34187b45aa.jpg", "https://habrastorage.org/getpro/habr/post_images/85b/b7a/bdc/85bb7abdcc6d2b29db7ad10b7a2ea006.jpg", "https://habrastorage.org/getpro/habr/post_images/782/882/2ee/7828822ee53b1753bd502af765bf2843.jpg", "https://habrastorage.org/getpro/habr/post_images/3e4/0f8/2b4/3e40f82b443014e9fd03ff66c882b68c.jpg"], "tag": ["со2", "esp8266"], "rating": ["+28"], "bookmarks": ["249"], "views": ["29,9k"], "comments_count": ["25"]},
{"author": ["antirek"], "date": ["30 ноября 2015 в 11:50"], "hubs": ["Разработка систем связи", "Lua", "Asterisk"], "type_label": [], "text": "За последний год на Хабре появилось несколько статей про использование диалплана lua в asterisk (раз, два, три, четыре). Это достаточно интересный способ написания гибких и мощных диалпланов. Но чтобы попробовать такой способ написания диалпланов надо потратить некоторое количество времени: установить нужные библиотеки, пересобрать с необходимыми опциям астериск. Вдобавок у многих пользователей asterisk'а разный уровень подготовки: кто-то ближе к системному администрированию или даже к традиционной телефонии, чем к программированию. Плюс специфика телефонии — лучше лишний раз незнакомыми экспериментами не нагружать работающие системы, а проводить тесты и эксперименты на своем ноутбуке — приходится захламлять систему. В общем, есть немало причин «отложить на потом». В данной статье я хочу показать всем желающим и работающим с астериском, как, используя docker, можно быстро ощутить вкус гибких сценариев lua. А уж затем решить стоит этим пользоваться дальше на практике или нет. (Кому неинтересно читать, а интересно смотреть и слушать — в конце текста 6-минутное видео с основными моментами и результатом.) Вводное слово В рамках работы над несколькими своими проектами, следуя современной тенденции упаковки всего в контейнеры, я подготовил образ astolua (asterisk + lua). В Dockerfile приведены команды для установки asterisk 11, lua 5.1, luarocks (пакетный менеджер для lua), luamongo (драйвер для доступа к mongodb), некоторые пакеты lua rocks. Вы можете в дальнейшем в репозитории docker-astolua взять только полезное для себя и собрать свою рабочую лошадку. Безусловно плюсом докера является возможность скачать образ, провести пробы-эксперименты-тесты, а затем удалить образы, оставив свою операционную систему в чистоте и привычном порядке. На основе образа astolua мы создадим свой рабочий образ, в котором будем использовать тестовые файлы конфигурации астериска и диалплан на lua. Подготовка Нам потребуется docker. Если у вас он не установлен, то, пожалуйста, установите сначала docker (официальная документация, статья на Хабре). Также нам потребуется git (установка git) Также сразу отмечу, что моей рабочей системой является Ubuntu 14.04. Если вы используете иной Linux, то отличия в командах по идее быть не должно, но нюансы не исключены. Загрузка образа astolua Затягиваем образ (внимание, будет скачан образ с репозитория hub.docker.com размером ~600Мб). docker pull antirek/astolua Sample Клонируем docker-astolua-sample — это заранее заготовленный набор файлов для этой статьи. git clone https://github.com/antirek/docker-astolua-sample.git cd docker-astolua-sample Теперь давайте остановимся на sample и посмотрим содержимое директории. Файл Dockerfile Файл для сборки нашего рабочего образа. В нем мы указываем, что берем за основу astolua. Затем добавляем скрипт автозагрузки after_start.sh, который будет выполнен при старте контейнера. В консоль, где мы запустим контейнер, будт выводиться лог консоли астериска. Файл build Внутри файла команда докера на построение образа sample из нашего Dockerfile. docker build -t \"astolua:sample\" . Файл run Внутри файла команда докера на запуск контейнера на основе образа sample с конфигурированием необходимых ему ресурсов. docker run \\ -v /etc/localtime:/etc/localtime:ro \\ -v $(pwd)/store/etc/asterisk:/etc/asterisk \\ -v $(pwd)/store/var/log/asterisk:/var/log/asterisk \\ -v $(pwd)/store/var/menu:/var/menu/ \\ --net=host \\ -i -t \"astolua:sample\" Папка store Папка store содержит конфигурационные файлы астериска (те, которые обычно лежат в /etc/asterisk) и папки для логов и голосовых меню. Команда run наиболее интересна, т.к. здесь указываются необходимые ресурсы для контейнера. Например, опцией -v $(pwd)/store/etc/asterisk:/etc/asterisk мы указываем, что конфигурационные файлы из нашей папки store должны оказаться внутри контейнера на своем месте в /etc/asterisk. Почему команды в файлах? Удобно редактировать команды в файлах, т.к. это ускоряет время на протестировать изменения в командах с разными опциями, а также все изменения лягут под контроль версий. И еще удобно потом перенести опции в docker-compose, если образ будет использоваться совместно с другими. Вернемся к консоли. Сделаем образ astolua:sample (в директории, куда мы склонировали docker-astolua-sample) ./build Запускаем asterisk (если у вас уже запущен на машине астериск или иной сервис, занимающий порт 5060, то его лучше предварительно остановить) ./run В консоль должен повалиться лог загрузки астериска. Можно протестировать связь. В конфигурационном файле астериска sip.conf указаны два абонента 101 и 102 (пароль 1234), а в файле queues.conf очередь 1234, в которую добавлены эти два абонента. Настройте свой софтфон или хардфон на 101 абонента и попробуйте совершить звонок на абонента 102. (Транков для подключения к внешним voip-сервисам или настроек какого-либо железа нет, поэтому диалплан мы потестируем на локальных звонках). Информация о звонке между абонентами должна появиться в консоли астериска. Абоненты работают, звонки проходят? Ок, значит астериск в докер-контейнере работает как надо. Диалплан lua Диалплан lua находится в файле extensions.lua. В конфигурационных файлах астериска в папке store/etc/asterisk есть пример работающего диалплана lua. В этом файле должны быть правильно описаны переменные extensions и hints (в терминологии lua — это «таблицы»). В таблице extensions содержатся контексты и соответствующие extensions. Все как в традиционном диалплане. Но каждый extension обрабатывается своей функцией, в которой вы уже можете делать все, что угодно на lua, при этом взаимодействуя с астериском через таблицы app и channel. Самый простой пример extensions = { [\"internal\"] = { [\"_1XX\"] = function (context, extension) -- do something -- app.dial('SIP/'..extension); -- do something again end; } } Видно, что через app доступно приложение диалплана Dial, оно принимает все те же параметры, что и в традиционном диалплане. Через app доступны все приложения диалплана. Переменная channel дает доступ к канальным переменным. Вот так, например, получаем dialstatus. extensions = { [\"internal\"] = { [\"_1XX\"] = function (context, extension) -- do something -- app.dial('SIP/'..extension); local dialstatus = channel[\"DIALSTATUS\"]:get(); app.noop('dialstatus: '..dialstatus); end; } } Вы можете изменить extensions.lua, а затем командой в CLI астериска module reload pbx_lua.so перечитать extensions.lua. Астериск проверит синтаксис lua, и если все ок, то загрузит его для выполнения — можно тестировать изменения. А что еще можно делать в диалплане lua? Например, гибко обработать dialstatus, который будет возвращен функцией Dial диалплана. Не надо больше изобретать эти Goto(s-${DIALSTATUS},1), теперь можно по-человечески написать проверку статуса extensions = { [\"internal\"] = { [\"_1XX\"] = function (context, extension) app.dial('SIP/'..extension); local dialstatus = channel[\"DIALSTATUS\"]:get(); if dialstatus == 'BUSY' then -- do something elseif dialstatus == 'CHANUNAVAIL' then -- do another thing end; end; } } В примерe extensions.lua есть пример простого ivr: позвонив на номер 200, вы услышите запись из файла /var/menu/demo и сможете перейти дальше, нажав 1 или 2. local ivr = function (context, extension) app.read(\"IVR_CHOOSE\", \"/var/menu/demo\", 1, nil, 2, 3); local choose = channel[\"IVR_CHOOSE\"]:get(); if choose == '1' then app.queue('1234'); elseif choose == '2' then dial('internal', '101'); else app.hangup(); end; end; Для человека, написавшего пару десятков строк традиционного диалплана, здесь должно быть все знакомо. Плюс появляется вся мощь lua и пакетов luarocks. Надеюсь очевидно, что здесь же в диалплане вы можете отправить смс, емейл, положить данные в бд, взять данные из бд, а бд может быть любая: mysql, mongodb, redis и т.п., сделать вызов команды, инициировать еще один звонок, сделать крутой роутинг звонка по транкам и т.д., не забывая, конечно, что это все работает в рамках астериска, и все «тяжелые» задачи лучше все-таки решать отдельно. Что дальше? Предлагаю: посмотреть официальную документацию Asterisk и LUA — достаточно примеров и сравнений, чтобы разобраться с основами прочитать еще раз статьи на Хабре от Sayman_Nsk и ovoshlook: диалплан на lua, AMI в диалплане, обновление DEF-кодов, создание IVR посмотреть пример диалплана на lua от Игмара, где реализована большая часть функционала АТС: звонки абонентам, регистрация/отрегистрация операторов очередей, webhook'и при входящих звонках, маршрутизация в зависимости от дня недели и времени дня. «запилить» что-то свое: ) Надеюсь, данная статья будет полезна для быстрого старта, и вы найдете один свободный зимний вечер и попробуете такой способ написания диалпланов. Ошибки? Опечятки? Вопросы? Пожалуйста, пишите.", "image": ["https://habrastorage.org/files/2ca/668/2ea/2ca6682ead5b4f3cbd0a5eca2990e112.png"], "tag": ["asterisk", "docker", "lua", "dialplan", "telecom", "ivr", "свой маленький ламповый voximplant"], "rating": ["+12"], "bookmarks": ["118"], "views": ["14,9k"], "comments_count": []},
{"author": ["ageyev"], "date": ["24 ноября 2015 в 06:36"], "hubs": ["Lua", "Разработка игр"], "type_label": ["Перевод"], "text": "Недавно я снова начал играть в Minecraft. Ванильный Minecraft несколько скучен, как по мне, и я всегда ищу модпаки (пакеты дополнений). В поисках новых модпаков я наткнулся на FTB Horizons: Daybreaker. Из списка содержащихся в нем модов мое внимание привлек мод OpenComputers. Как можно предположить из названия, модуль OpenComputers добавляет в Minecraft компьютеры. Настоящие компьютеры! При этом они тоже модульные. Вы можете добавлять периферию: от мониторов до клавиатур и карт расширения, которые добавляют возможности такие как графика и сеть. И эти компьютеры могут быть запрограммированы на языке Lua, прямо в игре. И существует такой вид карт, как Интернет-карта, которая можете себе представить, может подключаться к Интернету реального мира. Неплохо. Итак, что мы можем сделать примерно в один час свободного времени? У меня была парочка лампочек с WiFi, правда было бы неплохо управлять ними из Minecraft? Мои wifi-лампочки — это неизвестные девайсы, найденные на eBay, которые управлялись неуклюжим мобильным приложением. Друг мой Томас сделал реверс-инжиниринг протокола и я смог контролировать их цвет и состояние через TCP на порт 5577. Итак, у меня есть все что нужно, что дальше? Начинаем мастерить Прежде всего, я запустил Minecraft. Далее, я сотворил новый мир в Minecraft и вошел в игру. Переключился в творческий режим, что означает что я мог вносить в игру все что хочу, и построил OpenComputers компьютер. Имеется много инструкций на этот счет, но все же разобраться как работают такие компьютеры — это заняло некоторое время. После некоторых проб и ошибок у меня был работающий компьютер и я мог создать TCP соединение с реальным миром! Протокол используемый лампочкой довольно прост, один байт заголовка (header byte), три дополнительных байта определяющих цвет в формате RGB, и байт определяющий яркость белого (лампочка RGBW), и один байт переключающий между режимом RGB и режимом белого, и замыкающий байт (footer byte). Достаточно просто! 0x56 RED GREEN BLUE WHITE MODE 0xAA В ванильном Minecraft есть редстоун («красная пыль»), эквивалент электричеству в нашем мире. По умолчанию, поддерживаются различные блоки такие как рычаги, поршни, компараторы, и т.д. Люди создают реально сложные конструкции используя редстоун, такие как настоящий процессор. OpenComputers компьютеры работают от редстоуна, значит мы можем считывать бинарное значение состояния майнкрафтовского рычага: «включено» или «выключено» и переключать WHITE байт чтобы включить или выключать лампочку. Это компьютер, который я построил в игре, у него есть 6 мониторов которые составляют один большой монитор, жесткий диск и редстоуновский рычаг подключенный справа линией «красной пыли»: Соединяем это все вместе Итак, у нас есть компьютер, способ управлять компьютером и входящими сигналами. Мы также имеем путь и протокол для коммуникации с лампочкой. Последний элемент паззла — программа которая запуститься на компьютере и оживит всю систему. Прежде всего я заспавнил в Minecraft жесткий диск. При записи информации на жесткий диск, OpenComputers компьютер создает директорию с уникальным идентификаторов в директории файлов Minecraft. Таким образом я могу добавлять, редактировать и удалять файлы из моего компьютера на компьютере в игре. В качестве редактора я использовал Sublime Text, на мой взгляд писать код на компьютере в игре не слишком-то удобно. И вот после некоторых исследований и ошибок, я написал следующий скрипт: local event = require('event') local net = require('internet') local myEventHandlers = {} local running = true local con = net.open('192.168.1.110', 5577) function myEventHandlers.key_up(address, char, code, playerName) if (char == 'q') then running = false print('Goodbye ' .. playerName .. '!') end end function myEventHandlers.redstone_changed(_, address, side) local brightness = 0xff; if side > 0 then brightness = 0xff else brightness = 0x00 end print('Sending ' .. brightness .. ' to lamp...') con:write(string.char(0x56)) con:write(string.char(0x00)) con:write(string.char(0x00)) con:write(string.char(0x00)) con:write(string.char(brightness)) con:write(string.char(0x0f)) con:write(string.char(0xaa)) con:flush() end function handleEvent(eventID, ...) local event = myEventHandlers[eventID] if (event) then event(...) end end if con then print('Connected to the bulb!') end while running do handleEvent(event.pull()) end Программа на Lua при исполнении реагирует на два события (events): «key_up» и «redstone_changed». Первое имеет место, когда нажимается клавиша во время работы программы, и последнее — когда получен редстоун-сигнал. Теперь у нас есть главный цикл событий, и можно было реализовать простую логику. Прежде всего, если нажата клавиша 'q' — программа завершается. Когда получен сигнал редстоуна, программа преобразует положение рычага в '0x00' либо '0xFF', что означает включение и выключение wifi-лампы. Пакеты передаются по каналу и лампа реагирует соответственно. Наконец, TCP подключение открывается, когда программа запускается. Просто и работает! Ссылки: Четвёртая стена (термин) оригинал статьи использовавшаяся автором модель WiFi лампочки на dx.com Обсуждение на Hacker News OpenComputers на GitHub OpenComputers на Minecraft Forum", "image": ["https://habrastorage.org/getpro/habr/post_images/c6b/660/447/c6b66044731eee9761de7d4a24a4ad0e.jpg", "https://habrastorage.org/getpro/habr/post_images/e1c/4f2/75e/e1c4f275efb76d296c6ae9e305e32910.gif", "https://habrastorage.org/getpro/habr/post_images/5dd/dd4/db5/5dddd4db5c463bc5cf6fa65436d44757.jpg", "https://habrastorage.org/getpro/habr/post_images/3d8/a38/51b/3d8a3851b1598b0a70ba9feee2938e7e.gif"], "tag": ["internet of things", "minecraft", "wi-fi"], "rating": ["+28"], "bookmarks": ["102"], "views": ["34,2k"], "comments_count": ["18"]},
{"author": ["mrsuh"], "date": ["11 ноября 2015 в 19:03"], "hubs": ["Программирование", "Lua"], "type_label": [], "text": "Предположим, у вас есть данные, которые вы хотите кэшировать и отдавать, не используя тяжелые языки, как php, при этом проверяя, что пользователь аутентифицирован и имеет право на доступ к данным. Сегодня я расскажу, как, используя связку nginx lua redis, выполнить эту задачу, снять нагрузку с сервера и увеличить скорость отдачи информации сервером в десятки раз. Для начала необходимо собрать nginx с модулем nginx_lua_module. Инструкция по установкеУстановим компилятор lua (версии 2.0 или 2.1) Скачаем luaJit и соберем его make && sudo make install Для сборки nginx с nginx devel kit необходим http_rewrite_module, а тот с свою очередь требует библиотеку pcre. Поэтому установим ее sudo apt-get update sudo apt-get install libpcre3 libpcre3-dev Скачаем зависимые модули и сам nginx nginx devel kit nginx lua module nginx Сконфигурируем и установим nginx export LUAJIT_LIB=/usr/local/lib // путь к библиотеке lua export LUAJIT_INC=/usr/local/include/luajit-2.1 //путь к luaJit ./configure --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-ld-opt=\"-Wl,-rpath,/path/to/lua/lib\" // путь к библиотеке Lua --add-module=/path/to/ngx_devel_kit //путь к nginx devel kit --add-module=/path/to/lua-nginx-module // путь к nginx lua module --without-http_gzip_module make -j2 sudo make install Скачаем библиотеку lua для работы с redis lua redis lib и скопируем ее в папку библиотек lua командой sudo make install Подключим библиотеку lua redis в конфигурацию nginx http { ... lua_package_path lua_package_path \"/path/to/lib/lua/resty/redis.lua;;\"; // путь к библиотеке lua redis ... } Все. Теперь можно писать скрипы на lua, которые будут исполнятся nginx Чтобы быстро и эффективно отдавать кэшированные данные, мы положим самые часто используемые из них в redis сразу при прогреве кэша, а менее используемые будем класть по запросу. Отдавать данные будем с помощью lua на стороне nginx. В этой связке не будет участвовать php, что в разы ускорит выдачу данных и будет занимать намного меньше памяти у сервера. Для этого напишем Lua скрипт search.lualocal string = ngx.var.arg_string -- получим параметр из GET запроса if string == nil then ngx.exec(\"/\") -- если параметра нет, то сделаем редирект end local path = \"/?string=\" .. string local redis = require \"resty.redis\" -- подключим библиотеку по работе с redis local red = redis:new() red:set_timeout(1000) -- 1 sec local ok, err = red:connect(\"127.0.0.1\", 6379) if not ok then ngx.exec(path) -- если нельзя подключиться к redis, то сделаем редирект end res, err = red:get(\"search:\" .. string); -- получим данные из redis if res == ngx.null then ngx.exec(path) -- если данных нет, то сделаем редирект else ngx.header.content_type = 'application/json' ngx.say(res) -- если данные есть, то отдадим их end Подключим этот файл в nginx.conf и перезагрузим nginx location /search-by-string { content_by_lua_file lua/search.lua; } Теперь при запросе /search-by-string?string=smth lua подключится к redis и попробует найти данные по ключу search:smth. Если данных не окажется, то запрос обработает php. Но если данные уже закэшированы и лежат в redis, то они будут сразу же отданы пользователю. Но что, если нам нужно отдавать данные, только если пользователь аутентифицирован и при этом имеет определенную роль? В таком случае можно хранить сессию в redis и перед тем, как отдавать контент, проверять роль пользователя по данным сессии. Т.к. я работаю с фрэймворком Symfony2, то для него был написан небольшой бандл nginx-session-handler, с помощью которого можно хранить сессию в redis именно так, как нам удобно. В redis данные будут хранится в качестве хэш значения: phpsession — префикс ключа для сессии php-session — сама сессия php user-role — роль пользователя. Теперь нужно написать lua скрипт для обработки этих данных: session.lualocal redis = require \"resty.redis\" -- подключаем библиотеку по работе с redis local red = redis:new() red:set_timeout(1000) -- 1 sec local ok, err = red:connect(\"127.0.0.1\", 6379) if not ok then ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR) -- если не удалось подключиться, end -- то возвращаем ответ со статусом 500 local phpsession = ngx.var.cookie_PHPSESSID -- получаем id сессии из cookie пользователя local ROLE_ADMIN = \"ROLE_ADMIN\" -- роль, которой нужно предоставить доступ if phpsession == ngx.null then ngx.exit(ngx.HTTP_FORBIDDEN) -- если в cookie нет сессии(пользователь не аутентифицированн), end -- то возвращаем ответ со статусом 403 local res, err = red:hget(\"phpsession:\" .. phpsession, \"user-role\") -- получаем роль пользователя -- из redis по id сессии if res == ngx.null or res ~= ROLE_ADMIN then ngx.exit(ngx.HTTP_FORBIDDEN) -- если сессии нет(закончилось время жизни сессии) или end -- у пользователя не та роль, что нам нужна, -- то возвращаем ответ со статусом 403 Мы достаем id сессии пользователя из cookie, пытаемся получить роль пользователя по его id сессии из redis по запросу HGET phpsession:id user-role. Если у пользователя истекло время жизни сессии, он не аутенитифицированн или у него не роль ROLE_ADMIN, то сервер вернет код 403. Дописываем этот скрипт обработки сессии перед нашим скриптом получения данных и теперь данные могут получить только аутентифицированные пользователи с ролью ROLE_ADMIN. На деле скрипт обработки сессии будет необходим для нескольких location nginx. Чтобы не писать один и тот же код в разных местах, мы будем подключать этот файл там, где нам нужно. Для начала немного перепишем наш скрипт обработки сессии. session.lualocal _M = {} --добавили переменную function _M.handle() -- записали в нее функцию и поместили в нее весь предыдущий код local redis = require \"resty.redis\" local red = redis:new() red:set_timeout(1000) -- 1 sec local ok = red:connect(\"127.0.0.1\", 6379) if not ok then ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR) end local phpsession = ngx.var.cookie_PHPSESSID local ROLE_ADMIN = \"ROLE_ADMIN\" if phpsession == ngx.null then ngx.exit(ngx.HTTP_FORBIDDEN) end local res = red:hget(\"phpsession:\" .. phpsession, \"user-role\") if res == ngx.null or res ~= ROLE_ADMIN then ngx.exit(ngx.HTTP_FORBIDDEN) end end return _M -- вернули переменную с функцией Теперь необходимо собрать session.o файл из session.lua с помощью компилятора luaJit и собрать nginx c этим файлом. Соберем session.o файл, выполнив команду компилятора lua /path/to/luajit/bin/luajit -bg session.lua session.o Добавим в конфигурацию для сборки nginx строку --with-ld-opt=\"/path/to/session.o\" и соберем nginx(как собрать nginx описано выше) После этого можно подключать файл в любой lua скрипт и вызывать функцию handle() для обработки сессии пользователя local session = require \"session\" session.handle() В конце небольшой тест для сравнения. конфигурация компьютераProcessor: Intel Xeon CPU X3440 @ 2.53GHz × 8 Memory: 7.9 GiB Тесты, которые с помощью php или lua достают данные из redis ab -n 100 -c 100 phpServer Software: nginx/1.9.4 Concurrency Level: 100 Time taken for tests: 3.869 seconds Complete requests: 100 Failed requests: 0 Requests per second: 25.85 [#/sec] (mean) Time per request: 3868.776 [ms] (mean) Time per request: 38.688 [ms] (mean, across all concurrent requests) Transfer rate: 6.66 [Kbytes/sec] received Connection Times (ms) min mean[±sd] median max Connect: 1 3 1.1 3 5 Processing: 155 2116 1053.7 2191 3863 Waiting: 155 2116 1053.7 2191 3863 Total: 160 2119 1052.6 2194 3864 Percentage of the requests served within a certain time (ms) 50% 2194 66% 2697 75% 3015 80% 3159 90% 3504 95% 3684 98% 3861 99% 3864 100% 3864 (longest request) ab -n 100 -c 100 luaServer Software: nginx/1.9.4 Concurrency Level: 100 Time taken for tests: 0.022 seconds Complete requests: 100 Failed requests: 0 Requests per second: 4549.59 [#/sec] (mean) Time per request: 21.980 [ms] (mean) Time per request: 0.220 [ms] (mean, across all concurrent requests) Transfer rate: 688.66 [Kbytes/sec] received Connection Times (ms) min mean[±sd] median max Connect: 2 4 0.9 4 6 Processing: 3 13 1.6 13 14 Waiting: 3 13 1.6 13 14 Total: 9 17 1.3 18 18 Percentage of the requests served within a certain time (ms) 50% 18 66% 18 75% 18 80% 18 90% 18 95% 18 98% 18 99% 18 100% 18 (longest request) Разница «количества запросов в секунду» в 175 раз. Такой же тест с другими парметрами ab -n 10000 -c 100 phpServer Software: nginx/1.9.4 Concurrency Level: 100 Time taken for tests: 343.082 seconds Complete requests: 10000 Failed requests: 0 Requests per second: 29.15 [#/sec] (mean) Time per request: 3430.821 [ms] (mean) Time per request: 34.308 [ms] (mean, across all concurrent requests) Transfer rate: 7.51 [Kbytes/sec] received Connection Times (ms) min mean[±sd] median max Connect: 0 0 0.3 0 4 Processing: 167 3414 197.5 3408 4054 Waiting: 167 3413 197.5 3408 4054 Total: 171 3414 197.3 3408 4055 Percentage of the requests served within a certain time (ms) 50% 3408 66% 3438 75% 3458 80% 3474 90% 3533 95% 3633 98% 3714 99% 3866 100% 4055 (longest request) ab -n 10000 -c 100 luaServer Software: nginx/1.9.4 Concurrency Level: 100 Time taken for tests: 0.899 seconds Complete requests: 10000 Failed requests: 0 Requests per second: 11118.29 [#/sec] (mean) Time per request: 8.994 [ms] (mean) Time per request: 0.090 [ms] (mean, across all concurrent requests) Transfer rate: 1682.94 [Kbytes/sec] received Connection Times (ms) min mean[±sd] median max Connect: 0 0 0.4 0 5 Processing: 1 9 3.4 7 19 Waiting: 1 9 3.5 7 18 Total: 2 9 3.4 7 21 Percentage of the requests served within a certain time (ms) 50% 7 66% 13 75% 13 80% 13 90% 13 95% 13 98% 13 99% 15 100% 21 (longest request) Разница «количества запросов в секунду» в 381 раз. Надеюсь, моя статья была полезна. Если у вас есть пожелания, замечания или вы, знаете как сделать лучше — пишите.", "image": ["https://habrastorage.org/files/adf/e6d/10e/adfe6d10e2ec4c2a8f0631c45e7d5499.png"], "tag": ["nginx", "redis", "lua-nginx-module", "lua"], "rating": ["+32"], "bookmarks": ["243"], "views": ["23,6k"], "comments_count": ["12"]},
{"author": ["dedokOne"], "date": [" 2 декабря 2015 в 13:00"], "hubs": ["Open source", "Lua", "Блог компании Mail.Ru Group"], "type_label": [], "text": "Вам знакома такая архитектура? Хоровод демонов, пляшущих между web-server, cache и storage. Какие минусы такой архитектуры можно отметить? Решая задачи в рамках такой архитектуры, мы сталкиваемся с кучей вопросов: какой язык(и?) взять, какой I/O framework выбрать, как синхронизировать cache и storage? Куча инфраструктурных вопросов. А зачем решать инфраструктурные вопросы, когда надо решить задачу? Безусловно, можно сказать, что нам нравятся некие технологии X и Y, и перевести эти минусы в рамки идеологических. Но нельзя отрицать тот факт, что данные располагаются на неком расстоянии от кода (картинка выше), что добавляет latency, что может уменьшить RPS. Цель данной статьи — рассказать об альтернативе, которая построена на базе Nginx как web-server, bаlancer и Tarantool как App Server, Cache, Storage. Улучшаем cache и storage У Tarantool есть несколько интересных свойств. Tarantool — это не только эффективная inmemory DB, но и полноценный Application Server, приложения пишутся на Lua (luajit), C, C++, т.е. можно написать логику любой сложности, ограничение одно: фантазия. Если данных больше, чем доступно памяти, часть данных можно хранить на диске, используя движок Sophia. Если Sophia не подходит, можно взять что-то другое и скидывать «холодные» данные, т.е. данные, которые не нужны прямо сейчас, из Tarantool в другой Storage, а «горячую» часть хранить в Tarantool, т.е. в памяти. Какие преимущества это дает нам? Нет посредников. Как минимум горячая часть данных находится на одном уровне с кодом. Горячие данные в памяти. Код достаточно простой и легко обновляется, если мы говорим о Lua. Транзакции, репликация, шардинг и множество других возможностей Tarantool. Улучшаем web-server Конечным потребителем данных является пользователь. Обычно, пользователь получает данные от Application Server через Nginx как балансер/прокси. Вариант написания демона, который умеет общаться и с Tarantool, и с HTTP не подходит, так как приведет нас к первому рисунку, и мы опять вернёмся к тому, с чего начали. Поэтому попробуем взглянуть на ситуацию с другой стороны, и задать другой вопрос: «Как избавиться от посредников между данными и пользователем?». Ответом на этот вопрос и стала реализация Tarantool Nginx Upstream Module. Nginx Upstream Nginx Upstream — это персистентное (см. Upstream Keepalive) соединение через pipe/socket к backend, далее будем называть это «проксированием». Nginx предоставляет много разнообразного функционала для написания правил Upstream, для проксирования HTTP в Tarantool особое значение приобретают следующие возможности: возможность указывать несколько backend, на которые Nginx будет балансировать нагрузку; возможность указывать backup, т.е. указывать, куда ходить, если Upstream не работает. Эти возможности позволяют: распределять нагрузку на N Tarantool, например, вкупе с шардингом можно построить кластер с равномерной загрузкой по нодам; можно сделать отказоустойчивую систему при помощи репликации; используя п. а) и п. b) получим отказоустойчивый кластер. Пример конфига для Nginx, частично иллюстрирующий возможности настроек: # Настройки проксирования в Tarantool upstream tnt { server 127.0.0.1:10001; # первый сервер живет на localhost server node.com:10001; # второй где-то еще server unix:/tmp/tnt; # третий через unix socket server node.backup.com backup; # а тут backup } # HTTP-сервер server { listen 8081 default; location = /tnt/pass { # Говорим Nginx что надо использовать Tarantool Upstream Module # и указываем имя Upstream tnt_pass tnt; } } Более детально о конфигурировании Nginx Upstream можно прочитать тут: http://nginx.org/en/docs/http/ngx_http_upstream_module.html#upstream. Nginx Tarantool Upstream Module (v0.1.4 Stable) Основной функционал: модуль активируется в Nginx.conf директивой — tnt_pass UPSTREAM_NAME; быстрое потоковое преобразование HTTP + JSON <-> Tarantool Protocol, минимальные блокировки (на время парсинга) Nginx worker; неблокирующее I/O Nginx в оба направления; как приятный бонус: все фичи Nginx, Nginx Upstream; модуль позволяет вызывать хранимые процедуры Tarantool через JSON-based Protocol; данные доставляются через HTTP(S) POST, что удобно для Modern WebApps и не только. Входные данные [ { \"method\": STR, \"params\":[arg0 ... argN], \"id\": UINT }, ...N ] «method» Имя хранимой процедуры. Имя должно совпадать с именем процедуры в Tarantool. Например, чтобы вызвать lua-функцию do_something(a, b), надо: “method”: “do_something” «params» Аргументы хранимой процедуры. Например, чтобы передать аргументы в lua-функцию do_something(a, b), надо: “params”: [ “1”, 2 ] «id» Числовой идентификатор, устанавливается клиентом. Выходные данные [ { \"result\": JSON_RESULT_OBJECT, \"id\":UINT, \"error\": { \"message\": STR, \"code\": INT } }, ...N ] «result» Данные, которые вернула хранимая процедура. Например, lua-функция do_something(a, b) возвращает return {1, 2} то “result”: [[1, 2]] «id» Числовой идентификатор, установленный клиентом. «error» Если произошла ошибка, в этом поле будут данные о причинах. Более детальней о протоколе тут: https://github.com/tarantool/nginx_upstream_module/blob/master/README.md Hello World Запускаем Nginx Nginx мы соберем из исходников: $ git clone https://github.com/tarantool/nginx_upstream_module.git $ cd nginx_upstream_module $ git submodule update --init --recursive $ git clone https://github.com/nginx/nginx.git $ cd nginx && git checkout release-1.9.7 && cd - $ make build-all-debug Цель build-all-debug — это debug-версия. Делаем так, чтобы меньше конфигурировать Nginx. Для тех, кто хочет законфигурировать все с нуля, есть цель build-all. Файл test-root/conf/nginx.conf http { # Добавляет один Tarantool как backend upstream echo { server 127.0.0.1:10001; } server { listen 8081 default; # Nginx повесим на *:8081 server_name tnt_test; location = /echo # на *:8081/echo вешаем ‘echo’ Tarantool Upstream { tnt_pass echo; } } } $ ./nginx/obj/nginx # запускаем nginx Запускаем Tarantool Tarantool можно поставить из пакетов, либо собрать. Файл hello-world.lua -- Это и есть наша хранимая процедура, она предельно простая и не использует Tarantool как DB. -- Все что она делает - это просто возвращает свой 1-й аргумент. function echo(a) return {{a}} end box.cfg { listen = 10001; -- указываем куда вешаем Tarantool } Если вы поставили Tarantool из пакетов, запустить его можно так: $ tarantool hello-world.lua # первым аргументом передаем имя lua-скрипта. Вызываем хранимую процедуру Вызвать хранимую процедуру echo можно любым HTTP-коннектором, все что нужно сделать — HTTP POST по 127.0.0.1/echo и в теле передать следующий JSON (см. Входные данные): { \"method\":\"echo\", // имя метода, должно совпадать с именем метода в Tarantool \"params\":[ {\"Hello world\": \"!\"} // 1-й аргумент - объект ], \"id\":1 // ID сообщения } Я вызову эту процедуру wget’ом $ wget 127.0.0.1:8081/echo --post-data '{\"method\":\"echo\",\"params\":[{\"Hello world\": \"!\"}],\"id\":1}' $ cat echo {\"id\":1,\"result\":[[{\"hello world\":\"!\"}]]} Еще несколько примеров: https://github.com/tarantool/nginx_upstream_module/blob/master/examples/echo.html https://github.com/tarantool/nginx_upstream_module/blob/master/test/client.py Подведем итоги Плюсы использования Nginx Tarantool Upstream Module: нет посредников, код и данные, как правило, на одном уровне; относительно простое конфигурирование; балансировка нагрузки на N Tarantool; высокая скорость работы, низкая latency; JSON-based протокол вместо бинарного, не надо искать Tarantool Driver, JSON есть везде; Tarantool Sharding/Replication и Nginx = кластерное решение, но это тема отдельной статьи; решение используется в продакшене. Минусы: Overhead JSON вместо более компактного и быстрого MsgPack; решение не коробочное, нужно конфигурировать, нужно думать, как деплоить. Планы: поддержка OpenRеsty и nginScript; поддержка WebSocket и HTTP 2.0. Результаты бенчмарка, а они очень даже интересные, будут в другой статье. Tarantool, как и Upstream Module, всегда открыт для новых пользователей, если у вас есть желание это все попробовать, использовать или выразить новую идею — обращайтесь на github, google group. Ссылки Сайт Tarantool — http://tarantool.org Git Tarantool — https://github.com/tarantool/tarantool Git Tarantool Nginx Upstream Module — github.com/tarantool/nginx_upstream_module Google group — https://groups.google.com/forum/#!forum/tarantool P.S. В следующей статье я покажу, какие задачи можно решить, используя Tarantool.", "image": ["https://habrastorage.org/files/d7c/36b/afb/d7c36bafbc3e49e3a63058ad1b608caa.png", "https://habrastorage.org/files/0a7/dcd/f8f/0a7dcdf8f14041b1b733ba142e006272.png", "https://habrastorage.org/files/555/74a/4cf/55574a4cf95e488092f58646e6003820.png", "https://habrastorage.org/files/9a7/809/240/9a78092400a14edc82e532310c2ff27c.png"], "tag": ["nginx", "nginx_upstream_tarantool_module", "tarantool", "microservices", "http", "базы данных", "rpc"], "rating": ["+37"], "bookmarks": ["158"], "views": ["19,1k"], "comments_count": ["22"]},
{"author": ["ivan386"], "date": [" 5 февраля 2016 в 00:58"], "hubs": ["Lua"], "type_label": [], "text": "Данная статья является лиш исследованием на тему и не должна использоваться как инструкция к действию. Блокировки продолжаются а я всё также не приветствую отдачу не шифрованного HTTP трафика в заморские прокси, Tor, анонимайзеры и включение экономии трафика в браузере. Пока есть возможность я буду пытаться ходить на сайты прямо. Заодно скорость связи с сайтом не будет зависеть от загруженности стороннего сервиса. Я поставил на Firefox плагин RequestPolicy и обнаружил в HTTP хедерах на сайте. X-Squid-Error:\"403 Access Denied\" Это значит что соединение к сайту проходит через прозрачный прокси. В этой статье я попробую пройти при помощи локального прокси написанного на Lua (Вики) Скачав LuaSocket 2.0.2 я написал небольшой скрипт локального прокси. require \"socket\" local cors = {} function main() local proxy_bind = socket.tcp() proxy_bind:setoption(\"reuseaddr\", true) -- На всякий случай proxy_bind:bind(\"localhost\", 8080) -- Принимаем подключения только от локального клиента proxy_bind:listen(100) -- 100 подключений в очереди proxy_bind:settimeout(0) -- 0s Позволяет не задерживаться ожидая данных и забрать из буфера сразу всё. repeat -- Главный цикл который принимает подключения local client, accept_err = proxy_bind:accept() if (client) then local new_cor = coroutine.create(new_client) local ok, err = coroutine.resume(new_cor, client) if (ok) then table.insert(cors, new_cor) end end local new_list = {} for id, cor in ipairs(cors) do local ok, err = coroutine.resume(cor) if (ok) then table.insert(new_list, cor) end end cors = new_list socket.sleep(0.001) -- Чтоб не сильно нагружать процессор until accept_err and (accept_err ~= \"timeout\") end -- Читаем хедеры и соединяемся с конечным сайтом сквозь фильтрующий прокси function new_client(client) client:settimeout(0) local headers, err = get_data(client:receive(\"*a\")) local host, port = get_host_port(headers) headers = headers:gsub(\"( HTTP/1.1)\\13(\\10Host: )\", \"%1%2\") local server = socket.connect(host, port) print(\"NC\", host, port) if (server) then if (not send_connect(server, string.format(\"%s:%s\", socket.dns.toip(host), port))) then server:close() server = socket.connect(host, port) end if (server) then headers = headers:gsub(\"\\10Connection%: keep%-alive\\13\\10\", \"\\10Connection: close\\13\\10\") server:send(headers) cycle_data(server, client, host) end end print(\"CLOSED\", host, port) server:close() client:close() end function get_data(data, err, part, marker) data = (data or part) return data, err end function get_host_port(headers) if headers and (#headers > 0) then if not (headers:find(\" HTTP/1.1\\13\\10Host: \", 1, true)) then return end local _, _, host, port = headers:find(\" HTTP/1.1\\13\\10Host: ([a-z0-9%.%-]+):?([0-9]*)\\13\\10\") if (#port > 0) then port = tonumber(port) else port = 80 end return host, port end end -- Используем метод CONNECT который превращает фильтрующий прокси в TCP трубу local connect = \"CONNECT %s HTTP/1.1\\13\\10Host: %s\\13\\10\\13\\10\" function send_connect(server, address) server:send(string.format(connect, address, address)) server:settimeout(0.1) local headers, err = get_data(server:receive(\"*a\")) while ((not headers) or (#headers <= 12)) and not (err and (err ~= \"timeout\")) do coroutine.yield() -- Даём скрипту обработать другие подключения local data, err = get_data(server:receive(\"*a\")) if (data and #data > 0) then headers = (headers or \"\") .. data end end return headers:find(\"^HTTP/1.[01] 200\") end -- Пересылаем данные в обе стороны function cycle_data(server, client, host, port) local _in_, out = server, client repeat _in_:settimeout(0) out:settimeout(1) local data, receive_err = get_data(_in_:receive(\"*a\")) if data and (#data > 0) then data = data:gsub(\"\\13\\10Connection%: keep%-alive\\13\\10\", \"\\13\\10Connection: close\\13\\10\") local index, send_err = send_data(out, data) end coroutine.yield() -- Даём скрипту обработать другие подключения until (receive_err and (receive_err ~= \"timeout\")) or (send_err and (send_err ~= \"timeout\")) end function send_data(out, data) local index = 0 repeat index = index +1 index, err = get_index(out:send(data, index)) until index >= #data or (err and (err ~= \"timeout\")) return index, err end function get_index(index, err, partial_index) return (index or partial_index), err end main() Сохраняем скрипт как «proxy.lua» в распакованную папку с LuaSocket 2.0.2. Создаём простой «proxy.bat» файл для запуска «proxy.lua», который сохраним там же. %~d0 cd %~p0 lua5.1 proxy.lua pause Теперь подредактируем «proxy.pac» из прошлой статьи. (Адреса изменены) function FindProxyForURL(url, host) { if (shExpMatch(url, \"http://*\") && shExpMatch(host, \"rutracker.og\")) { return \"PROXY localhost:8080; PROXY rutracker.og; DIRECT\"; } /* Для HTTPS соединений через HTTP прокси метод CONNECT используется автоматически */ if (shExpMatch(url, \"https://*\") && shExpMatch(host, \"rutracker.og\")) { return \"PROXY rutracker.og; DIRECT\"; } return \"DIRECT\"; } Запускаем прокси двойным кликом по «proxy.bat». Перезапускаем браузер и открываем rutracker.og. Скрипт писался быстро и чинился костылями. Это не полноценный прокси. Если кто придумает решение проще я буду очень рад. Дополнительно: На случай возможного разделегирования домена в файл hosts добавим строку (Адреса изменены): #198.51.100.0 rutracker.og И если домен разделегируют можно раскоментировать строчку удалив \"#\" и вернуть доступ к серверу. 198.51.100.0 rutracker.og Так например можно вернуть доступ к серверу rutor.og (адрес изменён) взяв его ip из реестра или других источников. Использована информация: Lua 5.1 Reference Manual LuaSocket: TCP/IP support Дурим DPI двумя скриптами Proxy Auto Configuration (PAC) hosts — Википедия", "image": [], "tag": ["antirkn", "lua", "proxy", "script", "filter proxy"], "rating": ["+12"], "bookmarks": ["123"], "views": ["16,3k"], "comments_count": ["10"]},
{"author": ["akalend"], "date": ["18 января 2016 в 01:32"], "hubs": ["Высокая производительность", "NoSQL", "Lua"], "type_label": [], "text": "Рассказ будет про один контентный проект, в котором мне пришлось переделать архитектуру. Ранее была реализована классическая Лампа-схема (Linux-Apache-MySQL-PHP). Но кол-во посетителей прибавлялось и прибавлялось, уже стало подходить к 1М хостов и сервер БД переставал справляться. Первым делом, я предложил докупить еще один серак, но в данном сегменте конвертация в партнерских программах довольно низкая, так что, руководство проекта немного пожмотилось. Если, интересно, как мне пришлось изменить архитектуру и при этом еще прикрутить систему ротации и рейтингов, то добро пожаловать под кат. Особенность данного проекта в том, что он раздает видео контент, который находится на сайтах-донорах, типа твоей трубы (YouTube). Сайт должен отображать только ВВ-коды (определенный HTML). Поэтому, не было необходимости постоянно генерить HTML на лету, а делалось это через определенное время, например, раз в сутки, правда потом заменили на ротацию через 1000 показов. Apache заменили на nginx, а сам nginx отдавал просто сгенерированный статический контент HTML. Каждый раз, придя на сайт, посетитель должен увидеть что-то новенькое. А новенькое, как часто бывает – это хорошо забытое старенькое. Вобщем, нужна была ротация видео превью (о них чуть позже). Существует несколько алгоритмов ротации. Вы даже не представляете изощренность ума маркетологов. Поэтому, расскажу только про один, наиболее простой. В первые 10 слотов, вставляются только новые превьюшки. Далее, выбираются 90 превьюшек данной категории с максимальным CTR. Кто не знаком с этим термином, это показатель кликабельности, от англ. click-through rate: отношение числа кликов на картинку к числу её показов. Видео может быть потенциально популярным, а вот превьюшка не презентабельной. Это с большой вероятность может быть, так как вместо студента, который сидит и выбирает самые сочные момменты видео, сидит робот и генерит превьюшки случайно выбранного кадра. Поэтому рейтинг, вполне интересного видео может уйти в “даун”. Чтобы, разнообразить сайт, да и выровнять эффект случайного кадра, используется локальный рейтинг: генерится три превью от одного видео, которые тоже ротируются. В ходе естественного отбора, остаются наиболее привлекательные картинки. Есть еще система голосований: пальчик вверх/пальчик вниз, но её тех-реализация один в один похожа на систему ротации. Но, мы здесь собрались не SEO-сказки слушать, а поделиться тех деталями. В общем, вся Лампа технология была заменена на сайто-генератор. Nginx работал на отдачу статики. Остаётся только реализовать подсчет CTR. Так как общее кол-во видео на сайте составляло в районе 100К, то вполне можно выбрать персистентное in-memory хранилище. Какие у нас есть альтернативы: Redis, Aerospike,Tarntool. Из-за хороших функциональных возможностей и дружественной русско-говорящей поддержки ребят из MailRu выбор пал на Tarantool. MySQL у нас ни куда не делся, в нем продолжают храниться BB-коды видео, списки категорий и наименований, описание контента и прочая информация, которая необходима для сайто-генерации. Но, так как БД практически не использовалась, то ему отвели минимум памяти. Теперь более подробно про Tarantool (далее по тексту Т*). О нем много было написано в разных статьях Я постараюсь рассказать, как это применимо на практике, опуская настройку и инсталляцию. Немного скучной теории, чтобы понять что к чему: Все данные в Т* хранятся в пространствах: space. Это аналог таблицы в SQL или коллекции в MongoDb. Как таблица состоит из строк, коллекция из документов, так пространство включает в себя множества кортежей (аналог строки в MySQL). Кортеж состои из элементов или полей. Мне элементы кортежа удобно называть полями и я буду придерживаться этой терминологии, что не идет в разрез с документацией tarantool.org/doc/book/box/index.html. В отличие от строк таблицы, поля в кортеже не имеют названий, а имеют только порядковый номер. Хотя, как вы увидите в последствии, это не принципиально. Каждый кортеж должен иметь первичный ключ. Первичный индекс может иметь один из следующих типов: TREE, HASH, BITSET или RTREE. Так же, на пространство можно наложить вторичный индекс, что позволяет делать такие уникальные выборки, которые не возможно сделать в редисе. На рис 1 изображена аналогия MySQL и T*. Для хранения рейтингов создается пространство stats. Для этого зайдем в консоль и выполним команды: box.cfg{} – загружает дефолтную конфигурацию box.schema.space.create(\"stats\") – создает новое пространство Проверим, как создалось наше пространство: tarantool> box.space --- - stats: temporary: false engine: memtx ... И присвоим его переменной stats tarantool> stats = box.space Если бы мы составляли схему для БД или MongoDb, то выбрали бы следующую схему: 1 key - первичный ключ, совпадает с id видео 2 clicks_1 – кол-во кликов для первой картинки 3 clicks_2 – – || – второй картинки 4 clicks_3 – – || – третьей картинки 5 clicks_sum_1 – общее кол-во кликов для первой картинки 6 clicks_sum_2 – – || – второй картинки 7 clicks_sum_3 – – || – третьей картинки 8 show_1 все тоже самое для показов … 13 show_sum_3 14 ctr_1 ctr для первой картинки за последний промежуток 15 ctr_2 16 ctr_3 17 ctr_sum_1 ctr для первой картинки за весь период 18 ctr_sum_2 19 ctr_sum_3 20 ctr ctr по всем картинкам за последний промежуток 21 ctr_sum ctr по всем картинкам за весь период Первая колонка — это номер поля, определим константами имена полей: -- первое поле это первичный ключ clicks_1 = 2 clicks_2 = 3 . . . ctr_sum = 22 Создадим в нашем пространстве первичный ключ, выбираем тип HASH: stats:create_index('primary', {type = 'hash', parts = {1, 'NUM'}}) Проверим, что создали: tarantool> stats.index --- - 0: &0 unique: true parts: - type: NUM fieldno: 1 id: 0 space_id: 513 name: primary type: HASH primary: *0 ... Очень хорошо, если получилось, а теперь создадим функцию, которая будет инкрементировать поле clicks_1, и для отладки вставим несколько записей: stats:insert{1,0,0,0,0,0,0} stats:insert{2,0,0,0,0,0,0} stats:insert{3,0,0,0,0,0,0} Сперва проверим, что понавставляли: tarantool> stats:select{2} --- - - [2, 0, 0, 0, 0, 0, 0] … Замечательно, у нас все работает! Теперь напишем код инкрементации поля: tarantool> stats:update(2,{{ '+',2,1 }}) tarantool> stats:select{2} - [2, 1, 0, 0, 0, 0, 0] tarantool> stats:update(2,{{ '+',2,1 }}) - [2, 2, 0, 0, 0, 0, 0] Команда update имеет следующие параметры: primary key — номер ключа, по которой производится обновление вторым параметром идет список действий, каждый элемент которого представляет триплет (список из трех элементов): — тип действия, в данном случае сложение — номер поля, над которы проводятся изменения — число Подробнее о команде update в документации: tarantool.org/doc/book/box/box_space.html#lua-function.space_object.update Мы видим, что с каждым выполнением stats:update данные для key=2 второго поля увеличиваются на 1. Запишем в более читабельном виде. Ранее мы должны были задать: tarantool> clicks_1 = 2 Выполним: tarantool> stats:update(2,{{ '+',clicks_1,1 }}) - [2, 4, 0, 0, 0, 0, 0] Теперь обернем это в функцию: function click_inc(key) stats:update(key,{{ '+',clicks_1,1 }}) end И проверим: tarantool> click_inc(2) tarantool> stats:select{2} --- - - [2, 5, 0, 0, 0, 0, 0] ... tarantool> click_inc(2) tarantool> stats:select{2} --- - - [2, 6, 0, 0, 0, 0, 0] … Добавим в нашу функцию номер картинки (номер начинается 0 – первая картинка): function click_inc(key, img_num) stats:update(key,{{ '+',clicks_1 + img _num, 1}}) end После проверки, приведем функцию в более лучшый вид в отдельнойм файле: click.lua function click_inc(key, img_num) if img_num >3 then return false end box.space.stats:update(key, {{'+',clicks_1 + img_num,1}}) return true end Как видим, логика исполнения функции довольно проста: первый агрумент – id видео, следующий номер его превью. Теперь рассмотрим, как все это может быть применимо. Для WEB проекта, эту функцию можно вызвать тремя c половиной способами: — используя пользовательское АПИ: из скриптов PHP/Python/Perl/Java и т.д. — через tarantool-http, на который будут проксироваться запросы через nginx или собственный lua-скрипт, используя http.lib или иной web сервер (например xavante) — непосредственно из nginx, используя nginx_upstreem модуль. Если есть интерес, могу подробнее рассказать про второй способ, но в данном случаи нами был выбран третий вариант. В статье и так много буковок, так что про установку и настройку модуля можно прочитать в статье Строим сервисы на базе nginx & Tarantool от авторов Т*. Итак, наш click.lua будет следующий: #!/usr/bin/tarantool box.cfg{ log_level = 5; listen = 10001; } click_1 = 2; function click_inc(key, img_num) if img_num >3 then return 0 end box.space.stats:update(key, {{'+',click_1 + img_num,1}}) return 1 end Проверим его: curl http://127.0.0.1:8081/echo --data '{\"method\":\"click_inc\",\"params\":[2,1], \"id\":0}' {\"id\":0,\"result\":[[1]]} Для проверки подконектимся к запущенному экземпляру Т*: tarantool> console=require(\"console\") tarantool> console.connect(\"127.0.0.1:10001\") tarantool: connected to 127.0.0.1:10001 - true 127.0.0.1:10001> stats = box.space.stats 127.0.0.1:10001> stats:select{2} - - [2, 7, 0, 0] ... Так же мы можем инкрементировать счетчик второй картинки: curl http://127.0.0.1:8081/echo --data '{\"method\":\"click_inc\",\"params\":[2,2], \"id\":1}' {\"id\":0,\"result\":[[1]]} Проверим результат: 127.0.0.1:10001> stats:select{2} - - [2, 7, 1, 0] ... Мы рассмотрели как просто сделать систему подсчета кликов. Теперь перейдем к системе показов. Каждая страница множества превьюшек, условно назовем “категории”, по идеи должна вызвать сотню (будем считать что за одна страница категории содержит сто превьюшек из этой категории) раз процедуру инкрементации показов: show_inc. Но, как мы понимаем – это не оптимально. Есть следующий вариант: В теле HTML странице генерится переменная. <script> show_pictupies=”1,2,3,4,5” /* тут перечислены все id показываемых картинок*/ </script> и далее по AJAX передавать весь этот список. Но тут, кроме id картинки надо передать и её вариант показа, поэтому список может принять сл вид: “1-1, 2-1, 3-1, 4-2”, где циферка после знака минус показывает вариант показа. Такого аналога функции, как explode в lua, к сожалению, не существует, поэтому погуглив использовали этот код function split(inputstr, sep) if sep == nil then sep = \"%s\" end local t={} ; i=1 for str in string.gmatch(inputstr, \"([^\"..sep..\"]+)\") do t[i] = str i = i + 1 end return t end Далее проходимя циклом по таблице. Для осуществления цикла, реализуем функцию-итератор: function values(t) local i = 0 return function() i = i + 1; return t[i] end end for it in values(tt) do show_inc(it, 2 ) end Как вы уже догодались, show_inc очень похожа на click_inc с тем немногим исключением, что переменную click_1 заменяем на show_1. Поэтому, можно создать более уневерсальную функцию, stat_inc(key, field, img_number ). function stat_inc(key, field, img_num) if img_num >3 then return 0 end box.space.stats:update(key, {{'+',field + img_num,1}}) return 1 end Так как, мы осуществляем подсчет двух типов ctr: первый с момента последней генерации и общий, то создадим процедуру click, которую будем вызывать через nginx: function click( key, img_num) stat_inc(key, clicks_1, img_num ) stat_inc(key, clicks_sum_1, img_num) end а show: function show( key_list) list = slipt( key_list, ',') for it in value(list) do pos = string.find(it, “-”); key = string.sub(it, 0, pos-1); img_num = string.sub(it,pos+1) stat_inc(key, shows_1, img_num) stat_inc(key, shows_sum_1, img_num) end end Таким образом, у нас подсчитываются и клики, и показы. При интересе к этой теме, я могу описать, как расчитывать ctr и как выбирать картинки для формирования HTML.", "image": ["https://habrastorage.org/files/e11/818/646/e118186460bd41e8b8b7c57e4fa24c14.png"], "tag": ["tarantool", "nginx module", "высоконагруженные проекты", "nosql", "архитектура системы"], "rating": ["+9"], "bookmarks": ["61"], "views": ["9,2k"], "comments_count": ["22"]},
{"author": ["ar1"], "date": [" 6 октября 2015 в 11:16"], "hubs": ["Программирование", "Python", "Lua"], "type_label": [], "text": "V-REP представляет собой среду для симулирования (sandbox) различных видов роботов, при этом пользователю нет необходимости иметь физический доступ к реальной машине, что экономит деньги и время. Среда V-REP предоставляет удобный интерфейс для визуализации действий робота в трёхмерном виртуальном пространстве намного раньше, чем реальный прототип робота будет создан. При помощи данного руководства вы убедитесь, что для того, чтобы работать в данной среде, программисту не нужно иметь большого технического опыта в области роботостроения. Причиной создания данного руководства стало отсутствие (на то время) знаний языка Lua, на котором по умолчанию написаны все скрипты управления роботом, и его меньшая популярность. Цель данного руководства показать как пользоваться удалённым (Remote) API данной среды на примере языка Python. Для начала скачайте версию для Академических целей (Non-limited EDUCATIONAL) для своей ОС с официального сайта. После установки и запуска программы откроется основное окно программы. Когда вы открываете среду V-REP, она инициализирует сцену по умолчанию. Пользователь может открывать несколько сцен параллельно, но отображается только текущая. Панель инструментов содержит набор кнопок, основными из которых являются кнопки для запуска и остановки сцены. Также инструменты для работы с камерой. Для перемещения и изменения угла просмотра, приближение. Для работы с элементами помещенными на сцену существуют следующие инструменты: “выделяемость” объекта по нажатию, перемещение и изменение угла расположения объекта. При этом у выделенного объекта появляются дополнительные оси, за которые удобно перемещать и поворачивать. Иерархия сцены содержит список открытых сцен. В каждую сцену входят различные объекты, которые могут состоят из целого набора подобъектов, таким образом выстраивая целую иерархию. В сцену по умолчанию входят: Камера, Источники света, Расширяемый пол. По нажатию на плюсик в дереве можно посмотреть зависимые объекты. Как вы заметили, справа от имени некоторых объектов есть различные иконки. Таким образом отображаются зависимые Lua-скрипты, которые можно просмотреть по двойному нажатию. У самой сцены есть главный скрипт, редактировать который не рекомендуется. А у других объектов собственные, которые можно добавлять, редактировать и изменять в соответсвии с вашими потребностями. Давайте добавим что-нибудь на нашу сцену. V-REP содержит целую коллекцию разнообразных роботов, которых можно предварительно посмотреть в обзорщике моделей (Tools | Model browser). Для добавления нужной модели необходимо лишь перетащить её на сцену. При этом важно, чтобы сцена при перетаскивании была остановлена, иначе ваши изменения не будут сохранены. Также в среде доступны все основные примитивы, добавить которые можно, нажав правую кнопку мыши на сцене и выбрав соответсвующие пункты меню. Например, добавим на нашу сцену куб, выбрав Add | Primitive shape | Cuboid. И выставим в появившемся меню размеры 0.400 x 0.400 x 0.400. (Соответсвующие метрической системе). Давайте посмотрим как взаимодействовать с V-REP посредством предоставляемым им Remote API, который позволяет писать сценарии для среды на различных языках, среди которых C/C++, Python, Java, Matlab/Octave и Urbi. Для начала создайте папку для нашего нового проекта. Затем создайте новую сцену или удалите/отмените изменения на сцене по умолчанию. Сохраните сцену, например как myFirstScene. В результате создастся файл myFirstScene.ttt Далее вам необходимо скопировать несколько файлов из директории с установленной программой. Зайдите в неё. В ней содержится папка programming, затем в remoteApiBindings, из которой вам нужно скопировать несколько файлов в созданную ранее папку для проекта. А именно файлы из папки python (vrep.py, vrepConst.py, simpleTest.py). И файлы из папки lib в соответсвии с разрядностью вашей ОС (это может быть remoteApi.so или remoteApi.dll). Добавим на сцену модель робота pioneer p3dx. Для этого в обзорщике моделей в дереве robots выберите mobile и перетащите робота на сцену. Если сейчас нажать на кнопку Play (Старт сцены), то робот поедет в прямом направлении, логика его работы содержится в прикреплённом скрипте, который мы скоро заменим на наш Python-скрипт. Если внимательно изучить из чего состоит данная модель в Иерархии сцены (Scene hierachy), то можно заметить, что данный робот состоит из пары колёс (Pioneer_p3dx_leftWheel и Pioneer_p3dx_rightWheel), 16 сенсоров по бокам (Pioneer_p3dx_ultrasonicSensor1-16) и 11 коннекторов (Pioneer_p3dx_connection1-11). Для начала давайте отключим скрипт, двигающий робота вперёд. Для этого нажмём на боковой панели кнопку Скрипты (Scripts). Появится новое окно, в котором перечислены все имеющиеся на сцене скрипты. Теперь выделите скрипт робота Non-threaded child script (Pioneer_p3dx) и поставьте галочку на пункте Disabled. Теперь закройте это окно и протестируйте Включив сцену, робот должен стоять на месте. О том что скрипт отключен также свидетельствует изменившаяся иконка в Иерархии сцены. Теперь давайте немного разберёмся в том, как наш скрипт будет взаимодействовать со сценой при помощи Remote API. V-REP предоставляет средства контроля симуляцией из внешнего приложения или внешнего устройства (например с настоящего робота, удалённого компьютера). API содержит сотни функций, которые могут быть вызваны через коммуникационные сокеты, с минимальной задержкой и нагрузкой на сеть. Всё это происходит в скрытом от пользователя виде. По средствам удалённого API можно взаимодействовать с V-REP в синхронном и асинхронных режимах (по умолчанию действует асинхронный режим), и даже удалённо управлять симулятором (удалённо загружать сцену, начинать и останавливать работу симуляции). Примечание: Синхронный режим подразумевает, что симулятор будет ждать подтверждающего сигнала от клиента для выполнения следующего шага на время t + dt. Для начала работы с Remote API нужно активировать его на стороне сервера, тоесть в самой среде V-REP. Для этого нужно активировать прослушку порта в любом активном потоково зависимом скрипте (например дописав команду в имеющийся Lua-скрипт или добавив какой-нибудь примитив, тот же куб и прикрепив скрипт к нему). Давайте добавим куб на сцену как описано выше, оставим размеры по умолчанию (0.100 x 0.100 x 0.100). Выделите его на сцене, нажмите правую кнопку мыши и в контекстном меню выберите Add | Associated child script | Threaded. После чего рядом с именем нашего куба появится иконка зависимого скрипта и его настроек в иерархии сцены. В панеле Скрипты (Scripts) также появится соответствующий пункт. По нажатию на иконку скрипта в текстовом редакторе выведется стандартный каркас потоковых скриптов, в него же вам следует добавить строку открытия и активации порта на языке Lua. simExtRemoteApiStart(19999) Добавьте ее сразу после команды simSetThreadSwitchTiming(2), в результате получится следующее. Если на данном этапе попробовать запустить сцену, то ничего не произойдет. Осталось написать код влияющий на объекты сцены. Для этого вернитесь в папку нашего проекта и обратите внимание на скрипт simpleTest.py. Давайте изучим его содержимое: import vrep print ('Program started') vrep.simxFinish(-1) # just in case, close all opened connections clientID = vrep.simxStart('127.0.0.1',19999,True,True,5000,5) if clientID != -1: print ('Connected to remote API server') res,objs=vrep.simxGetObjects(clientID,vrep.sim_handle_all,vrep.simx_opmode_oneshot_wait) if res == vrep.simx_return_ok: print ('Number of objects in the scene: ', len(objs)) else: print ('Remote API function call returned with error code: ', res) vrep.simxFinish(clientID) else: print ('Failed connecting to remote API server') print ('Program ended') Попробуйте запустить его. Если сцена будет не запущенна, то вы получите соответсвующее уведомление в консоли, иначе скрипт подсчитает количество объектов на сцене. Разберемся в содержимом данного скрипта. Если вы владеете инструментом IPython, то можете последовательно строка за строкой вводить команды и изучать, что возвращают функции V-REP. Для начала импортируем модуль V-REP. Не забывайте, что он должен быть в текущей дириктории скрипта(для этого мы и копировали те файлы из папки programming), иначе Python не обнаружит его. import vrep Далее остановим другие соединения со сценой чтобы они не мешали логике нашего скрипта, если они конечно существуют. Для это есть функция simxFinish c аргументом -1. vrep.simxFinish(-1) Далее необходимо соединиться с удалённым сервером на том порту, что мы открыли в скрипте куба. Так как V-REP запущен у нас локально, то адрес 127.0.0.1. Согласно документации по Remote Api для Python (ссылка), аргументы данной функции обозначают следующее: clientID = vrep.simxStart('127.0.0.1', 19999, True, True, 5000, 5) connectionAddress: IP адрес, где сервер находится (тоесть адрес сервера с V-REP). connectionPort: Порт, с которым происходит соединение. waitUntilConnected: Если True, тогда функция блокируется на время соединения или пока не закончится время тайм-аута. doNotReconnectOnceDisconnected: Если True, тогда коммуникационный поток не будет пытаться переподсоединиться в случае потери соединения. timeOutInMs: Тайм-аут соединения в милисекундах (для первого соединения). commThreadCycleInMs: Указывает на то, как часто должен происходить обмен пакетами данных. Уменьшение этого числа повышает чувствительность, а в роли значения по умолчанию рекомендуется 5. В качестве возвращаемого значения clientID: идентификатор клиентского ID, или -1, если соедиение с сервером не возможно (в том числе по окончанию времени тайм-аута). Вызов simxStart всегда должен быть в паре с вызовом simxFinish, за исключением случая, когда соедиение не было выполнено (тоесть clientID = -1). Чему соответсвует следующая строка кода: vrep.simxFinish(clientID) После попытки установления соединения выполняется проверка на успешность, о чем сообщит соответсвующее сообщение. if clientID != -1: print ('Connected to remote API server') ... else: print ('Failed connecting to remote API server') Дальше скрипт запрашивает все объекты на сцене через функцию vrep.simxGetObjects. Согласно документации, которую вы можете изучить на официальном сайте (ссылка), функция получает хэндлы объектов определенного типа или, как в нашем случае, всех типов (vrep.sim_handle_all); последний аргумент означает, что после отправки команды функция будет ждать ответа от сервера и вернёт его, если не произойдет ошибки или будет превышенно время тайм-аута (vrep.simx_opmode_oneshot_wait). Остальные режимы можно посмотреть здесь. res, objs = vrep.simxGetObjects(clientID, vrep.sim_handle_all, vrep.simx_opmode_oneshot_wait) Функция возвращает 2 значения errorCode: код ошибки и objectHandles: массив хэндлов объектов. Далее следует проверка кода ошибки и в случае успеха — подсчет количества объектов на сцене: if res == vrep.simx_return_ok: print ('Number of objects in the scene: ', len(objs)) else: print ('Remote API function call returned with error code: ', res) При этом стоит заметить, что константа simx_return_ok соответсвует нулю (0). Отлично! После того как мы разобрались со значением функций, давайте, наконец, оживим нашу сцену. Для этого нам потребуется выполнить следующие действия в нашем собственном скрипте: Получаем clientID и закрываем остальные соединения, если таковые имеются. Проверяем получилось ли соединиться, если нет, то выводим сообщение и прекращаем работу. Поискав в документации, обнаруживаем функцию vrep.simxGetObjectHandle, с помощью которой можно получить хэндл нужного нам объекта (в нашем случае левого и правого колеса). Задаем ускорение (vrep.simxSetJointTargetVelocity) в случае успеха, что заставит нашего робота двигаться с нужным нам ускорением. В результате у вас выйдет подобный скрипт script1.py: import vrep import sys vrep.simxFinish(-1) clientID = vrep.simxStart('127.0.0.1', 19999, True, True, 5000, 5) if clientID!= -1: print(\"Connected to remote server\") else: print('Connection not successful') sys.exit('Could not connect') errorCode,left_motor_handle=vrep.simxGetObjectHandle(clientID,'Pioneer_p3dx_leftMotor',vrep.simx_opmode_oneshot_wait) errorCode,right_motor_handle=vrep.simxGetObjectHandle(clientID,'Pioneer_p3dx_rightMotor',vrep.simx_opmode_oneshot_wait) if errorCode == -1: print('Can not find left or right motor') sys.exit() errorCode=vrep.simxSetJointTargetVelocity(clientID,left_motor_handle,0.2, vrep.simx_opmode_oneshot_wait) errorCode=vrep.simxSetJointTargetVelocity(clientID,right_motor_handle,0.2, vrep.simx_opmode_oneshot_wait) Для функции simxGetObjectHandle помимо clientID указывается имя объекта, которое можно посмотреть в Иерархии сцены. errorCode, left_motor_handle = vrep.simxGetObjectHandle(clientID, 'Pioneer_p3dx_leftMotor', vrep.simx_opmode_oneshot_wait) Теперь если запустить сцену и активировать скрипт, наш робот начинает двигаться. Пробуя разные значения скоростей, или, например, задав скорость только одному колесу, можно заставить робота крутиться вокруг своей оси. Как видите, взаимодействовать со средой V-REP при помощи Python совсем не сложно, а благодаря большому функционалу можно создавать действительно сложные сценарии взаимодействия целых групп роботов и многое многое другое. Для вдохновления можете начать с изучения их демо-примеров.", "image": ["https://habrastorage.org/files/780/5fe/19e/7805fe19e40841e590867585770397fc.jpg", "https://habrastorage.org/files/139/33c/d93/13933cd9305846d38fdf6b808698b27e.png", "https://habrastorage.org/files/7df/aa4/4b2/7dfaa44b2dfb4b9f87ac2df22da43921.png", "https://habrastorage.org/files/d9c/105/594/d9c105594e2b4af193e1c7299f80f1c0.png", "https://habrastorage.org/files/9a4/b33/94b/9a4b3394b21e426a8078d26bf55b9e8a.png", "https://habrastorage.org/files/791/539/aff/791539affd1340c3ba4228f7fbe737fe.png", "https://habrastorage.org/files/cc0/4c2/b5c/cc04c2b5cab44c76a83215088aa5680f.png", "https://habrastorage.org/files/888/c49/1e0/888c491e05e748988dcb6d825944d76b.png", "https://habrastorage.org/files/20b/1f7/b52/20b1f7b525ba4591a9dc482cfd10b307.png", "https://habrastorage.org/files/559/089/78b/55908978b7d447258bfbc1b329e8a52e.png", "https://habrastorage.org/files/e82/3c0/9bc/e823c09bc7204ecba9c4c2e6c7e1ffe2.png", "https://habrastorage.org/files/b21/82b/50e/b2182b50ea954201a3481e5d2c691666.png", "https://habrastorage.org/files/a7a/34e/fb0/a7a34efb017d45d6ae1fbb26224fb977.png", "https://habrastorage.org/files/532/28e/2df/53228e2dfbce4f548fe9b03812c2995d.png", "https://habrastorage.org/files/f60/110/627/f60110627b3a4987b4664a38a435c828.png", "https://habrastorage.org/files/370/ecd/e5a/370ecde5a16a48bcbc7a3bf2bc59c2b5.png", "https://habrastorage.org/files/323/d81/15a/323d8115accf4fb990c0304745e19ef0.png", "https://habrastorage.org/files/377/454/991/377454991fb143ff815fd370a44c6339.png", "https://habrastorage.org/files/d58/6c6/f7b/d586c6f7b30248e981092d3127a26c41.png", "https://habrastorage.org/files/aea/261/565/aea261565aa546989709281cfce0b4e3.png", "https://habrastorage.org/files/960/8c2/c65/9608c2c653664b09b92701aed49fe55b.png", "https://habrastorage.org/files/b2d/4e0/ae5/b2d4e0ae569243ab875049add36b96de.png"], "tag": ["робототехника", "Python", "v-rep", "lua"], "rating": ["+7"], "bookmarks": ["57"], "views": ["12,4k"], "comments_count": ["2"]},
{"author": ["claygod"], "date": [" 4 марта 2016 в 09:09"], "hubs": ["Lua"], "type_label": [], "text": "Лучше маленькая рыбка, чем большой таракан. Русская поговорка Lua нравится всем, он простой, но не примитивный. Нет, скорее — продуманный, выверенный, оптимальный. Р.Иерузалимски (автор языка), в своей книге «Программирование на языке Lua» пишет: «Lua — это крошечный и простой язык». Это так. И ещё он скриптовый, переносимый, эффективный, расширяемый, склеивающий (glue). Как же такой не попробовать? Как и многие другие, я поддался искушению заглянуть, что же из себя представляет Lua. Ну а поскольку самый лучший способ изучить язык, это написать на нём программу, я решил набросать простой веб-микрофреймворк под сервер Apache (версии 2.3+). Апач выбран потому, что он есть на каждом хостинге, и вся настройка под Lua заключается во включении модуля mod_lua.so в конфигурации сервера. Это решение конечно, будет медленнее, чем на Nginx, но возможно, нам больше и не надо? Я с удовольствием прочитал первоапрельскую статью LUA в nginx: лапшакод в стиле inline php о создании сайта на Lua под Nginx в стиле раннего РНР. Как известно, в каждой шутке… До первого апреля я не дотянул, но пятница — тоже неплохо. Из написанной статьи можно сделать по крайней мере два однозначных вывода: на Lua можно разрабатывать сайты (или движки под них), сайты точно будут быстрыми. Приступая к написанию фреймворка, а он именно микро, я не был уверен, что это в принципе будет работать вообще. Было интересно и любопытно, тем более, что язык Lua мне был не знаком. Пришлось выучить язык и на ходу придумать, как его применить. Полученный за пару недель результат не претендует на большое и великое (и не рассчитан на использование в продакшене), но всё же надеюсь, что смогу внести малую лепту в популяризацию Lua в среде вебпрограммирования. Архитектура фреймворка Хотя слово архитектура и слишком громкое, тем не менее структура у фреймворка есть, и я попробую её описать. Со стартом происходит инициализация и запускается DI. С его помощью запускается Front — главный контролёр. Front получает от Request запрос, передаёт его в Router и получает имя контролёра. У контролёра есть несколько презентеров (например презентер статьи, меню и т.д.). Собрав ответы презентеров, контролёр возвращает ответ Front-у, а тот отправляет ответ на вывод. Всё достаточно просто и прозрачно. Front — самый главный, но сам он ничего не делает (работу делают презентеры). Контролёр (один из них), отвечает за то, какие презентеры будут на странице пользователя. Презентер должен выполнить свою миссию и дать ответ, содержащий название, описание и контент (можно ещё прикрутить дату, чтобы отдавать Last-Modified, так я по крайней мере делал в PHP). Что из ответа презентера использовать, а что нет, решает контролёр. Шаблонизация реализована нативно, поэтому с одной стороны — быстрая, с другой, требует разработки (каталог package/Demo/View/ пока пустой) Подробности Настроив файл htaccess так, чтобы все запросы шли на index.lua, в индексном файле мы должны обязательно создать функцию handle(r ), которая аргументом принимает таблицу request_rec, структуру её содержимого можно посмотреть тут: httpd.apache.org/docs/trunk/mod/mod_lua.html Получив запрос, можно дальше писать код по его обработке. (В роутере кстати на POST запросах и на GET запросах, не попавших в какой-нибуть роут пока стоят заглушки.) Мне показалось интересным использовать возможности Lua по созданию и использованию предкомпилированного кода. У такого подхода очевидный плюс в повышении быстродействия, ведь фаза предкомпиляции пропускается каждый раз при запуске программы. Ну и минус в том, что предкомпилированный файл напрямую не отредактируешь — надо править исходный код и компилировать файл заново. Программу можно заставить каждый раз сравнивать дату последнего изменения файлов, но для «быстрого» сайта это не совсем верное решение. Вариант с использованием мемкэша я пока не рассматриваю, оставлю на будущее. Для удобства, и наверное по привычке, код я организовал в псевдо-ООП стиле. Реализована инкапсуляция, наверно потому, что именно её я ценю больше всего (субъективно). Полиформизм не потребовался, а наследование сделаю тогда, когда это будет необходимо. Конечно, для маленького фреймворка, написанного для создания небольших сайтов, можно было бы обойтись и вовсе функциями, но как-то неудобно это, хотя и вполне возможно. Именование классов во фреймворке сделано классически: оно передаёт физическое расположение файла. Например класс CoreKernelRoute обозначает, что файл Route.lua располагается в подкаталоге Kernel пакета Core. Полный путь от корня сайта package/Core/Kernel/Route.lua Таким образом простой (да, тут всё простое и маленькое) иньектор зависимостей легко собирает все зависимые классы для создаваемого объекта и передаёт их ему в конструкторе. Список зависимостей хранится в файле system/dependency.lua Если требуется, чтобы объект был синглтоном, то его нужно прописать файле system/single.lua Демо Чтобы знакомство с фреймворком не означало простое прочтение статьи с не очень понятными пояснениями автора, я в фреймворк добавил примитивный модуль Demo, по которому можно понять и увидеть (если поместить дистрибутив на сервер) работу сайта. Все контролёры лежат в каталоге package/Core/Controller/ Все они, кроме Hello.lua используют презентер DemoPresenterArticle для генерации списка статей из демонстрационной базы DemoDataDb, а контроллёр Page также у этого презентера получает и контент конкретной статьи. Контроллёр Hello.lua — сделан именно как Hello world! — это самый короткий путь, который может проделать скрипт, при этом полностью задействовав своё ядро (если тестировать на максимальную скорость, то это именно эту страничку). Кстати, чтобы правильно работала главная страница, не забудьте в httpd.conf в разделе DirectoryIndex добавить index.lua Пример Допустим, вы хотите показывать время на главной странице. Для этого нужно создать презентер DemoPresenterTime с парой методов, возвращающих время на сервере в 24-х или 12-и часовом формате. Можно добавить и метод, возвращающий дату (название презентера это вполне подразумевает). Располагать его нужно по адресу package/Demo/Presenter/Time.lua DemoPresenterTime--[[ DemoPresenterTime --]] function genObj() local M = {} local L = {} --[===================[ Public methods --]===================] function M.doJob(route, event) event = event or 'Clock24' local exe_event = 'exe' .. event if L[exe_event] then local id_page = tostring(route.id_page) return L[exe_event](id_page) else return L.conf.Core.array_error_1 end end --[===================[ Private methods --]===================] -- Getting time 24 function L.exeClock24() return {title = \"Clock 24\", description = \"Time in 24-hour format\", content = os.date(\"%H:%M:%S\"), status = true} end -- Getting time 12 function L.exeClock12() return {title = \"Clock 12\", description = \"Time in 12-hour format\", content = os.date(\"%I:%M:%S\"), status = true} end return M end Теперь шаблон CoreTemplatePage сохраняем как CoreTemplateIndex — делаем индивидуальный шаблон для главной страницы. В нём добавляем {server_time} где-нибудь под меню. Если добавить {server_time} в CoreTemplatePage, то потребуется подключать презентер к каждому контроллёру, а в наших планах этого нет. В контролёре CoreControllerIndex добавляем за блоком с сайдбаром -- time res = L.obj.server_time.doJob(route, 'Clock24') tpl = string.gsub (tpl, '{server_time}', res.content, 1) И в файле system/dependency.lua для этого контроллёра подключаем новый презентер строкой server_time = 'DemoPresenterTime', Всё, презентер создан, и вы можете наблюдать на главной странице время сервера, что буден весьма «интересно» посетителю, особенно если ваш хостинг где-нибудь на другой стороне планеты :) Стиль Боюсь, что и на архитектуру, и на стиль оформления фреймворка слишком сильно повлиял мой предыдущий «опыт» написания скриптов на РНР. Записывать его в «бэст практик» не берусь. Но писать на Lua мне понравилось. Код получается лаконичный, количество скобочек небольшое, точки с запятыми в конце строк не нужны. Также мне показалось очень удобным использовать многострочные комментарии --[[ --]], достаточно поставить между пар скобок любой знак и блок кода вышел из комментариев, удалил — всё обратно в комментариях. Функции-классы возвращают объекты, которые по сути — замыкания. Мыслить такими замыканиями оказалось очень легко, хотя раньше я сторонился подобной практики. Но полагаю, глубинное восприятие Lua у меня ещё впереди, и возможно, ждёт вместе с корутинами и C API. Вообще, у Lua всё как-то на своём месте, что оставляет чёткое ощущение продуманности языка, без прикручивания забытой впопыхах детали (сугубо ИМХО, без холиварности). Lua и PHP Этот абзац никак не ради вброса топлива в огонь священных войн. Просто я немного писал на PHP и могу провести некую параллель. Хотя мне понравился Lua, это не значит, что он лучше PHP. Возможно, что мне просто хочется чего-то нового. Кроме того, при работе с PHP появилась привычка к подробнейшей высококачественной документации, огромному числу примеров, статей, разжевываний самых разных мелочей, вылизанным библиотекам и модулям, которым несть числа, и которые либо уже есть на самом заштатном хостинге, либо вам их подключат при первой необходимости. Если бы меня кто-то спросил, на чём писать большой и сложный проект, я бы сказал, что Lua мне нравится, но лучше пиши на PHP. Тем не менее, считаю, что Lua должен занять хоть и небольшую, но достаточно значимую нишу в вебстроительстве. Он быст, лёгок и прост, и если это всё, что нужно, то почему бы и нет? Кроме того, благодаря изначальному проектированию языка под интеграцию с Си, решению на основе Lua (и LuaJIT) вполне показана дорога на хайлоад. Мне кстати очень интересно было прочитать о возможности писать приложения на Lua в Tarantool. Сферический конь Любые самостоятельные бенчи лучше рассматривать относительно, поскольку настройка операционной системы, железо, могут сильно повлиять на результаты. Да и вообще, тестировать тоже надо уметь. Но в сравнении много чего становится понятно, во всяком влучае в категориях «быстрее-медленней», т.е. субъективных. На моём стареньком ХХХ компе показатели: главной страницы (2 презентера) ab -n 1000 -c 10 --> 622 r/s ab -n 1000 -c 100 --> 582 r/s article3.html (2 презентера) ab -n 1000 -c 10 --> 660 r/s ab -n 1000 -c 100 --> 634 r/s Hello world! (без презентеров, только контролёр) ab -n 1000 -c 10 --> 736 r/s ab -n 1000 -c 100 --> 727 r/s Для сравнения скорость работы простого r:puts(«Hello World!!!»), на Lua без фреймворка ab -n 1000 -c 10 --> 2210 r/s ab -n 1000 -c 100 --> 2067 r/s главная страница сайта, сделанного на PHP фреймворке, похожем по применённым архитектурным принципам, но немного сложнее устроенном (с некоей системой шаблонизации и т.д.) и с четырьмя статическими презентерами (т.е. презентер грузит статический контент — текст) не смотря на схожесть реализации на цифры прошу смотреть только краем глаза ab -n 1000 -c 10 --> 207 r/s ab -n 1000 -c 100 --> 187 r/s Общий вывод из поверхностного тестирования такой: фреймворк на инициализацию ядра тратит порядка миллисекунды, что естественно, не мало, но для обычного сайта эта величина весьма небольшая. Также он немного тратит и памяти: без фреймворка 25Кб, с фреймворком 61Кб, итого 36Кб (с ростом фреймворка цифра конечно будет расти). Учитывая, что фреймворк собирает с десяток разных файлов, думаю, результат можно назвать приемлемым. Эффективность предкомпиляции Сгенерировав предкомпилированные .ls файлы я смог посмотреть, насколько эффективно такое решение. Я пришёл к выводу, что эффект вырастает на больших файлах. Т.е. если бы код фреймворка был собран в одном файле, то это бы очень сильно повлияло на скорость работы. Предкомпиляция же маленьких файлов эффекта не даёт. В пакете Demo в качестве базы данных используется простая lua-таблица. Увеличив её до мегабайта, я увидел очень сильное влияние использования файла в предкомпилированном виде на скорость (не хочу тут приводить ещё одного сферического коня, но разница была на порядок). Я бы сказал, что для небольшого сайта (в смысле размера БД), вполне можно обойтись хранением данных в lua-таблице, без использования SQL, это конечно не панацея, но вполне дежурное решение. Ссылка на GutHub: github.com/claygod/Rumba", "image": ["https://habrastorage.org/getpro/habr/post_images/f22/c5b/4cb/f22c5b4cbe462cf831cdf16ef7c8a6af.png", "https://habrastorage.org/getpro/habr/post_images/550/97b/5a5/55097b5a52217fa3eb124b48b8164558.png"], "tag": ["lua"], "rating": ["+13"], "bookmarks": ["39"], "views": ["11,4k"], "comments_count": ["14"]},
{"author": ["rtsisyk"], "date": [" 9 декабря 2015 в 14:13"], "hubs": ["Высокая производительность", "NoSQL", "Lua", "Блог компании Mail.Ru Group"], "type_label": [], "text": "Привет, %хабраюзер%. Команда Тарантула продолжает делиться инсайтами и экспертизой для эффективной работы с данными в высоконагруженных проектах. Сегодня мы попытаемся разобраться, почему же Tarantool — это «два в одном»: не только база данных, но и сервер приложений. Наверное, некоторые слышали о Тарантуле как о сверхбыстром персистентном in-memory хранилище с поддержкой репликации и хранимок на Lua. Представьте, что мы берём кусочки Redis, добавляем замороженный Node.js, сверху заправляем Go, после чего варим, медленно перемешивая, в течение пяти минут после закипания. Казалось бы, при чём здесь Application Server? Многие, наверное, будут удивлены, но такие отличные продукты, как nginx, Go, Node.js, Redis, MongoDB, Tarantool и др., имеют много общего в архитектурном плане. Для создания любого высокопроизводительного сетевого сервера так или иначе требуется набор библиотек, обеспечивающий неблокирующий ввод-вывод, асинхронную обработку событий, работу с памятью, обработку ошибок, логирование, демонизацию и т. п. и т. д. Данный движок (runtime) обычно представляет собой достаточно сложную штуку, требующую глубокого понимания основ работы различных систем и навыков низкоуровневого программирования. Мы в команде Tarantool прошли очень длинный путь, создав свой runtime с асинхронной обработкой событий, неблокирующими I/O, зелёными тредами в user-space (файберами), кооперативной многозадачностью, семейством специализированных аллокаторов памяти и пр., и пр. Получилось что-то архитектурно больше всего похожее на Go (у глупцов мысли совпадают), но только в виде библиотек для чистого C. Благодаря данной основе «под капотом» удалось создать СУБД, которая сегодня способна обрабатывать до 6M запросов в секунду на одном ядре рядового ноутбука и имеет лучший memory footprint на рынке. В какой-то момент мы решили дать неограниченную свободу разработчикам приложений, разрешив в хранимых процедурах делать не только запросы к базе, но и использовать весь наш инструментарий по полной программе. Получить и распарсить JSON’чик по HTTP с облачного сервиса прямо из базы данных — легко. Запустить свой REST-сервис прямо в СУБД — пожалуйста. Сходить за данными на десяток серверов, параллельно обрабатывая запросы, — без проблем! Все возможности и инструменты в руки разработчиков! Developers, developers, developers! Как же в Tarantool сделать X, Y, Z? Наc очень часто спрашивают, есть ли в Tarantool очереди, expiration данных, pub/sub, multiget или ещё что-нибудь из сотен команд Redis’а. Нет, в Tarantool ничего этого нет, не было и не будет (сорян, котаны). Мы отказались от подобного пути и предлагаем немного другой подход. Как известно, дай человеку рыбу, и он будет сыт один день, научи его ловить рыбу, и он будет сыт всегда. Tarantool предоставляет инструменты («удочку»), с помощью которых можно решать различные задачи, в том числе и выходящие из разряда шаблонов и паттернов. Автоматическое удаление старых данных — фоновый файбер на Lua. Multiget из нескольких таблиц по определённому условию — две строчки Lua. Отдача данных в формате JSON — загрузить модуль веб-сервера прямо в базу данных. Think out of the box! Посмотрим, что же за инструменты предоставляет Tarantool: fiber — кооперативная многозадачность и каналы (как в Go); socket, fio — асинхронный неблокирующий сокетный и файловый ввод-вывод; json/msgpack/yaml — упаковщики-распаковщики данных; mysql/pg/whatever — клиенты к MySQL, PostgreSQL из самого Тарантула; net.box — клиент к Тарантулу из самого Тарантула; http — примитивный HTTP сервер и клиент; tap — тестирование для приложений и модулей; console — инспектирование состояния сервера, горячая загрузка кода, изменение настроек на лету; log — логирование событий, logrotate; init-скрипты, RPM/DEB-пакеты, средства развертывания и др. В роли вишенки на торте выступает box — супербыстрая multi-engine база данных с поддержкой транзакций и multi-master репликации, работающая прямо в том же адресном пространстве, что и приложения. Занимательно, но у нас же трёхуровневая архитектура? «Неужели опять предлагается переносить всю бизнес-логику в базу данных, вместо отдельного application server (Node.js, PHP, Python, whatever) и СУБД (Redis, MongoDB и т. п.)?» — резонно возразите вы. Нет, мы не покушаемся на основы мироздания. Давайте лишь посмотрим чуть более прагматично. Во времена, когда космиче приложения можно писать уже прямо в браузере, серверная часть остаётся по большей мере для хранения и обработки данных, тогда как браузер может запрашивать и обновлять всю необходимую информацию динамически через AJAX. Что же в таком раскладе делает ваш application server (PHP/Node/Go/Python)? Простаивает в ожидании ответа от базы, чтобы потом сразу отдать всё это в виде JSON в nginx? А ведь надо открыть транзакцию, после этого по сети выкачать данные из базы, поменять в них какие-то поля в application server, послать обновления обратно в базу данных, закрыть транзакцию и вернуть результат в nginx. Сколько лишних сетевых round trip и переключений userspace <-> kernel <-> userspace мы при этом потратим? А ещё ведь база данных должна на каждую открытую транзакцию поддерживать для вас целостный read-view данных, например ценой использования локов или других, не менее тяжеловесных механизмов. И всё это ради того, чтобы выбрать пять записей из одной таблички, обновить две записи в другой и вернуть результат в наш REST-сервис? Для подобного рода микросервисов Тарантул предлагает удоч написать хранимку прямо рядом с самими данными, внутри СУБД. Модуль tarantool-http и nginx_tarantool_upstream легко организуют REST-сервис из Тарантула, упрощая архитектуру сервиса и убирая лишнее звено в виде выделенного application server. При этом никто не предлагает таким образом переписывать всё приложение, ведь можно выделить в микросервис лишь самые нагруженные части проекта, где запаса производительности традиционных решений уже не хватает. Для остального можно использовать тот же Tarantool как СУБД общего назначения через коннекторы из различных языков программирования. Прекрасно, но там же Lua?! «Мы не умеем писать на Lua! Да и где же взять таких программистов?» — спросите вы. Don’t panic! Lua (португ. луна) — простой как три копейки язык, не требующий для работы изучать собрание сочинений авторов в десяти томах. Посмотрели на примеры вместо просмотра рекламы в метро — и уже можно начинать грабить коро кодить. В Mail.Ru Group процедурки на Lua одинаково успешно пишут как программисты на C/C++, так и Python-, Perl-, Ruby- и JS-девелоперы. Но почему же Lua? Tarantool даёт разработчику настоящий Тьюринг-полный язык программирования высокого уровня, позволяющий решать любые задачи. Скажем своё твёрдое железное нет программированию на PL/SQL, XML, YAML и ini-файлах (прости господи). Кроме того, Lua крайне простой и очень быстро работает. С Lua нет споров о том, какие же 10% функциональности языка разрешить использовать в проекте. Кстати, Tarantool также имеет сишный API, что позволяет достигать невиданной ранее производительности и, в теории, возможности использовать любые другие языки. Мы расскажем об этом подробнее в следующих сериях, не отключайтесь. А давайте-ка попробуем! Устанавливаем Tarantool со страницы tarantool.org/download.html. В репозиториях на сайте есть бинарные пакеты под основные Linux-дистрибутивы, а также порты для FreeBSD и brew для OS X. После установки вводим в консольке команду tarantool, которая по умолчанию запускает интерактивную консоль (как Python, Node, irb и др.): roman@book:~$ tarantool tarantool: version 1.6.8-123-gbe2ce21 type 'help' for interactive help tarantool> В интерпретаторе можно вводить произвольный Lua-код, а результат выполнения будет выведен в читабельном формате (YAML) в консольку: tarantool> 2 + 2 --- - 4 ... tarantool> { name = \"Roman\", gender = \"male\" } --- - name: Roman gender: male ... tarantool> print('Hello') Hello --- ... Всё то же самое можно написать в виде скриптика в отдельном файле: #!/usr/bin/env tarantool print(‘Hello world!’) Запускаем скрипт аналогично Bash, Python или Ruby: roman@desktop:~$ edit ololo.lua roman@desktop:~$ chmod a+x ololo.lua roman@desktop:~$ ./ololo.lua Hello world! Tarantool полностью совместим с Lua 5.1 и LuaJIT на уровне скриптов и может использоваться как drop-in replacement. Все модули от Lua работают в Tarantool. Функция box.cfg{} конфигурирует и запускает встроенную базу данных (box), после чего можно создавать таблицы (space) и выполнять запросы: tarantool> box.cfg {} [cut] tarantool> space = box.schema.space.create('test') [cut] tarantool> box.space.test:create_index('primary', { type = 'tree', parts = { 1, 'num' }}) [cut] tarantool> box.space.test:insert({48, 'some data', { key = 'value', key2 = 'value2' }}) --- - [48, 'some data', {'key': 'value', 'key2': 'value2'}] ... tarantool> box.space.test:select() --- - - [48, 'some data', {'key': 'value', 'key2': 'value2'}] ... Если же теперь остановить интерактивную консоль (через CTRL+D или os.exit(0)), то в каталоге можно увидеть новые файлы *.snap, *.xlog. Данные файлы используются для обеспечения persistence нашей базы данных в оперативной памяти. Повторный же запуск tarantool восстановит все данные: tarantool> box.cfg{} --- ... tarantool> box.space.test:select() --- - - [48, 'some data', {'key': 'value', 'key2': 'value2'}] ... А теперь попробуем что-нибудь более сложное (пример с главной страницы): #!/usr/bin/env tarantool box.cfg{} -- Создаёт таблички при первом запуске box.once('schema', function() box.schema.create_space('hosts') box.space.hosts:create_index('primary', { type = 'hash', parts = {1, 'str'} }) end) -- Обработчик GET-запросов к / local function handler(self) -- Получаем IP-адрес клиента local ipaddr = self.peer.host -- Вставляем новую запись для адреса или инкрементируем существующую box.space.hosts:upsert({ ipaddr, 1 }, {{'+', 2, 1}}) -- Возвращаем все записи в виде JSON клиенту return self:render{ json = box.space.hosts:select() } end local httpd = require('http.server') local server = httpd.new('127.0.0.1', 8080) server:route({ path = '/' }, handler) server:start() Для запуска необходим модуль tarantool-http, который можно поставить из пакетов или из GitHub. Скрипт при первом запуске создаст таблицу hosts, после чего будет запущен HTTP-сервер, который на `/` будет инкрементировать counter для каждого IP-адреса и возвращать клиенту все адреса в формате JSON. Так же легко можно поставить перед сервисом nginx. Кстати, try.tarantool.org написан на самом Tarantool. Мы сами кушаем свои кактусы и стараемся делать жизнь разработчиков лучше. Выкатываем на production Как же лучше разместить наше простенькое приложение на рабочем сервере? Ведь одно дело в консольках поиграться, и совсем другое — запустить всё это в бой. Всё просто. Переносим скриптец в /etc/tarantool/instances.enabled/myapp.lua и запускаем уже через готовые утилиты для init (tarantoolctl start myapp или даже service tarantool restart). Работает! Просто? Приложений можно сделать сколько угодно много, init-система сама будет запускать нужное количество демонов Tarantool и следить за ними. Мы рекомендуем запускать чуть меньше тарантулов, чем вы имеете физических ядер. Данный подход позволит обеспечить наилучшие показатели производительности на один сервер и сэкономить миллионы долларов. В списке процессов легко можно найти демон с именем вашего приложения. Log-файлы по умолчанию пишутся в /var/log/tarantool/myapp.log, данные хранятся в /var/lib/tarantool/myapp/, а pid-файл пишется в /run/tarantool. Иными словами, всё именно так, как задумано в вашем любимом дистрибутиве. Для сборки RPM- и DEB-пакетов можно воспользоваться нашим шаблоном. Из полезного стоит отдельно отметить команду tarantoolctl enter myapp, которая позволяет подключаться консолькой к работающему демону для интроспекции состояния и изменения кода на лету. Также через box.cfg({listen = 3313 }) можно открыть сетевой порт для подключения коннекторами из других языков программирования и фреймворков (мы же вам обещали, что не будем ломать всё мироустройство!). Что далее? В следующих сериях мы расскажем более подробно, как обеспечить модульную архитектуру вашего приложения, организовать тестирование и непрерывную интеграцию кода. Также будет раскрыто секретное know-how по приготовлению Тарантула для обработки до 6М запросов в секунду на одном физическом ядре (seriously). Ждём вопросов и комментариев. З. Ы. 28 января мы проводим второй Tarantool Meetup в суперсовременном офисе Mail.Ru Group на м. Аэропорт. На встрече будут новые инсайты как от нашей команды, так и от внешних пользователей Тарантула. Вход бесплатный после регистрации, все ништяки включены. С вас хорошее настроение и желание попробовать Tarantool в своих проектах.", "image": ["https://habrastorage.org/files/324/120/7b1/3241207b147d439095581566628e28ef.jpg", "https://habrastorage.org/files/026/3a1/426/0263a1426aa8404eaf30d807aeae326e.jpg", "https://habrastorage.org/files/15f/325/d2d/15f325d2d8134502992bbdee726a280b.jpg", "https://habrastorage.org/files/703/4df/89b/7034df89b5d14d6cbc67377cffd64c00.jpg", "https://habrastorage.org/files/c45/903/3d4/c459033d4ee24556b4f5e245e8d30306.jpg", "https://habrastorage.org/files/679/cef/82b/679cef82bffa4914ab7f76ec6f974130.jpg"], "tag": ["mail.ru", "tarantool", "lua"], "rating": ["+57"], "bookmarks": ["136"], "views": ["21,2k"], "comments_count": ["58"]},
{"author": ["forewar"], "date": [" 3 марта 2015 в 00:21"], "hubs": ["Разработка под iOS", "Разработка под Android", "Разработка мобильных приложений", "Lua"], "type_label": [], "text": "Создатели известного движка для разработки кроссплатформенных мобильных приложений Corona SDK 2 марта объявили о том, что отныне Corona SDK будет бесплатна. Четыре месяца назад, в ноябре 2014 Corona была куплена компанией FusePowered. Многие предрекали грядущие изменения в политике компании и в выборе путей ее развития. Вопрос был, в какую сторону будут эти изменения. И вот сегодня случилось — Корона объявила, что возможности, доступные раньше только в платных подписках, теперь будут бесплатны. Разберемся, что же они теперь нам предлагают. Раньше подписки на Корону выглядели следующим образом: Бесплатной была версия Starter и предоставляла действительно очень базовые возможности (впрочем, на большую часть функционала их хватало). Теперь все возможности подписок Starter, Basic и Pro объединены в одну и доступны бесплатно сразу после регистрации. Подписки Enterprise по-прежнему платные, но они позиционируются уже не как Corona SDK, а как Corona Enterprise. Пользователям, которые уже имеют аккаунт, достаточно перелогиниться в Corona Simulator, чтобы обновить свой статус. Делается это следующим образом: 1. Запускаем Corona Simulator 2. Переходим в File -> Preferences 3. Жмем кнопку Deauthorize and Quit и перезапускаем Corona Simulator, чтобы залогиниться заново 4. При запуске вводим свой имейл и пароль 5. Наблюдаем окно с подпиской Pro В завершении стоит отметить, что Корона не единственная из кроссплатформенных мобильных движков открывает двери к платным прежде функциям. Например, Unreal Engine тоже 2 марта объявил, что теперь он доступен для всех бесплатно. Конкуренция на рынке мобильных движков заставляет компании все сильнее бороться за разработчиков, создающих комьюнити. Всем успехов в разработке!", "image": ["https://habrastorage.org/files/e21/817/01b/e2181701b3794b8cadf0c80fbaf101b0.png", "https://habrastorage.org/files/457/cb4/823/457cb4823ff34e7d9903bc57aadc275e.png", "https://habrastorage.org/files/106/4ae/a31/1064aea319414fb19958b523b84eef7a.png", "https://habrastorage.org/files/869/14a/c6c/86914ac6cd4341329013d06f87d8ba0e.png", "https://habrastorage.org/files/08b/2c0/8b7/08b2c08b72234f2c9dd478d2affe7336.png"], "tag": ["Corona SDK", "Lua", "мобильная разработка", "кроссплатформенная разработка"], "rating": ["+24"], "bookmarks": ["172"], "views": ["29,8k"], "comments_count": ["19"]},
{"author": ["e-sha"], "date": ["31 марта 2015 в 18:12"], "hubs": ["NoSQL", "Lua", "Блог компании Mail.Ru Group"], "type_label": [], "text": "Не так давно на Хабре была опубликована статья о NoSQL базе — «Tarantool 1.6 от первого лица». Уверен, в своих кругах эта база данных отлично известна и уже завоёвывает популярность. Уверен так же и в том, что есть те начинающие, руки не дошли, кто хотел бы попробовать Tarantool в действии. Именно для таких желающих я приведу несколько простых примеров, помогающих начать знакомиться с этим интересным продуктом. Как понятно из названия статьи — речь идет о версии Tarantool 1.6. Install На сайте проекта подробно описаны варианты установки для разных систем. Для Ubuntu выглядит так: wget http://tarantool.org/dist/public.key sudo apt-key add ./public.key release=`lsb_release -c -s` cat > /etc/apt/sources.list.d/tarantool.list <<- EOF deb http://tarantool.org/dist/master/ubuntu/ $release main deb-src http://tarantool.org/dist/master/ubuntu/ $release main EOF sudo apt-get update sudo apt-get install tarantool Hello world! Tarantool использует Lua в качестве встроенного языка (Lua 5.1 на базе on LuaJIT 2.0). Язык lua не сложный, быстро познакомиться с его основами можно здесь или на Хабре в публикации «Lua за 15 минут». Вы можете использовать Tarantool как Lua интерпретатор. $ /usr/bin/tarantool /usr/bin/tarantool: version 1.6.4-509-ga4af00e type 'help' for interactive help tarantool> 2 + 3 --- - 5 ... tarantool> print ('Ola lua!') Ola lua! --- ... Так же вы можете писать свою логику, используя скрипты на Lua. Напишем стартовый init.lua для запуска Tarantool и вывода 'Hello world'. Одна из основных библиотек tarantool — box. С помощью box.cfg (в lua {...} — это таблица) создадим конфигурацию запуска: box.cfg { listen = 3311, logger = 'tarantool.log', } Tarantool будет запущен на порт 3311 и будет хранить логи в tarantool.log: Создадим функцию hello() local function hello() print ('Hello world!) end hello() Запускаем и видим: $ tarantool init.lua Hello world! Data Base В tarantool кортежи хранятся в пространствах (space) — некий аналог таблицы. Создадим тестовый space и первичный (primary) индекс в нем (можно также строить и вторичный по всем полям записи), используя дерево для хранения индексов: s = box.schema.space.create('test') p = s:create_index('primary', {type = 'tree', parts = {1, 'NUM'}}) Заполним test записями вида {key, number}: for i = 1, 10 do s:insert({i, i}) end В данном случае объект s ссылка на объект box.space.test. Соответственно, можно было записать: box.space.test:insert({i, i}) Кстати, вы можете столкнуться с такой ошибкой при повторном запуске tarantool: $ tarantool init.lua Hello world! main/101/init.lua F> Space 'test' already exists Tarantool хранит все свои данные в оперативной памяти. Для их сохранности Tarantool делает снимки состояний (snapshot) и бинарные логи (xlog). Ошибка возникает из-за того, что при старте Tarantool загружает данные с последнего использования с помощью файлов .snap (снимки состояния) и .xlog (по умолчанию в рабочей директории). Соответственно, ваш test space уже присутствует в базе. Вы можете удалять .snap и .xlog при каждом запуске, или же добавить проверку существования пространства. s = box.space.test if not s then s = box.schema.space.create('test') p = s:create_index('primary', {type = 'tree', parts = {1, 'NUM'}}) for i = 1, 10 do s:insert({i, i}) end end Было бы очень неплохо проверить, сохранились ли наши данные, наша конфигурация в запущенном Tarantool. Для этого предусмотрена консоль для администратора. Вообще, в lua реализация подключения различных модулей, встроенных пакетов, других файлов с кодом происходит через механизм require. local console = require('console') console.listen(127.0.0.1:3312) После запуска Tarantool вы сможете подключится к админской консоли на порту 3312 с использование утилит nc/telnet и rlwrap (для удобства работы). Подключившись, вы можете напрямую работать с Tarantool. Посмотрим, к примеру, данные нашего пространства test: $ rlwrap nc 0 3312 Tarantool 1.6.4-509-ga4af00e (Lua console) type 'help' for interactive help box.space.test:select() --- - - [1, 1] - [2, 2] - [3, 3] - [4, 4] - [5, 5] - [6, 6] - [7, 7] - [8, 8] - [9, 9] - [10, 10] ... box.space.test:get(6) --- - [6, 6] ... Посмотрим параметры конфигурации нашего Tarantool: box.cfgbox.cfg --- - snapshot_count: 6 too_long_threshold: 0.5 slab_alloc_factor: 2 slab_alloc_maximal: 1048576 background: false logger: tarantool.log slab_alloc_arena: 1 sophia: page_size: 131072 threads: 5 node_size: 134217728 memory_limit: 0 listen: '3311' logger_nonblock: true snap_dir: . coredump: false sophia_dir: . wal_mode: write slab_alloc_minimal: 64 panic_on_snap_error: true panic_on_wal_error: true rows_per_wal: 500000 wal_dir: . log_level: 5 readahead: 16320 snapshot_period: 0 wal_dir_rescan_delay: 0.1 ... Итак, создав space выполним следующую задачу: в записях с ключом > 5 увеличим значение хранимого чиcла на 10. Для нужной выборки воспользуемся библиотекой box.index. for k,v in box.space.test.index.primary:pairs(5, {iterator = box.index.GT}) do s:update(v[1], {{'=', 2, v[2] + 10}}) end box.space.index.primary — означает работу с пространством test и его primary индексом. pairs() — функция итерирования, возвращающая итератор (переменная k в цикле) и таблицу значений (состоит из набора записей v), принимает на вход значение ключа(5) — старта итерирования и тип итератора. iterator = box.index.GT — итератор GT (greater) возвращает записи с ключами, больше заданного. update() — обновление записи в базе, принимает значение ключа записи (v[1]), {' = ', 2, v[2] + 10} — обозначает обновление ('=') второго значения на v[2] + 10. Посмотрим, используя админскую консоль, значения нашего space: box.space.test:select() --- - - [1, 1] - [2, 2] - [3, 3] - [4, 4] - [5, 5] - [6, 16] - [7, 17] - [8, 18] - [9, 19] - [10, 20] ... Общий код нашего init.lua скрипта:-- Пример init cкрипта для tarantool -- Подключение всех необходимых в скрипте модулей -- удобно описывать в начале local console = require('console') -- Стартуем админскую консоль console.listen('127.0.0.1:3312') -- Конфигурация tarantool box.cfg { listen = 3311, logger = 'tarantool.log', } local function hello() print ('Hello world!') end -- Запуск функции hello hello() -- Создаем и заполняем тестовый space, если он отсутствует s = box.space.test if not s then s = box.schema.space.create('test') -- Первичный индекс p = s:create_index('primary', {type = 'tree', parts = {1, 'NUM'}}) for i = 1, 10 do s:insert({i, i}) end end -- Увеличим хранящиеся значения во всех записях, где первичный ключ больше 5 for k,v in box.space.test.index.primary:pairs(5, {iterator = box.index.GT}) do s:update(v[1], {{'=', 2, v[2] + 10}}) end Конечно, чтобы полноценно освоить Tarantool, знать его тонкости, нужно читать документацию на сайте проекта. Ведь помимо всего Tarantool — это не только база данных, но еще и lua application server. К примеру, есть http сервер и очереди. Но первый шаг сделан — свой маленький скрипт для Tarantool вы написали. Еще вы можете почитать про Tarantool (в примерах там более старые версии проекта) в других статьях на Хабре: «Изучаем Tarantool + Lua», «Уникальные возможности Tarantool». Так же без всякой установки вы можете попробовать Tarantool на try.tarantool.org.", "image": [], "tag": ["tarantool", "nosql", "lua"], "rating": ["+25"], "bookmarks": ["118"], "views": ["32k"], "comments_count": ["5"]},
{"author": ["customizer"], "date": ["31 октября 2015 в 18:52"], "hubs": ["Lua"], "type_label": [], "text": "Перевел на русский язык «Lua 5.3 Справочное руководство». Его chm-версию можно взять на файлообменнике. Собственно, переводил для себя, поэтому в текст оригинального руководства понаставил множество примечаний, как во всплывающих окнах, так и в виде текстовых вставок (со спойлерами и без них) мелким серым шрифтом на желтоватом фоне. Я не программист, базовых знаний у меня нет, так что везде, где «спотыкался» на терминах, старался таким образом облегчить себе понимание. Кроме того, для тех, кто, возможно, захочет что-то изменить, вложил в архив файлик Lua5.3.hhp — чтобы любой мог разобрать/собрать chm-файл программой HTML Help Workshop. Ну и наконец, я не знаю английского языка, переводил в основном онлайновыми программами перевода (с помощью программы QTranslate).", "image": ["https://habrastorage.org/files/2f1/59d/fcb/2f159dfcb7a24845a7531a77304b1422.png"], "tag": ["Lua"], "rating": ["+11"], "bookmarks": ["95"], "views": ["13k"], "comments_count": ["9"]},
{"author": ["santeri"], "date": ["29 мая 2015 в 20:54"], "hubs": ["Программирование", "Lua"], "type_label": [], "text": "Привет, я придумал свой велосипед для реализации прототипного подхода ООП в Lua. Основные фишки Single inheritance Traits LuaJIT Перейдем сразу к примерам. -- подключаем модуль local object = require(\"object\") -- определяем наш класс, который на самом деле объект local HelloClass = object:extend(function(class) -- конструктор (необязательно) function class:init(name) self.name = name end -- метод класса function class:sayHello() print(\"Hello \" .. self.name) end end) local hello = HelloClass:new(\"John\") hello:sayHello() Как видим, вся магия заключается в методе extend(traits..., f), который расширяет текущий объект. Можно определять переменные внутри local object = require(\"object\") local Status = object:extend(function(status) status.HTTP_200_OK = {200, \"OK\"} status.HTTP_405_METHOD_NOT_ALLOWED = {404, \"Method not allowed\"} end) print(Status.HTTP_200_OK[2]) Статические методы Куда же без них… local object = require(\"object\") local MathUtils = object:extend(function(class) function class.square(x) return x * x end end) -- вызываем статический метод print(MathUtils.square(10)) -- вызывает тот же метод но уже через инстанс print(MathUtils:new().square(10)) -- 100 Конструктор При создании нового экземпляра через new() вызывается конструктор init() local Counter = object:extend(function(class) -- конструктор, который принимает какой-то параметр (может быть много параметров) function class:init(initial) self.ticks = initial or 0 end function class:tick() self.ticks = self.ticks + 1 end function class:getTicks() return self.ticks end end) local c = Counter:new() c.tick() c.tick() print(c:getTicks() == 2) Наследование и перегрузка методов Как я упомянул, наследование сделано как single inheritance, то есть отнаследоваться можно только от одного «класса», однако есть еще трейты, о которых поговорим чуть позже. Перегрузка методов не вызывает никаких вопросов. local Shape = object:extend(function(class) function class:getArea() return 0 end end) local Square = Shape:extend(function(class) function class:init(side) self.side = side end -- перегружаем метод function class:getArea() return self.side * self.side end end) local sq = Square:new(10) print(\"Area = \" .. sq:getArea()) Вызов родительского метода Для этого надо использовать второй параметр лямбда-функции, которую передаете в extend, которая есть ссылка на родительский объект (который хотим расширить) local Foo = object:extend(function(class) function class:init(value) self.value = value end function class:say() print(\"Hello \" .. self.value) end end) class Bar = Foo:extend(function(class, parent) function class:init(value) -- вызывает конструктор родителя parent.init(self, value) end end) local foo = Foo:new(\"World\") foo:say() -- напечатает \"Hello World\" local bar = Bar:new(\"World\") bar:say() -- напечатает \"Hello World\" Трейты Когда не хватает множественного наследования как в С++, можете воспользоваться трейтами, которые расширяют функционал. Просто передайте ваши трейты в начало аргументов extend() local TraitX = function(trait) function trait:setX(x) self.x = x return self end function trait:getX() return self.x end end local A = object:extend(TraitX, function(class) function class:say() print(self.x) end end) A:new():setX(10):say() Полезные функции is_instanceof(self, instance) — вернет true, если instance является прямым или непрямым наследником self local ClassA = object:extend() local ClassB = object:extend() local obj_a = ClassA:new() local obj_b = ClassB:new() print(obj_a:is_instanceof(ClassA)) -- true print(obj_a:is_instanceof(object)) -- true print(obj_a:is_instanceof(ClassB)) -- false is_typeof(self, instance) — вернет true, если instance является прямым наследником self local ClassA = object:extend() local ClassB = object:extend() local obj_a = ClassA:new() local obj_b = ClassB:new() print(obj_b:is_typeof(ClassA)) -- false print(obj_b:is_typeof(ClassB)) -- true LuaJIT Как альтернатива, поддерживается работа в LuaJIT. Где код, Карл? Здесь", "image": [], "tag": ["lua", "luajit", "буханка и тролейбус"], "rating": ["+10"], "bookmarks": ["52"], "views": ["9k"], "comments_count": ["4"]},
{"author": ["Perkovec"], "date": ["13 августа 2015 в 11:47"], "hubs": ["Программирование", "Разработка мобильных приложений", "Lua", "Разработка игр"], "type_label": ["Tutorial"], "text": "Давненько была статья про Gideros (разработка игр на LUA), но продолжения я так и не нашел. Поэтому сделал небольшую статейку о том, как разрабатывать игры на Gideros Studio. Исходники и апкшник проекта в конце статьи. Продолжение под катом. Установка Все предельно просто, переходим по этой ссылке и скачиваем необходимый установочник. В моем случае Gideros 2015.08 для OS X. Теперь стандартная процедура перетаскивания приложения в Application. Переходим в приложения и открываем Gideros Studio: Начальный экран Делаем простую игру Начнем мы с классики, напишем «Hello, world!» на экране. Для начала создадим проект: 1. Нажимаем «Create New Project»: 2. Вводим название проекта (в моем случае «Hi»): 3. Создаем файл для нашего скрипта: Ну и обещанный «Hello, world!»: Код-- application:getDeviceHeight() - высота экрана -- application:getDeviceWidth() - ширина экрана -- textfield:getWidth() - ширина спрайта, т.е. текста -- textfield:getHeight() - высота спрайта, т.е. текста local half_height = application:getDeviceHeight() / 2 local half_width = application:getDeviceWidth() / 2 local textfield = TextField.new(nil, \"Hello, world!\") textfield:setX(half_width - textfield:getWidth() / 2) textfield:setY(half_height - textfield:getHeight() / 2) stage:addChild(textfield) Нажимаем на джойстик и у нас запускается Gideros Player: Скрины Теперь нажимаем на синий треугольник и в плеере запускается наш скрипт. Скрины Чтобы остановить выполнение проекта нажмите на красный восьмиугольник. Теперь сделаем что-нибудь серьезнее. Например, подобие Angry Birds. 1. Подготовка: Нам понадобится SceneManager для переключения между уровнями. Берем его отсюда, нам нужны файлы scenemanager.lua и easing.lua. Загружаем их в наш проект (для удобства скопируйте его в папку проекта) при помощи «Add Existing Files...»: И выбираем наши скрипты из папки проекта. Теперь подготовим необходимые нам изображения, проделайте ту же самую процедуру как и со скриптами. Берем их отсюда: bg.png — yadi.sk/i/LLZpkzBliRDD9 buttons.png — yadi.sk/i/96GChQSAiRDCz props.png — yadi.sk/i/JaM6n6ZqiRDD7 spritesheet.png — yadi.sk/i/n6siot0LiRDHV 2. Just do it! Создаем скрипт main.lua, который у нас служит для запуска уровня: Кодapplication:setOrientation(application.LANDSCAPE_LEFT) sceneManager = SceneManager.new({ [\"level\"] = level }) stage:addChild(sceneManager) --start level scene sceneManager:changeScene(\"level\", 1, SceneManager.flipWithFade, easing.outBack) Теперь создаем наш главный скрипт с уровнем level.lua: Код-- Add box2d physics library require \"box2d\" level = Core.class(Sprite) function level:init() application:setOrientation(Application.LANDSCAPE_LEFT) local spritesheet = Texture.new(\"spritesheet.png\") local props = Texture.new(\"props.png\") local buttons = Texture.new(\"buttons.png\") self.world = b2.World.new(0, 10, true) -- Globals for followed camera self.screenW = application:getContentWidth()*2 self.screenH = application:getContentHeight() -- Add sprites self.catapult_l = Bitmap.new(TextureRegion.new(spritesheet, 834, 1, 43, 124)) self.catapult_r = Bitmap.new(TextureRegion.new(spritesheet, 3, 1, 37, 199)) self.bird_idle = Bitmap.new(TextureRegion.new(spritesheet, 903, 798, 46, 44)) self.bg_image = Texture.new(\"bg.png\", true, {wrap = Texture.REPEAT}) self.square_prop = Bitmap.new(TextureRegion.new(props, 0, 1, 84, 84)) self.triangle_prop = Bitmap.new(TextureRegion.new(props, 85, 1, 85, 83)) self.restart = Bitmap.new(TextureRegion.new(buttons, 580, 295, 108, 108)) -- Change scale of sprites self.bird_idle:setScale(0.6, 0.6, 0.6) setHalf({self.catapult_r, self.catapult_l, self.square_prop, self.triangle_prop, self.restart}) -- Create background local bg = Bitmap.new(self.bg_image) bg:setPosition(0, 0); local bg1 = Bitmap.new(self.bg_image) bg1:setPosition(bg:getWidth(), 0); -- Add ground collision self:wall(application:getContentWidth(), application:getContentHeight() - 20, application:getContentWidth()*2, 40) -- Add props physics local square_body = self.world:createBody{type = b2.DYNAMIC_BODY} local square_shape = b2.PolygonShape.new() square_shape:set(0, 0, self.square_prop:getWidth(), 0, self.square_prop:getWidth(), self.square_prop:getHeight(), 0, self.square_prop:getHeight()) local square_fixture = square_body:createFixture{shape = square_shape, density = 1.0, friction = 0.1, restitution = 0.2} self.square_prop.body = square_body local triangle_body = self.world:createBody{type = b2.DYNAMIC_BODY} local triangle_shape = b2.PolygonShape.new() triangle_shape:set(self.triangle_prop:getWidth() / 2, 0, self.triangle_prop:getWidth(), self.triangle_prop:getHeight(), 0, self.triangle_prop:getHeight()) local triangle_fixture = triangle_body:createFixture{shape = triangle_shape, density = 1.0, friction = 0.1, restitution = 0.2} self.triangle_prop.body = triangle_body -- Place catapult self.catapult_r:setPosition(100, 178) self.catapult_l:setPosition(85, 174) -- Place bird self.bird_idle:setAnchorPoint(.5, .5) self.bird_idle:setPosition(100, 190) self.start_x, self.start_y = self.bird_idle:getPosition() -- Place props self.square_prop.body:setPosition(600, 200) self.triangle_prop.body:setPosition(600, 150) -- Place restart buttons self.restart:setAnchorPosition(0, 0) self.restart:setPosition(10, 10) self.restart:addEventListener(Event.MOUSE_DOWN, restartDown, self) self.restart:addEventListener(Event.MOUSE_UP, restartUp, self) -- Create elastic band for catapult local onBirdBandX = self.bird_idle:getX() - self.bird_idle:getWidth() / 2 local onBirdBandY = self.bird_idle:getHeight() / 2 self.band_l = Shape.new() self.band_l:setFillStyle(Shape.SOLID, 0x382E1C) self.band_l:beginPath(Shape.NON_ZERO) self.band_l:lineTo(onBirdBandX + 4, self.bird_idle:getY() - onBirdBandY + 5) self.band_l:lineTo(onBirdBandX + 4, self.bird_idle:getY() + onBirdBandY - 5) self.band_l:lineTo(87, 198) self.band_l:lineTo(85, 185) self.band_l:closePath() self.band_l:endPath() self.band_r = Shape.new() self.band_r:setFillStyle(Shape.SOLID, 0x382E1C) self.band_r:beginPath(Shape.NON_ZERO) self.band_r:lineTo(onBirdBandX + 4, self.bird_idle:getY() - onBirdBandY + 5) self.band_r:lineTo(onBirdBandX + 4, self.bird_idle:getY() + onBirdBandY - 5) self.band_r:lineTo(110, 198) self.band_r:lineTo(110, 187) self.band_r:closePath() self.band_r:endPath() -- Add drag events to bird self.bird_idle:addEventListener(Event.MOUSE_DOWN, onMouseDown, self) self.bird_idle:addEventListener(Event.MOUSE_MOVE, onMouseMove, self) self.bird_idle:addEventListener(Event.MOUSE_UP, onMouseUp, self) -- Add all elements to scene self:addChildAt(bg, 1) self:addChildAt(bg1, 2) self:addChildAt(self.catapult_r, 3) self:addChildAt(self.band_r, 4) self:addChildAt(self.bird_idle, 5) self:addChildAt(self.catapult_l, 6) self:addChildAt(self.band_l, 7) self:addChildAt(self.square_prop, 8) self:addChildAt(self.triangle_prop, 9) self:addChildAt(self.restart, 10) self:addEventListener(Event.ENTER_FRAME, self.onEnterFrame, self) self:addEventListener(\"exitBegin\", self.onExitBegin, self) end function level:wall(x, y, width, height) local wall = Shape.new() wall:beginPath() wall:moveTo(-width/2,-height/2) wall:lineTo(width/2, -height/2) wall:lineTo(width/2, height/2) wall:lineTo(-width/2, height/2) wall:closePath() wall:endPath() wall:setPosition(x,y) local body = self.world:createBody{type = b2.STATIC_BODY} body:setPosition(wall:getX(), wall:getY()) body:setAngle(wall:getRotation() * math.pi/180) local poly = b2.PolygonShape.new() poly:setAsBox(wall:getWidth()/2, wall:getHeight()/2) local fixture = body:createFixture{shape = poly, density = 1.0, friction = 1, restitution = 0} wall.body = body wall.body.type = \"wall\" stage:addChild(wall) end function setHalf(arr) for i = 1, #arr do arr[i]:setScale(.5, .5, .5) end end function onMouseDown(self, event) local bird = self.bird_idle if bird:hitTestPoint(event.x, event.y) and bird.isFly ~= true then bird.isFocus = true bird.x0, bird.y0 = event.x, event.y event:stopPropagation() end end function onMouseMove(self, event) -- if sprite touch and move finger, then change position of sprite local bird = self.bird_idle if bird.isFocus then if event.x > 20 and event.x < 140 then local dx = event.x - bird.x0 bird:setX(bird:getX() + dx) bird.x0 = event.x end if event.y > 160 and event.y < 265 then local dy = event.y - bird.y0 bird:setY(bird:getY() + dy) self.bird_idle.y0 = event.y end local onBirdBandX = self.bird_idle:getX() - self.bird_idle:getWidth() / 2 local onBirdBandY = self.bird_idle:getHeight() / 2 self.band_l:clear() self.band_l = Shape.new() self.band_l:setFillStyle(Shape.SOLID, 0x382E1C) self.band_l:beginPath(Shape.NON_ZERO) self.band_l:lineTo(onBirdBandX + 4, self.bird_idle:getY() - onBirdBandY + 5) self.band_l:lineTo(onBirdBandX + 4, self.bird_idle:getY() + onBirdBandY - 5) self.band_l:lineTo(87, 198) self.band_l:lineTo(85, 185) self.band_l:closePath() self.band_l:endPath() self:addChild(self.band_l) self.band_r:clear() self.band_r = Shape.new() self.band_r:setFillStyle(Shape.SOLID, 0x382E1C) self.band_r:beginPath(Shape.NON_ZERO) self.band_r:lineTo(onBirdBandX + 4, self.bird_idle:getY() - onBirdBandY + 5) self.band_r:lineTo(onBirdBandX + 4, self.bird_idle:getY() + onBirdBandY - 5) self.band_r:lineTo(110, 198) self.band_r:lineTo(110, 187) self.band_r:closePath() self.band_r:endPath() self:addChildAt(self.band_r, 4) event:stopPropagation() end end function onMouseUp(self, event) if self.bird_idle.isFocus and self.bird_idle.isFly ~= true then self.bird_idle.isFocus = false local bird_body = self.world:createBody{type = b2.DYNAMIC_BODY} local circle_shape = b2.CircleShape.new(0, 0, self.bird_idle:getWidth() / 2) local bird_fixture = bird_body:createFixture{shape = circle_shape, density = 1.0, friction = .5, restitution = 0} self.bird_idle.body = bird_body self.bird_idle.body:setPosition(self.bird_idle:getX() + self.bird_idle:getWidth() / 2, self.bird_idle:getY() + self.bird_idle:getHeight() / 2) self.bird_idle.body:applyForce((self.start_x - self.bird_idle:getX()) * 8, (self.start_y - self.bird_idle:getY()) * 8, self.bird_idle.body:getWorldCenter()) self.bird_idle.isFly = true self.band_l:clear() self.band_r:clear() event:stopPropagation() end end function restartDown (self, event) if self.restart:hitTestPoint(event.x, event.y) then self.touch = true event:stopPropagation() end end function restartUp (self, event) if self.touch then sceneManager:changeScene(\"level\", 1, SceneManager.flipWithFade, easing.outBack) end end function level:onEnterFrame() self.world:step(1/60, 8, 3) local screenW = application:getContentWidth() local screenH = application:getContentHeight() local offsetX = 0; local offsetY = 0; if((self.screenW - self.bird_idle:getX()) < screenW/2) then offsetX = -self.screenW + screenW elseif(self.bird_idle:getX() >= screenW/2) then offsetX = -(self.bird_idle:getX() - screenW/2) end self:setX(offsetX) if((self.screenH - self.bird_idle:getY()) < screenH/2) then offsetY = -self.screenH + screenH elseif(self.bird_idle:getY()>= screenH/2) then offsetY = -(self.bird_idle:getY() - screenH/2) end self:setY(offsetY) for i = 1, self:getNumChildren() do local sprite = self:getChildAt(i) if sprite.body then local body = sprite.body local bodyX, bodyY = body:getPosition() sprite:setPosition(bodyX, bodyY) sprite:setRotation(body:getAngle() * 180 / math.pi) end end -- Move intarface with camera self.restart:setX(-self:getX()) if self.bird_idle:getX() < 0 or self.bird_idle:getX() > self.screenW then sceneManager:changeScene(\"level\", 1, SceneManager.flipWithFade, easing.outBack) end end function level:onExitBegin() self:removeEventListener(Event.ENTER_FRAME, self.onEnterFrame, self) end Ну вот и все. Теперь расскажу как тестировать прямо на устройстве «на лету». Для этого устанавливаем на андроид смартфон из папки Gideros apk файл GiderosAndroidPlayer.apk и запускаем. Теперь в Gideros Studio выбираем наше устройство (смартфон должен быть подключен к тому же Wi-Fi, что и компьютер): Тут видно, что «stegges» — это наш компьютер, а «HTC One Mini 2» — это наш смартфон, выбираем его. Ну а теперь просто нажимаем кнопку запуска в Gideros Studio и можно начинать играть. Компилируем проект Теперь давайте скомпилируем нашу игру для запуска на андроид устройстве. Заходим в пункт меню «File» и выбираем «Export project» (cmd+E), видим следующее окно. Выбираем «Android» из выпадающего списка или закладок. Выбираем среду для какой будет экспортирован проект, в нашем случае Eclipse. Вводим название пакета. Нажимаем OK и выбираем папку куда экспортируем проект. Открываем Eclipse, ПКМ в Package Explorer --> Import --> Existing Android Code --> выбираем папку с нашим экспортированным проектом --> Finish --> ПКМ по проекту в Package Explorer --> Android Tools — > Export Signed App… --> выбираем наш ключ для подписи и выбираем папку для нашего апк. Готово. Думаю, объяснил доходчиво. Жду советов по статье и коду. Если будет желание и настроение, то сделаю еще уроки. Обещанные исходники (zip, Github) Апкшник проекта И на всякий случай плеер для Андроид", "image": ["https://habrastorage.org/files/d34/644/bf4/d34644bf4df54efb9f2ceafee7dee3fb", "https://habrastorage.org/files/879/86c/6f5/87986c6f5a124efb997aa6a14af74d01", "https://habrastorage.org/files/5d4/89d/909/5d489d909d4f4730a66bd1eb3c282499", "https://habrastorage.org/files/8c6/9df/305/8c69df30575e4475917352fa0880b5e9", "https://habrastorage.org/files/20b/5e3/9e6/20b5e39e670241f0bc224086ae70f35b", "https://habrastorage.org/files/da1/b14/9d9/da1b149d93094594951bd68441a3aa12", "https://habrastorage.org/files/7d1/db5/e70/7d1db5e70d414a94b330f195a8385dfd", "https://habrastorage.org/files/baf/211/c02/baf211c02582465c93cd143eb6d1b87e", "https://habrastorage.org/files/d30/17a/88b/d3017a88be064f4887a61ef83998da53", "https://habrastorage.org/files/2e4/19f/f17/2e419ff173614c858f2dc7a7b9e5c0ed", "https://habrastorage.org/files/ce6/b50/016/ce6b50016be44d638908babb6443d2c5", "https://habrastorage.org/files/136/0c8/6a7/1360c86a775f42318ebf232ba75a3fca", "https://habrastorage.org/files/59b/321/f8e/59b321f8e9e745739eb0ed69432dc249", "https://habrastorage.org/files/5e1/9bc/ed4/5e19bced4fec4177b309fb495b9960b0.gif", "https://habrastorage.org/files/e82/bdd/fd7/e82bddfd765243b5b2ada1fc2d437554", "https://habrastorage.org/files/2d4/805/69b/2d480569bdd14984b5d5d673356e39c2", "https://habrastorage.org/files/68f/7a6/e95/68f7a6e958724d1f8923553186f09f63"], "tag": ["game development", "lua", "gideros", "development"], "rating": ["+16"], "bookmarks": ["96"], "views": ["12,1k"], "comments_count": ["4"]},
{"author": ["starius"], "date": ["27 марта 2015 в 15:50"], "hubs": ["Разработка веб-сайтов", "Тестирование IT-систем", "Lua", "C"], "type_label": [], "text": "ROTE — простая библиотека на языке C, служащая для эмуляции терминала VT100. Она создает терминал и предоставляет доступ к его состоянию в виде структуры языка C. В терминале можно запустить дочерний процесс, «нажимать» в нем клавиши и смотреть, что он рисует на терминале. Кроме того, есть функция для отрисовки состояния терминала в окне curses. Зачем на практике может потребоваться эмулировать терминал и взаимодействовать через него с дочерним процессом? В первую очередь это нужно для автоматического тестирования программ, рисующих что-то на терминале с помощью curses, по моему мнению. Как иначе написать тесты для программы, которая ждёт, что пользователь нажмёт клавишу, и выводит результаты в определенное место экрана средствами curses? Несмотря на всё удобство и внутреннюю красоту ROTE, использовать её напрямую в тестах было бы громоздко. Поэтому я решил упростить задачу, привязав ROTE к языку Lua, который я очень люблю и знаю, как писать тесты. Так и родилась библиотека lua-rote, о которой я хочу рассказать. Установка Потребуется Linux, curses, Lua версии от 5.1 до 5.3 или LuaJIT, пакетный менеджер luarocks с установленными пакетом luaposix и, собственно, сама библиотека ROTE. ROTE устанавливается простым ./configure && make && make install. Надо отследить, чтобы она установилась туда, где её увидит система сборки. Я использую для этого ./configure --prefix=/usr. Чтобы не замусоривать систему бесхозными файлами, можно сделать пакет, для этого подойдёт программа checkinstall. lua-rote добавлен в luarocks, поэтому для его установки достаточно набрать следующую команду: $ sudo luarocks install lua-rote Если ROTE установили в /usr/local, то об этом надо сообщить luarocks'у посредством опции: $ sudo luarocks install lua-rote ROTE_DIR=/usr/local Чтобы установить версию с GitHub, введите следующие команды: $ git clone https://github.com/starius/lua-rote.git $ cd lua-rote $ sudo luarocks make Чтобы устанавливать пакеты в luarocks локально (то есть в домашнюю папку пользователя, а не в системные папки), добавьте опцию --local. В таком случае потребуется изменить кое-какие переменные окружения, чтобы Lua увидел эти пакеты: $ luarocks make --local $ luarocks path > paths $ echo 'PATH=$PATH:~/.luarocks/bin' >> paths $ . paths Использование Вся библиотека lua-rote находится в модуле rote, так что для начала подключим его: rote = require 'rote' Основная часть библиотеки — класс RoteTerm, представляющий терминал. Создадим терминал из 24 строк и 80 столбцов: rt = rote.RoteTerm(24, 80) Чтобы удалить терминал, надо просто удалить переменную, в которой он живёт. В Lua работает сборщик мусора, который при очередном проходе сделает всю работу по удалению. Запустим дочерний процесс: pid = rt:forkPty('less /some/file') Команда запускается при помощи '/bin/sh -c'. В переменную pid попадает идентификатор дочернего процесса. Позже его можно выяснить с помощью метода childPid(). В случае ошибки метод возвращает -1. Если попытаться запустить неправильную команду, то ошибка не будет отловлена на этом уровне: shell попытается запустить её и завершится со статусом 127. Чтобы перехватывать подобные ошибки, надо устанавливать обработчик сигнала SIGCHLD. Чтобы игнорировать завершение дочерних процессов, надо установить обработчик SIGCHLD в значение SIG_IGN. В Lua всё это можно сделать с помощью библиотеки luaposix: signal = require 'posix.signal' signal.signal(signal.SIGCHLD, function(signo) -- do smth end) signal.signal(signal.SIGCHLD, signal.SIG_IGN) Взаимодействие с терминалом, в котором дочерний процесс завершился, не является ошибкой, хотя вряд ли имеет смысл. Тем не менее, стоит уведомить ROTE о завершении дочернего процесса, вызвав метод forsakeChild(). Чтение содержимого терминала У терминала есть ряд методов, возвращающих его параметры и состояние: rt:rows() и rt:cols() — число строк и столбцов терминала rt:row() и rt:col() — текущие координаты курсора rt:update() — применяет изменения, пришедшие от дочернего процесса; вызывать перед чтением содержимого терминала rt:cellChar(row, col) — символ ячейки (row, col) в форме строки длины 1 rt:cellAttr(row, col) — атрибуты ячейки (row, col) в форме числа (см. ниже, что с ним делать) rt:attr() — текущие атрибуты, которые применяются к новым символам rt:rowText(row) — строка терминала номер row, без \"\\n\" на конце rt:termText() — строка, представляющая весь терминал; ряды завершаются \"\\n\" Ещё есть метод draw для рисования содержимого терминала в окне curses: curses = require 'posix.curses' -- инициализация curses, см. ниже demo/boxshell.lua window = ... rt = ... start_row = 0 start_col = 0 rt:draw(window, start_row, start_col) Запись в терминал Есть несколько методов, позволяющих менять состояние терминала напрямую: rt:setCellChar(row, col, character) — заменяет символ ячейки (row, col) rt:setCellAttr(row, col, attr) — заменяет атрибуты ячейки (row, col) rt:setAttr(attr) — меняет текущие атрибуты, которые применяются к новым символам rt:inject(data) — вводит данные в терминал Более важны методы, посылающие данные в дочерний процесс: -- Отправляет последовательность ':wq\\n' в терминал -- Если есть дочерний процесс, данные передаются ему. -- Иначе данные напрямую вставляются в терминал при помощи inject() rt:write(':wq\\n') -- сохраняем документ и закрываем vim -- Отправляет нажатие клавиши дочернему процессу через write() local keycode = string.byte('\\n') -- число rt:keyPress(keycode) Коллекцию кодов клавиш для keyPress можно найти в curses. К сожалению, эти константы появляются в модуле только после инициализации curses, которую часто производить нежелательно (например, в коде тестов). Чтобы как-то жить с этим, был сделан модуль rote.cursesConsts, запускающий curses в дочернем процессе через ROTE и возвращающий все константы. Снимки состояния терминала Метод rt:takeSnapshot() возвращает объект-снимок, а метод rt:restoreSnapshot(snapshot) восстанавливает состояние терминала согласно снимку. Объект-снимок также удаляется автоматически сборщиком мусора. Атрибуты и цвета Атрибут — это 8-битное число, в котором хранится цвет букв, цвет фона, бит полужирного текста (bold bit) и бит мигающего текста (blink bit). Порядок битов следующий: бит: 7 6 5 4 3 2 1 0 содержимое: S F F F H B B B | `-,-' | `-,-' | | | | | | | `----- 3 бита цвета фона (0 - 7) | | `--------- бит мигающего текста | `------------- 3 бита цвета букв (0 - 7) `----------------- бит полужирного текста Есть пара функций для упаковки и распаковки значения атрибута: foreground, background, bold, blink = rote.fromAttr(attr) attr = rote.toAttr(foreground, background, bold, blink) -- foreground и background - числа (0 - 7) -- bold и blink - логические переменные Коды цветов: 0 = черный 1 = красный 2 = зеленый 3 = желтый 4 = синий 5 = фиолетовый 6 = голубой 7 = белый В модуле rote есть таблицы перевода между кодами цветов и названиями цветов: rote.color2name[2] -- возвращает \"green\" rote.name2color.green -- возвращает 2 Пример использования А ещё я занимаюсь биоинформатикой :) Давно хотелось иметь программу для просмотра выравниваний вроде Jalview, но прямо в терминале, так как часто файлы находятся на сервере, к которому я подключён через ssh. В таких случаях нужно что-то вроде less для fasta-файлов. Всё, что мне удалось найти на эту тему, — программа tview для просмотра ридов, но это немного не то. В результате я написал программу alnbox, которая именно это и делает: показывает выравнивание ДНК в curses, позволяет «ходить» по нему стрелочками, перемещаться в начало и в конец. Названия последовательностей отображаются слева, номера позиций — сверху, консенсус — снизу. Код написан несколько шире, поэтому может пригодиться не только для выравниваний, но и любых less-подобных программ с заголовками вдоль всех 4-ех сторон терминала. Весь код программы написан на Lua, без использования C. С помощью lua-rote и busted написаны тесты для alnbox, в которых проигрываются все возможные варианты работы с программой. За основу кода интеграции тестов в Travis CI взят костяк lua-travis-example от moteus. Проект пока незавершён, но смотреть выравнивания уже можно. Зависимости те же + сам lua-rote. Для установки наберите команду luarocks make. Ещё один пример использования Вместе с библиотекой ROTE распространяется файл demo/boxshell.c. Это по сути терминал в терминале: bash запускается внутри ROTE, а состояние ROTE рисуется в curses при помощи метода draw(). Этот пример я перенёс в Lua. В начале статьи показан пример работы в этом терминале. В Lua-версию boxshell внесено несколько исправлений. Во-первых, можно запустить в качестве дочернего процесса любую команду, а не только bash. Во-вторых, переделано чтение нажатых клавиш от пользователя: вместо nodelay используется halfdelay, то есть ожидание нажатия клавиши с таймаутом. Благодаря этому нагрузка на процессор со стороны boxshell снижена с 100% до менее чем 1%. Баги Нет поддержки юникода. Метод draw() может чудить при запуске в Travis CI. Воспроизвести этот баг у себя не удаётся. Точной причины я не знаю, но подозреваю, что дело в особенностях терминала, который предоставляет Travis CI. Возвращает неправильные данные, если у терминала мало столбцов (пример: терминал 1x2). Сообщить о баге Исходный код ROTE был написан в 2004 году Бруно Т. К. де Оливейра (Bruno T. C. de Oliveira) и опубликован под лицензией GNU Lesser General Public License 2.1. Исходный код lua-rote опубликован под той же лицензией. Автор ROTE пишет, что разработка библиотеки завершена и обновления стоит искать в библиотеке libvterm, которая основана на ROTE. Есть ещё один проект с названием libvterm, который развивается активнее и есть модификация для проекта NeoVim. Для моих текущих целей ROTE хватило, и она выглядит более простой, поэтому пока я остановился именно на ней. Возможно, потом перейду к одному из libvterm. Ссылки GitHub Home page Сообщить о баге Сообщение в списке рассылки lua-l Ветка обсуждения на Reddit ROTE Busted, фреймворк для тестирования кода на Lua lua-travis-example, костяк для интеграции Lua-проекта в Travis CI", "image": ["https://habrastorage.org/getpro/habr/post_images/e8c/f27/5cf/e8cf275cfd684d0a9f70e50b66fe9eec.png", "https://habrastorage.org/getpro/habr/post_images/4aa/c46/82a/4aac4682a1c5e426cc1e6c13d47cbe40.gif"], "tag": ["lua", "rote", "lua-rote", "терминал", "эмулятор терминала", "VT102", "continuous integration", "unit testing", "coverage", "тестирование", "покрытие", "curses", "ncurses", "биоинформатика", "просмотрщик выравниваний", "fasta"], "rating": ["+10"], "bookmarks": ["35"], "views": ["5,8k"], "comments_count": ["23"]},
{"author": ["ant00N"], "date": [" 1 июня 2015 в 16:53"], "hubs": ["ООП", "Lua"], "type_label": [], "text": "Однажды судьба свела меня с ней. С первого взгляда я был ослеплен и долгое время не мог отвести от нее взгляд. Шло время, но она не переставала меня удивлять, иногда казалось, что я изучил ее вдоль и поперек, но она снова переворачивала все мои представления. Ее гибкости не было предела, а потом я узнал, что она умеет еще и… ООП! Как-то я всерьез занялся покорением ООП в lua. И все, что я находил в интернете по этой теме, было вырвиглазными нагромождениями кода с обилием нижних подчеркиваний, которые никак не вписывались в элегантность этого языка. Поэтому я решил искать простое решение. После прочтения множества умных книжек и разбора нескольких ужасных реализаций ООП, я, крупица за крупицей, собирал все самое полезное и простое, пока не выработал свой стиль объектно ориентированного программирования на lua. Создание класса и экземпляра class Person--класс Person= {} --тело класса function Person:new(fName, lName) -- свойства local obj= {} obj.firstName = fName obj.lastName = lName -- метод function obj:getName() return self.firstName end --чистая магия! setmetatable(obj, self) self.__index = self; return obj end --создаем экземпляр класса vasya = Person:new(\"Вася\", \"Пупкин\") --обращаемся к свойству print(vasya.firstName) --> результат: Вася --обращаемся к методу print(vasya:getName()) --> результат: Вася Как видите, все очень просто. Если кто-то путается где ставить точку, а где двоеточие, правило следующее: если обращаемся к свойству — ставим точку (object.name), если к методу — ставим двоеточие (object:getName()). Дальше интереснее. Как известно, ООП держится на трех китах: наследование, инкапсуляция и полиморфизм. Проведем «разбор полетов» в этом же порядке. Наследование Допустим, нам нужно создать класс унаследованный от предыдущего (Person). class WomanWoman = {} --наследуемся setmetatable(Woman ,{__index = Person}) --проверяем masha = Woman:new(\"Марья\",\"Ивановна\") print(masha:getName()) --->результат: Марья Все работает, но лично мне не нравится такой вариант наследования, некрасиво. Поэтому я просто создаю глобальную функцию extended(): extended()function extended (child, parent) setmetatable(child,{__index = parent}) end Теперь наследование классов выглядит куда красивее: class WomanWoman = {}; --наследуемся extended(Woman, Person) --проверяем masha = Woman:new(\"Марья\",\"Ивановна\") print(masha:getName()) --->результат: Марья Инкапсуляция Все свойства и методы до этого момента в наших классах были публичные, но мы так же легко можем создавать и приватные: class PersonPerson = {} function Person:new(name) local private = {} --приватное свойство private.age = 18 local public = {} --публичное свойство public.name = name or \"Вася\" -- \"Вася\" - это значение по умолчанию --публичный метод function public:getAge() return private.age end setmetatable(public,self) self.__index = self; return public end vasya = Person:new() print(vasya.name) --> результат: Вася print(vasya.age) --> результат: nil print(vasya:getAge()) --> результат: 18 Видите? Все почти так же как вы и привыкли. Полиморфизм Тут все еще проще. полиморфизмPerson = {} function Person:new(name) local private = {} private.age = 18 local public = {} public.name = name or \"Вася\" --это защищенный метод, его нельзя переопределить function public:getName() return \"Person protected \"..self.name end --это открытый метод, его можно переопределить function Person:getName2() return \"Person \"..self.name end setmetatable(public,self) self.__index = self; return public end --создадим класс, унаследованный от Person Woman = {} extended(Woman, Person) --не забываем про эту функцию --переопределим защищенный метод function Woman:getName() return \"Woman protected \"..self.name end --переопределим метод getName2() function Woman:getName2() return \"Woman \"..self.name end --проверим masha = Woman:new() print(masha:getName()) --> Person protected Вася print(masha:getName2()) --> Woman Вася Итак, что мы тут сделали? — создали класс Person, с двумя методами: getName() и getName2(), первый из них защищен от переопределения; — создали класс Woman и унаследовали его от класса Person; — переопределили оба метода в классе Woman. Первый не переопределился; — получили профит! Кстати, открытые методы можно определять так же и вне тела класса: полиморфизмPerson = {} function Person:new(name) local private = {} private.age = 18 local public = {} public.name = name or \"Вася\" --это защищенный метод, его нельзя переопределить function public:getName() return \"Person protected \"..self.name end setmetatable(public,self) self.__index = self; return public end --это открытый метод, его можно function Person:getName2() return \"Person \"..self.name end А что делать, если нужно вызвать метод базового класса, который у нас переопределен? Это тоже делается легко! Синтаксис таков: РодительскийКласс.Метод(сам_объект, параметры (если есть)). class Woman--создадим класс, унаследованный от Person Woman = {} extended(Woman, Person) --не забываем про эту функцию --переопределим метод setName function Woman:getName2() return \"Woman \"..self.name end print(masha:getName2()) --> Woman Вася --вызываем метод родительского класса print(Person.getName2(masha)) --> Person Вася Постскриптум На этом все, искренне надеюсь, что хоть кому-нибудь эта статья окажется полезной. Напоследок приведу полный код, можете его скопипастить в IDE и убедиться в работоспособности. Полный кодfunction extended (child, parent) setmetatable(child,{__index = parent}) end Person = {} function Person:new(name) local private = {} private.age = 18 local public = {} public.name = name or \"Вася\" --это защищенный метод, его нельзя переопределить function public:getName() return \"Person protected \"..self.name end --этот метод можно переопределить function Person:getName2() return \"Person \"..self.name end setmetatable(public,self) self.__index = self; return public end --создадим класс, унаследованный от Person Woman = {} extended(Woman, Person) --не забываем про эту функцию --переопределим метод setName function Woman:getName2() return \"Woman \"..self.name end masha = Woman:new() print(masha:getName2()) --> Woman Вася --вызываем метод родительского класса print(Person.getName2(masha)) --> Person Вася", "image": [], "tag": ["луа", "ооп", "lua"], "rating": ["+21"], "bookmarks": ["117"], "views": ["24,1k"], "comments_count": ["19"]},
{"author": ["tmk826"], "date": ["26 октября 2014 в 00:13"], "hubs": ["Lua", "API"], "type_label": ["Tutorial"], "text": "На днях встал перед задачей, как определить, сколько времени тратит NFS сервер на запрос. Оказалось, что это не так уж и просто посмотреть. Но на помощь пришёл любимый молоток инструмент — wireshark. Для wireshak можно написать своё расширение на LUA. Идея простая: берём NFS запрос и кладём в hashmap, а когда видим ответ, то считаем разницу во времени: if msgtyp == 0 then packets[xid] = { timestamp = frameepochtime, source = tostring(ipsrc), destination = tostring(ipdst), op_code = nfs_op }; else local l = packets[xid] if l ~= nul then packets[xid] = nil local time_delta = frameepochtime - l.timestamp if time_delta > min_time_delta then print(frametime .. \" \" .. l.source .. \" <=> \" .. l.destination .. \" \" .. string.format(\"%.3f\",time_delta) .. \" \" .. l.op_code) end end Полный код доступен тут Запускается просто с командной строки $ tshark -q -X lua_script:nfs.lua -f \"port 2049\" Результат: \"Aug 27, 2014 16:44:43.000 CEST\" aaaa:bbbb:ccc:10a0::1:7f <=> aaaa:bbbb:ccc:10bf::1:8c 0.001 v4_EXCHANGE_ID \"Aug 27, 2014 16:44:43.000 CEST\" aaaa:bbbb:ccc:10a0::1:7f <=> aaaa:bbbb:ccc:10bf::1:8c 0.001 v4_CREATE_SESSION \"Aug 27, 2014 16:44:43.000 CEST\" aaaa:bbbb:ccc:10a0::1:7f <=> aaaa:bbbb:ccc:10bf::1:8c 0.001 v4_PUTROOTFH \"Aug 27, 2014 16:44:43.000 CEST\" aaaa:bbbb:ccc:10a0::1:7f <=> aaaa:bbbb:ccc:10bf::1:8c 0.002 v4_RECLAIM_COMPLETE \"Aug 27, 2014 16:44:43.000 CEST\" aaaa:bbbb:ccc:10a0::1:7f <=> aaaa:bbbb:ccc:10bf::1:8c 0.001 v4_PUTROOTFH \"Aug 27, 2014 16:44:43.000 CEST\" aaaa:bbbb:ccc:10a0::1:7f <=> aaaa:bbbb:ccc:10bf::1:8c 0.001 v4_DESTROY_SESSION \"Aug 27, 2014 16:44:43.000 CEST\" a.b.161.127 <=> a.b.191.140 0.001 v4_EXCHANGE_ID \"Aug 27, 2014 16:44:43.000 CEST\" a.b.161.127 <=> a.b.191.140 0.001 v4_CREATE_SESSION \"Aug 27, 2014 16:44:43.000 CEST\" a.b.161.127 <=> a.b.191.140 0.003 v4_PUTROOTFH \"Aug 27, 2014 16:44:43.000 CEST\" a.b.161.127 <=> a.b.191.140 0.002 v4_RECLAIM_COMPLETE \"Aug 27, 2014 16:44:43.000 CEST\" a.b.161.127 <=> a.b.191.140 0.004 v4_PUTROOTFH Может, у кого-то есть похожие наработки? Делитесь! Lua Support in Wireshark Wireshark LUA wiki", "image": [], "tag": ["nfs", "lua", "wireshark"], "rating": ["+9"], "bookmarks": ["50"], "views": ["7k"], "comments_count": ["2"]},
{"author": ["denis_p"], "date": ["28 октября 2014 в 09:58"], "hubs": ["Lua", "Разработка игр", "Программирование"], "type_label": [], "text": "Всем доброго времени суток. Так уж сложилось, что про использование cocos2d-x Lua в природе существует довольно мало информационных материалов, даже с учётом англоязычных источников. Поэтому во многом приходится разбираться самому, копаясь в чужом коде и читая (часто не особо содержательную) документацию. В этой статье я хочу хотя бы частично исправить эту несправедливость и рассказать о расширении стандартного функционала доступного в cocos2d-x Lua с помощью нативных классов. С этой задачей я столкнулся, можно сказать, лицом к лицу после осознания собственных скудных знаний Lua. Тогда же и созрело решение часть игровой логики написать на старом добром C++. Итак, кому интересен данный процесс прошу под кат. В качестве отправной точки примем то, что у вас установлена и настроена CocosCode IDE. Если нет, то об этом есть неплохая статья на русском вот здесь. 1. Создаём наш С++ класс Начнём с создания класса, который мы будем подключать к Lua. MyClass.hpp#ifndef MyClass_hpp #define MyClass_hpp #include \"cocos2d.h\" #include <string> using std::string; namespace cocos2d { class MyClass : public cocos2d::Ref { public: MyClass(); ~MyClass(); bool init(); string myFunction(); CREATE_FUNC(MyClass); }; } //namespace cocos2d #endif Здесь следует обратить внимание на то, что наш класс должен быть наследником от Ref, что вызвано особенностями управления памятью в cocos2d-x. MyClass.cpp#include \"MyClass.hpp\" using namespace cocos2d; MyClass::MyClass() {} MyClass::~MyClass() {} bool MyClass::init() { return true; } string MyClass::myMethod() { return \"Hello, Habrahabr!\"; } Файлы с нашим классом мы помещаем в директорию «myclass», которую создаём в /framework/cocos2d-x/cocos/ (внутри проекта). Если у вас нет папки framework, то в CocosCode нужно выполнить следующее: Клацнуть правой кнопкой мыши на проект -> Cocos Tools -> Add Native Code Support 2. Создаём Lua обёртку для нашего класса Для этого в папке /frameworks/cocos2d-x/tools/tolua создадим следующий файл: cocos2dx_myclass.ini[cocos2dx_myclass] # the prefix to be added to the generated functions. You might or might not use this in your own # templates prefix = cocos2dx_myclass # create a target namespace (in javascript, this would create some code like the equiv. to `ns = ns || {}`) # all classes will be embedded in that namespace target_namespace = android_headers = -I%(androidndkdir)s/platforms/android-14/arch-arm/usr/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/include android_flags = -D_SIZE_T_DEFINED_ clang_headers = -I%(clangllvmdir)s/lib/clang/3.3/include clang_flags = -nostdinc -x c++ -std=c++11 cocos_headers = -I%(cocosdir)s/cocos -I%(cocosdir)s/myclass -I%(cocosdir)s/cocos/base -I%(cocosdir)s/cocos/platform/android cocos_flags = -DANDROID cxxgenerator_headers = # extra arguments for clang extra_arguments = %(android_headers)s %(clang_headers)s %(cxxgenerator_headers)s %(cocos_headers)s %(android_flags)s %(clang_flags)s %(cocos_flags)s %(extra_flags)s # what headers to parse headers = %(cocosdir)s/cocos/myclass/MyClass.hpp # what classes to produce code for. You can use regular expressions here. When testing the regular # expression, it will be enclosed in \"^$\", like this: \"^Menu*$\". classes = MyClass.* # what should we skip? in the format ClassName::[function function] # ClassName is a regular expression, but will be used like this: \"^ClassName$\" functions are also # regular expressions, they will not be surrounded by \"^$\". If you want to skip a whole class, just # add a single \"*\" as functions. See bellow for several examples. A special class name is \"*\", which # will apply to all class names. This is a convenience wildcard to be able to skip similar named # functions from all classes. skip = rename_functions = rename_classes = # for all class names, should we remove something when registering in the target VM? remove_prefix = # classes for which there will be no «parent» lookup classes_have_no_parents = # base classes which will be skipped when their sub-classes found them. base_classes_to_skip = # classes that create no constructor # Set is special and we will use a hand-written constructor abstract_classes = # Determining whether to use script object(js object) to control the lifecycle of native(cpp) object or the other way around. Supported values are 'yes' or 'no'. script_control_cpp = no Вдаваться в подробности содержимого этого файла я не буду, об этом можно прочесть здесь. Теперь нам нужно добавить только что созданный ini файл в сценарий генерации Lua обёрток. Для этого откроем genbindings.py и добавим перед закрывающей фигурной скобкой следующую строку: cmd_args = {'cocos2dx.ini' : ('cocos2d-x', 'lua_cocos2dx_auto'), \\ 'cocos2dx_extension.ini' : ('cocos2dx_extension', 'lua_cocos2dx_extension_auto'), \\ 'cocos2dx_ui.ini' : ('cocos2dx_ui', 'lua_cocos2dx_ui_auto'), \\ 'cocos2dx_studio.ini' : ('cocos2dx_studio', 'lua_cocos2dx_studio_auto'), \\ 'cocos2dx_spine.ini' : ('cocos2dx_spine', 'lua_cocos2dx_spine_auto'), \\ 'cocos2dx_physics.ini' : ('cocos2dx_physics', 'lua_cocos2dx_physics_auto'), \\ 'cocos2dx_experimental_video.ini' : ('cocos2dx_experimental_video', 'lua_cocos2dx_experimental_video_auto'), \\ 'cocos2dx_experimental.ini' : ('cocos2dx_experimental', 'lua_cocos2dx_experimental_auto'), \\ 'cocos2dx_controller.ini' : ('cocos2dx_controller', 'lua_cocos2dx_controller_auto'), \\ 'cocos2dx_myclass.ini' : ('cocos2dx_myclass', 'lua_cocos2dx_myclass_auto') \\ } Запускаем genbindings.py. В случае успешного проведения всех описанных выше манипуляций, у нас должны появиться следующие файлы (в директории /frameworks/cocos2d-x/cocos/scripting/lua-binding): lua_cocos2dx_myclass_auto.hpp lua_cocos2dx_myclass_auto.cpp ./api/MyClass.lua Теперь у нас есть всё необходимое для подключения нашего класса к Lua. Этот процесс состоит из двух однотипных процедур: одна для iOS, другая для Android. 3.1. Подключение файлов к iOS Открываем проект приложения. Первым делом, добавим С++ исходники к cocos2d_libs: Теперь добавляем сгенерированные файлы к cocos2d_lua_bindings: Не забудем также задать путь к заголовочным файлам в cocos2d_lua_bindings -> Build Settings -> User Header Search Paths Пользуясь удобным случаем, зарегистрируем наш класс в AppDelegate.cpp: ... #include \"ConfigParser.h\" // Это наш сгенерированный заголовочный файл #include \"lua_cocos2dx_myclass_auto.hpp\" using namespace CocosDenshion; bool AppDelegate::applicationDidFinishLaunching() { ... // set FPS. the default value is 1.0/60 if you don't call this director->setAnimationInterval(1.0 / 60); auto engine = LuaEngine::getInstance(); ScriptEngineManager::getInstance()->setScriptEngine(engine); LuaStack* stack = engine->getLuaStack(); stack->setXXTEAKeyAndSign(\"2dxLua\", strlen(\"2dxLua\"), \"XXTEA\", strlen(\"XXTEA\")); // А тут мы регистрируем наш класс register_all_cocos2dx_myclass(stack->getLuaState()); #if (COCOS2D_DEBUG>0) if (startRuntime()) return true; #endif engine->executeScriptFile(ConfigParser::getInstance()->getEntryFile().c_str()); return true; } ... На этом наши приключения с iOS заканчиваются. 3.2. Подключение файлов к Android Здесь по сути всё аналогично предыдущему разделу. Нужно подключить исходники класса к cocos2d-x проекту и сгенерированные файлы к cocos2dx_lua проекту. Разница только в том, что дело придется иметь с текстовыми файлами Android.mk. Добавляем файлы нашего класса в проект кокоса. Для этого вносим несколько дополнений в файл /frameworks/cocos2d-x/cocos/Android.mk Здесь (указываем *.cpp файлы): И вот здесь (указываем путь к заголовочным файлам): Теперь осталось подключить сгенерированные файлы к cocos2d_lua. Для этого нужно отредактировать файл /frameworks/cocos2d-x/cocos/scripting/lua-bindings/Android.mk Тут (указываем *.cpp файл): И ещё вот тут (указываем путь к заголовочному файлу): 4. Обновляем среду выполнения В принципе, всё уже будет работать, если запускать проект в XCode или Eclipse. Чтобы всё работало и в CocosCode IDE, нужно пересобрать среду выполнения. Для этого щёлкаем правой кнопкой мыши на проект -> Cocos Tools -> Build Custom Runtimes. Вот и всё. 5. Запускаем, радуемся Не вижу особого смысла показывать результаты в виде скриншотов одной единственной строки в консоле. Тем не менее, вывод будет таким: [Lua Debug]: Hello, Habrahabr! Аналогичным образом с помощью binding-generator-a можно добавлять свои классы и в cocos2d-js. Следует однако предупредить, что на нормальный запуск самого генератора мне пришлось потратить добрые пару часов. Возился с несоответствием разных необходимых библиотек. Если всё делать как написано, то проблем быть не должно (указания по настройке генератора можно найти вот здесь). P.S. На мой взгляд, «подвязка» движка к скриптовым языкам в некоторых случаях может здорово упростить жизнь. Не знаю, упростила ли она жизнь мне в конечном итоге, но интересный опыт я приобрел.", "image": ["https://habrastorage.org/files/cc9/388/174/cc93881747d646f999b79860d50bf03d.png", "https://habrastorage.org/files/668/41e/d73/66841ed732994d66bc106516677e4f51.png", "https://habrastorage.org/files/d43/07d/e22/d4307de22cd444b984ae3bb0c83192c3.png", "https://habrastorage.org/files/324/eb3/b91/324eb3b911fa45ed8d31bd4b02566291.png", "https://habrastorage.org/files/a9a/c40/7b6/a9ac407b65dc409a8bc835b473bd0d24.png", "https://habrastorage.org/files/408/ec6/6ed/408ec66ed27d4889a8b826f491054685.png", "https://habrastorage.org/files/df2/ee5/7bc/df2ee57bc3ed4b94b8e273e0614cae2e.png"], "tag": ["game dev", "game development", "cocos2d-x", "cocos2dx"], "rating": ["+14"], "bookmarks": ["46"], "views": ["5,7k"], "comments_count": ["14"]},
{"author": ["Sayman_nsk"], "date": ["13 ноября 2014 в 14:34"], "hubs": ["Lua", "Asterisk"], "type_label": [], "text": "Приветствую всех. Когда-то тема использования языка программирования lua при написании диалплана в Астериске для меня стояла довольно жёстко. Дело в том, что мне сильно не нравится работать с различными GUI (типа FreePBX) при настройке Астериска. Когда я всё настраивал в первый раз, работал с обычным линейным extensions.conf. Время шло, потребности в функционале телефонии росли. Язык lua постепенно немного изучил. И вот пришёл я работать админом в одну крупную компанию в нашем городе (одно крупное агентство недвижимости) — около 45 филиалов на тот момент было, примерно 650 — 700 пользователей, включая межгород и т.д. Там уже стоял Asterisk, но всё настроено было с использованием FreePBX. Почти сразу руководство начало меня заваливать различными вопросами по наворотам Астериска. Например, хотели, чтобы при входящем звонке в какой-то филиал, звонки внутри филиала были распределены случайным образом. Хотели иметь запись разговоров в mp3, хотели сделать общую группу, куда можно было бы включить вообще все филиалы и при наборе какого-то номера, чтобы случайно попасть на один из филиалов и т.д. Задачи вроде простые, однако сидеть решать даже такие вопросы средствами графического интерфейса лично мне было не очень интересно. Был ещё один важный момент — качество работы телефонии в целом на тот момент было просто ужасным. Голос постоянно булькал, звонки разрывались, абонента не слышно, сам астер часто крашился и т.д. Смотрю на файлик диалплана, а он размером в 16 мб. Открыл редактором текста — и что тут делать? Там строк в несколько миллионов. Решил переделать, перекинув всё на lua. Примерно через пару дней после начала разработки я уже смог представить первый прототип диалплана на lua, вполне рабочий, но без существующих «фишечек» и «рюшечек». Заменил им весь старый конфиг и далее ещё в течение недели накидал основные навороты, которые хотело видеть руководство. Так же обновил самого астера до 11-й версии (на тот момент 11.3.0, кажется). Далее в процессе работы иногда поглядывал в файл диалплана и подпиливал то, что сам хотел или хотело руководство. В итоге астер с диалпланом на lua работал значительно быстрее и более стабильно, чем прошлый. Условия в которых работала «станция»: cpu: intel xeon e5520 (если не ошибаюсь) ram: 24gb и другие «железные» параметры, включая два гигабитных сетевых интерфейса и рэйд1 количество вн.абонентов: около 700 количество транков: около 10 (из которых 2 это провайдеры, остальные это gsm шлюзы addpack). количество «городских» номеров: около 200 (150 номеров от одного провайдера и примерно50 или чуть больше от второго). Городские номера тут были закреплены за каждым филиалом. За некоторыми филиалами даже по два или три номера. Поскольку все звонки из города прилетали в контекст, далее я делал разбор по did и передавал звонок на нужный филиал. Средствами lua реализовал ring groups, сделал два варианта вызова абонента — случайное и по порядку перечисления в группе (за исключением занятых абонентов). Прикрутил lua-sql для записи собственной базы звонков (дополнение к cdr). Это было сделано вот для чего: сотрудник звонит клиенту на сотовый, клиент сейчас не захотел разговаривать (занят или ещё что); через некоторое время он перезванивает на определённый ранее номер и должен попасть к тому же сотруднику, который ему до этого звонил. Я сделал запись события «звонок на мобильный» в отдельную базу. Когда клиент с сотового перезванивает, я по событию «звонок с сотового» поднимаю прошлый звонок и отдаю клиента на нужного сотрудника. Запоминался только один такой сотрудник. Т.е. если этому клиенту позвонит ещё один сотрудник. то соответственно, звонок вернётся к нему. Сейчас я уже не работаю в той компании, а там где сейчас — меняю старую АТС на Астериска и, конечно, использую старую свою наработку. Вспомнил, что тема интересна была не только мне. Ну а поскольку по этой теме информации крайне мало, решил накидать вот эту статью, вдруг кому-то пригодится. Теперь перейду к самой сути темы — кодинг на lua. Описывать стадию включения модуля pbx_lua не буду — информации тут много. Например, сейчас у меня стоит Centos 6.6, там в стоке уже есть lua. Я докинул только пакет lua-devel и включил модуль pbx_lua в menuselect. Дополнительно, если кто собирается использовать ручное подключение к mysql (или к другой базе), то лучше докинуть пакет lua-sql, предварительно установив luarocks и оттуда закачав это дополнение. Далее в самом диалплане можно описать пользователей и правила набора, что-то типа того: extensions = { }; local_ext = { -- когда вн.абонент поднял трубку и набрал другого вн.абонента h = function() -- обработчик конца разговора (hangup) app.stopmixmonitor() d_status = channel[\"DIALSTATUS\"]:get() if d_status ~= nil then app.noop(\"Dial over with status:\"..d_status) -- например, если абонент не дозвонился, тогда затираем имя файла в базе cdr if d_status ~= \"ANSWER\" then channel[\"CDR(recordingfile)\"]:set(\"\") end app.noop(\"Good buy!\") app.hangup() end; app.hangup() end; [\"_14XXX\"] = call_local; [\"_21XX\"] = call_local; [\"_4595\"] = call_all; -- это описание не номера, а группы номеров. при наборе звоним на случайны номер из группы [\"_*99\"] = function() -- это специально добавлял для принудительного включения dnd (занятно). local cid, dnd app.answer() cid = channel[\"CALLERID(num)\"]:get() dnd = channel[\"DB(DND/\"..cid..\"/)\"]:get() app.noop(\"DND:\"..dnd) if dnd == \"1\" then channel[\"DB_DELETE(DND/\"..cid..\"/)\"]:get() app.playback(\"beep\") app.playback(\"beep\") app.hangup() else channel[\"DB(DND/\"..cid..\"/)\"]:set(\"1\") app.playback(\"beep\") app.wait(1) app.hangup() end end; include = {\"mobile_out\"}; }; тут [\"_XXномер\"] — шаблон. Т.е. всё тоже самое, что и в обычном extensions.conf. call_local — функция на которую ссылается данное описание. Т.е. при наборе номера, скажем, 14555, будет вызываться функция call_local. Так же эта функция может вызываться при входящем внешнем звонке. function call_local(ctx,ext) local callerid,cf,uniq,chn local n,j,i n = string.sub(ext,3) -- взяли последние 2 символа номера if n == \"90\" or n == \"79\" or n == \"80\" then -- если оканчивается на 90 и т.д. тогда это звонок на одну из групп филиалов j = channel[\"CALLERID(num)\"]:get() app.noop(string.format(\"Using ring group %s from %s\",ext,j)) dial_rg(shuffle(r_group[ext],nil)) -- смешать номера в группе и вызвать end -- если пользователь включил режим \"отсутствую\", тогда звонок полетит к нему на его сотовый cf = channel[\"DB(CF/\"..ext..\"/\"..\")\"]:get() app.noop(\"CF:\"..cf) if cf ~= \"\" then app.noop(string.format(\"Call forward detected from %s to %s\",ext,cf)) app.goto(\"mobile_out\",cf,\"1\") end callerid = channel[\"CALLERID(num)\"]:get() app.noop(string.format(\"Trying to local call %s from %s\",ext,callerid)) if ext ~= \"4550\" and (CheckChannel(ext)) ~= NOT_INUSE then return end uniq = channel.UNIQUEID:get() chn = channel[\"CHANNEL\"]:get() app.noop(string.format(\"UNIQUEID: %s\",uniq)) app.noop(string.format(\"CHANNEL: %s\",chn)) app.noop(string.format(\"CALLERID_name: %s\",callerid)) app.noop(string.format(\"EXTEN: %s\",ext)) app.noop(string.format(\"CONTEXT: %s\",ctx)) record(string.format(\"%s-%s-%s\",callerid,ext,uniq)) if ext == \"4550\" then local support = CallSupport(callerid) if support == \"failed\" then return end end if ext == \"4514\" or ext == \"4592\" then app.noop(\"Redirect!!!\") app.dial(\"SIP/4591,60,tT\") end app.dial(string.format(\"SIP/%s,60,tT\",ext)) end Тут есть несколько проверок на некоторые группы и статусы. Например, 4550 — это группа технической поддержки. Для неё есть отдельная функция, в которой есть обработка занятости сотрудников, информирование «вн.клиента», запись журнала и сброс предупреждения о пропущенном звонке в тех.поддержку через jabber. Если вызываемый абонент является группой, тогда смешать список и вызвать случайного абонента. Почему я использую случайный метод вызова абонентов из групп? Филиалы — это, по сути своей, менеджеры продаж. Если включать последовательный вызов сотрудников филиала, то всегда у первых в списке будет продаж больше, чем у других (читинг). Аналогично обстоят дела и с методом mem-primari (кажется), при котором пользователь ответивший в прошлый раз будет игнорирован. Метод случайного смешивания более честный, ставит всех «продажников» в равные условия. Можно сделать конечно call-all (звонить всем одновременно), но тогда филиалы начинают жаловаться, что в филиале все телефоны «орут» одновременно это не удобно, шумно и т.д. Для случайного вызова можно было бы так же использовать очереди, но я их почти не использую. Не знаю почему, так получилось. Далее, входящие из города, описание: from_trunk = { h = function() app.noop(\"BBBBBBBLLLLAAAAHHHHHH!!!!!!!\") app.stopmixmonitor() if d_status ~= nil then d_status = channel[\"DIALSTATUS\"]:get() app.noop(\"Dial over with status:\"..d_status) if d_status ~= \"ANSWER\" then channel[\"CDR(recordingfile)\"]:set(\"\") end exten = \"\" uniqid = \"\" app.noop(\"Good buy!\") app.hangup() end app.noop(\"Some problem!!!\") app.hangUP() end; [\"f1\"] = function(e) -- если честно, не помню что я тут делал... app.goto(\"local_ext\",e,1) end; [\"_.\"] = foo; -- да да, это функция называется типа foobar... include = {\"local_ext\"} } Тут я все внешние входящие я заворачиваю в foo. function foo(ctx,ext) local chn tmptab.did = ext tmptab.rg = g_tab[ext] if tmptab.did == \"99051000227736\" then -- тут я делал эксперимент с входящими со Скайпа. работают. app.noop(\"Skype TEST!!!\") app.dial(\"SIP/14553,,tT,M(bar)\") end tmptab.callerid = channel[\"CALLERID(num)\"]:get() if string.find(tmptab.callerid,\"88005550678\",1) then app.hungup() end -- кого-то забанил... if string.find(tmptab.callerid,\"79\",1) then -- тут я тоже подзабыл, что-то связанное с определением сотовых номеров tmptab.callerid = \"8\"..string.sub(tmptab.callerid,2) channel[\"CALLERID(all)\"]:set(tmptab.callerid) end chn = channel[\"CHANNEL\"]:get() app.noop(\"CHANNEL:\"..chn) if string.find(chn,\"SIP/gsm_\",1) then -- тут я вылавливаю входящие через gsm шлюзы app.noop(\"Found channel \"..chn) -- через ранее созданную простейшую базу на mysql выловил абонента и отправил ему клиента num = sql.mobile_get(tmptab.callerid) if num then app.goto(\"local_ext\",num,1) end end app.noop(\"CallerID(num):\"..tmptab.callerid) app.noop(\"by context:\"..ctx) app.noop(\"DID:\"..tmptab.did) app.set(\"CDR(did)=\"..tmptab.did) if tmptab.did == \"4595\" then call_all(tmptab.did) end -- 4595 это глобальная группа по всем филиалам app.answer() app.wait(1) j = channel[\"DB(ENUM/\"..tmptab.did..\"/)\"]:get() app.noop(\"tag = \"..j) if j == \"ngs_rec\" then dial_rg(shuffle(tmptab.rg),1) else if tmptab.did ~= \"3471234\" then -- имейте ввиду, все номера тут вымышленные!!! app.playback(mhold.comp_hello) if tmptab.did == \"3472345\" then app.goto(\"local_ext\",\"4591\",1) end ivr(tmptab.did) -- да, голосовое меню тут тоже есть, но показывать его не буду... dial_rg(shuffle(tmptab.rg),nil) else app.noop(\"BLAH DETECTED\") dial_rg(tmptab.rg,nil) end end app.noop(\"hungup?\") end В данном случае определяю сотовые номера и внешние номера (did). Если звонящий звонит на местный сотовый (симка в gsm шлюзе), тогда беру последнего звонившего абонента и отправляю этого клиента к нему. Так же есть определение из списка ngs_rec. Тут номера заранее определены как «рекламные». Это был старый метод (потом переделал, но в этой версии файла из которой беру код данной доработки нет). Все рекламные номера отправляю на спец.номера в конторе и делаю отметку в базе, что был звонок на номер, указанный в рекламе. Пока, думаю, хватит кода на данный момент. Если у кого-то появится интерес к переходу от старого диалплана к lua, думаю, смогу продолжить и разъяснить более детально некоторые вещи. Хотя, если кто-то уже знает, как программировать на Lua, проблем совершенно не будет. В завершении хочу сказать, что, конечно, на сегодняшний день существует целая пачка разных навороченных решений, типа VoxImplant и подобных. Многим вообще не привычно работать в консоли и что-то своё кодить. Но, хочу заметить, что когда размеры компании большие (от 50 абонентов и выше), то выстраивание логики работы «станции» при помощи кнопочек и галочек в графическом интерфейсе в итоге могут приводить к проблемам. Выше в начале статья я приводил примеры про бульканье и обрывы. Диалплан на lua весит всего 24кб, 968 строк. На нём работали почти 700 абонентов без каких-то проблем. Всё. Всем до свиданья!", "image": [], "tag": ["Asterisk", "LUA"], "rating": ["+9"], "bookmarks": ["147"], "views": ["17,7k"], "comments_count": ["54"]},
{"author": ["IgorTimofeev"], "date": [" 4 декабря 2015 в 10:50"], "hubs": ["Lua"], "type_label": [], "text": "В далеком 2011 году мир увидел такую игру как Minecraft — воксельную песочницу, где каждый творит все, что душе угодно. Спустя некоторое время народные умельцы стали писать различные модификации для нее, делающие геймплей более разнообразным. Не так давно появился мод под названием «OpenComputers», добавляющий полноценные компьютеры, программируемые на скриптовом языке Lua. И в этой статье я хочу поделиться с вами небольшим опытом, приобретенным при изучении этого крайне интересного мода. Изучаем мод Если поставить перед собой компьютер и установить на него стандартную консольную ОС с местных дискет, то можно слегка разочароваться в функционале мода. По сути на старте мы имеем командую строку с довольно противно выглядящим интерфейсом, имеем набор стандартных команд по типу ls, edit <файл>, remove <файл> или mkdir <папка>. Меня все это дело решительно не устраивало, и я решил добавить более приятные цвета к консоли и русифицировать подсказки для мода, благо автор позволил нам редактировать исходный код всех его наработок. Синтаксис Lua, его структура и возможности меня крайне удивили по сравнению с тем же недружелюбным к новичкам семейством СИ или еще более неказистой Java, в нем есть абсолютно все, что нужно «из коробки», а документация к моду написана простым популярным языком. Сначала я стал писать простенькие скрипты а-ля «Hello world», чуть позже позже я перешел на всякие мелкие программы для контроля дверей или освещения в игровом доме, но все это отдавало душком скуки и простоты. Хотелось хардкора! Постепенно изучая местные библиотеки и особенности Lua, мы с моим другом смогли делать простенькие GUI-приложения. Пошарив по всяким википедиям, мы нашли несколько алгоритмов работы с цветом — например, для преобразования цвета из RGB в HSB формат или для наложения одного цвета на другой с учетом прозрачности. Немного повозившись, мы сумели реализовать эти алгоритмы на Lua, и так появилась наша первая библиотека для этого мода, мы назвали ее colorlib, а с ее помощью мы смогли накодить вот такую симпатичную палитру: Решив не останавливаться на достигнутом, мы подумали, что классно было бы сделать графический редактор для этого мода, а также свой формат изображения. Действительно, почему бы нет? Так мы смогли бы легко рисовать красивую графику на мониторе. Провозившись несколько дней, мой товарищ сумел реализовать грамотную структуру файлов будущих картинок, которая кушала крайне мало места на местных жестких дисках, которые, к слову, имеют ограниченный объем в 4 МБ. Аббревиатуру формата мы обозначили как \".pic\", а сам формат назвали «OpenComputers Image Format», сокращенно «ocif». После всего этого мы приступили к созданию самого графического редактора, потратив на это около трех дней. В итоге мы имеем вот это: Структуру файла .pic в шестнадцатеричном виде можно лицезреть на этой картинке: Первым делом мы добавили в наш графический редактор самые необходимые инструменты — кисть, ластик, а также текст для создания надписей, ведь по сути мы имеем консоль, где каждый пиксель имеет три параметра: цвет текста, цвет фона и символ. Чуть позже вставили алгоритм рекурсивной заливки для более удобного создания картинок, а еще чуть позже сумели приучить наш редактор работать с реальным PNG-форматом изображения (кстати, при помощи статьи с хабра). Итак, мы имеем рабочий формат изображения, но не знаем, где его можно применять. Мы стали писать различные приложения под этот мод, например, вот такой симпатичный календарик: Или приложение, генерирующее цифровой дождь из всем известного фильма: В конце концов у нас скопилось столько различных скриптов и библиотек, что мы утомились загружать их вручную cтандартным методом через Pastebin.com. Да, мод имеет интеграцию с пастбином, поэтому все наши файлы мы хранили изначально на нем, загружая их по мере необходимости на компьютеры. Но учитывая количество файлов, нами было принято решение о создании программы-инсталлятора, автоматически загружающей список файлов с нашего репозитория на GitHub, а затем скачивающей файлы по списку в нужную директорию. Было довольно много геморроя с переносом файлов с Pastebin'a, но через пару часов мы управились с задачей и приступили к кодингу инсталлятора. В итоге вышло вот что: Итак, мы уже могли кодить простые приложения с картинками, имели удобный инсталлятор для них, но хотелось чего-то большего! Идея создания операционной системы пришла как-то сама собой, и, недолго думая, я решил сделать несколько набросков иконок для будущей ОС. К примеру, вот так выглядит папка: Нарисовав основные иконки, я приступил к созданию самой операционной системы, сразу дав ей название «MineOS». Основная концепция очень проста: в папке MineOS/Desktop/ лежат файлы любого типа. С помощью стандартной функции getFileList() мы получаем список файлов, получаем формат файла через обрезку строкового имени файла, а затем рисуем на нашем экране иконки в соответствии с полученным форматом. Вышло что-то вроде этого: Затем я приделал нижнее меню в стиле Mac OS, добавил меню сверху, накодил библиотеку контекстного взаимодействия — и в итоге мы имеем уже нечто, достойное названия «графическая оболочка», но до полноценной ОС это пока что не дотягивало. У всего есть свои недостатки: местные «видеокарты», предоставляемые модом, имеют ограниченное количество операций, которые они могут сделать за игровой тик. Под операциями подразумевается изменение цвета текста, цвета фона, установка символа и т.п. Нетрудно себе представить, какое количество операций требовалось на отрисовку наших картинок и уж тем более на отрисовку рабочего стола. Но самая большая печаль заключалась в том, что мне необходимо было перерисовывать рабочий стол полностью, если, например, открыть контекстное меню или запустить какой-нибудь файл. Но тут на помощь мне пришел еще один товарищ и посоветовал написать алгоритм двойной буферизации изображения. Для тех, кто не в курсе, поясню вкратце его суть: в оперативной памяти у нас находятся два массива изображения: первый содержит информацию о пикселях, которые в данный момент отображены на экране, а второй — информацию о пикселях, которые мы хотим отрисовать. Затем при помощи вызова функции расчета алгоритм сверяет эти два массива и выводит на экран не все пиксели, а только лишь измененные. А затем присваивает первому массиву значение второго. Также в эту библиотеку я встроил несколько алгоритмов для ускорения работы местных GPU, группирующих соседние пиксели по цветам и объединяющие их в одну строку вместо поочередной отрисовки. И только теперь моя ОС заработала как надо! Иконки рисовались практически мгновенно, с компьютером стало крайне приятно взаимодействовать. Решив не останавливаться на достигнутом, я добавил несколько функций, симулирующих прозрачность изображения, и с их помощью сумел добиться довольно красивых результатов. Затем я накодил красивый файловый менеджер в стиле Finder из все той же Mac OS, и интегрировал его в систему. Добавил также сортировку файлов по имени, типу и дате изменения, добавил скрытие формата изображения, добавил меню «избранное». В итоге имеем следующее: Все это уже выглядит довольно неплохо, но за мной есть такой грешок как сильная любовь к хорошей графике. Поэтому я решил добавить поддержку обоев. Вот несколько примеров: К слову, сегодня написал HEX-редактор файлов, так как я не люблю платить за готовые решения, продающиеся в интернете. Вот так он выглядит в сочетании с обоями робочего стола. Итак, наша ОС готова! В совокупности мы имеем порядка 28 собственных библиотек, при этом некоторые из них имеют более 2-х тысяч строк кода. Также мы имеем около 30 качественных GUI-приложений. От начала изучения мода и до нынешнего времени прошел почти год, при этом программировали мы далеко не каждый день и не каждую неделю. Таким вот образом и написалась эта операционная система, а вслед за ней и эта статья. Как скачать? Если вам хочется пощупать эту ОС своими руками, то милости прошу, вот краткая инструкция: ставите на землю корпус компьютера, присоединяете к нему монитор, а к монитору прикрепляете клавиатуру. Затем вставляете в корпус лучшую видеокарту, процессор, оперативную память, жесткий диск, Lua-биос, стандартную дискету с OpenOS (скриптами автора мода), а также интернет-карту (не сетевую, а именно интернет). Затем включаете компьютер, ждете, пока система загрузится с дискеты, а затем вводите в консоль команду install. Далее выбираете цифру жесткого диска, жмете enter, и система поставится. Далее перезагружаете компьютер. Теперь ваш комп готов к установке уже моей операционной системы. Вводите в консоль команду pastebin run 0nm5b1ju, жмете enter и следуете инструкциям на экране. Желаю приятного использования. Итог Зачем, собственно, я писал эту статью? Мне хотелось показать людям, что на любом языке и в любой среде можно создать маленький, не побоюсь этого слова, шедевр. Еще полтора года назад я крайне смутно представлял себе, что такое «функция», «массив» или «класс», а теперь мы с товарищами кодим собственную мини-ОС. Главное — иметь свободное время и желание его потратить с пользой и с удовольствием, лично для меня нет большего кайфа, чем кодить всякую ерунду в любимой игре. Желаю всем начинающим и не очень начинающим программистам творческих успехов! Исходники Если кому интересно — можете покопаться в сырцах, там вы найдете все библиотеки, саму ОСь, программы и изображения. Авторы На всякий случай хочу перечислить остальных людей, которые так или иначе были связаны с этой ОС, которым так же, как и мне, было интересно изучать эту модификацию, да и язык Lua в целом. Глеб Трифонов — разработчик формата изображения, а также половины библиотек. Яков (фамилия неизвестна) — разработчик концепции двойной буферизации, помощник в оптимизации кода. Максим Пакин — автор нескольких программ для ОСи. Тимофей Шестаков — моральная поддержка команды, автор нескольких интересных идей по ускорению работы ОС.", "image": ["https://habrastorage.org/getpro/habr/post_images/266/93d/4d3/26693d4d3cd62fbeae423adec011f802.png", "https://habrastorage.org/getpro/habr/post_images/736/974/5ca/7369745ca5e70033d38a042bc91c11c0.png", "https://habrastorage.org/getpro/habr/post_images/6de/dd8/b35/6dedd8b3511c9023ac4488a1a26bce89.png", "https://habrastorage.org/getpro/habr/post_images/eeb/60e/e54/eeb60ee545804b31dd390c72980a561e.png", "https://habrastorage.org/getpro/habr/post_images/269/705/247/26970524772ee592de506b12ab4a0d8e.png", "https://habrastorage.org/getpro/habr/post_images/239/c22/7af/239c227aff16ae30fe5829c7c2143e6a.png", "https://habrastorage.org/getpro/habr/post_images/300/ae0/049/300ae00490ad0b193ef65831b215f984.png", "https://habrastorage.org/getpro/habr/post_images/926/92a/5e2/92692a5e2e913948a27349e1a33796e4.png", "https://habrastorage.org/getpro/habr/post_images/58b/4b9/abc/58b4b9abccfb4906ef3c058ba2140afc.png", "https://habrastorage.org/getpro/habr/post_images/c05/9a1/114/c059a11141d85cf8cc26f9fdf396ded3.png", "https://habrastorage.org/getpro/habr/post_images/d00/b81/5a3/d00b815a331ac53e906e7d349f8b1e88.png", "https://habrastorage.org/getpro/habr/post_images/a2c/bb7/580/a2cbb75803f9d03617ce6cbab1ff01a8.png", "https://habrastorage.org/getpro/habr/post_images/d4b/9dd/bed/d4b9ddbedd084e5ef044c7d861b5f57c.png", "https://habrastorage.org/getpro/habr/post_images/263/267/022/263267022b9277764cae44a800730954.png", "https://habrastorage.org/getpro/habr/post_images/dcc/256/068/dcc2560681c0fe27991aef89b300181d.png", "https://habrastorage.org/getpro/habr/post_images/288/795/8cc/2887958ccb09022453568580213f98aa.png", "https://habrastorage.org/getpro/habr/post_images/346/765/91d/34676591d3a4def86ae189b669e0b688.png", "https://habrastorage.org/getpro/habr/post_images/e4b/6b2/282/e4b6b22828a093eb0d423fea6eb1291a.png", "https://habrastorage.org/getpro/habr/post_images/35d/bf8/c2f/35dbf8c2f53c059787bad35b5ce746b0.png", "https://habrastorage.org/getpro/habr/post_images/541/b0c/2ae/541b0c2aec9e60621f9a48dc393bd618.png", "https://habrastorage.org/getpro/habr/post_images/5fe/c4c/354/5fec4c3541ecc9e0e7d3307aafe6906b.png", "https://habrastorage.org/getpro/habr/post_images/29b/6b7/997/29b6b79973705343e6f087e3c9929497.png", "https://habrastorage.org/getpro/habr/post_images/c60/f95/d5a/c60f95d5ada5ff3d9065a636a74271bd.png"], "tag": ["Minecraft", "Lua", "OS", "операционная система", "операционные системы", "ОС", "скриптинг", "OpenComputers", "ComputerCraft"], "rating": ["+95"], "bookmarks": ["173"], "views": ["76,8k"], "comments_count": ["125"]},
{"author": ["Sayman_nsk"], "date": ["14 ноября 2014 в 08:07"], "hubs": ["Lua", "Asterisk"], "type_label": [], "text": "Снова всех приветствую. После написания прошлой статьи про использование lua в астериске, пришла мысль про небольшое пояснение об использовании DEF-кодов совместно с lua. Ранее тут пролетала статья про генерацию кодов используя скрипт на php. Я этим скриптом успешно пользовался и пользуюсь, но с небольшими (совсем не большими) доработками. Приводить листинг самого скрипта не буду, вы можете его прочитать по ссылке: habrahabr.ru/post/150793 тут укажу только сами доработки. Первое — нам надо генерировать код на lua и сохранять его по стандартному «библиотечному» пути (/usr/lib/lua/5.1 или для 64бит систем /usr/lib64/lua/5.1). Для этого в выше упомянутом скрипте в самом его начале делаем запись: $dp = fopen('/usr/lib/lua/5.1/mphonetable.lua','w'); //lua dialplan эту строчку я вставил сразу после $defs = array(); Далее, в конце оригинального скрипта, после цикла foreach я добавил следующую запись, которая генерирует код на lua: # генерируем шаблоны для правила набора выхода через 9ку $linecode = '98'; fwrite($dp,\"extensions.mobile_out={\\n\"); foreach($regs as $op => $reg) { foreach($reg as $r) { fwrite($dp,\"\\t[\\\"_\"); echo \"\\t[\\\"_\"; echo $linecode.$r.'\"]=call_mobile;'.\"\\n\"; $line = $linecode.$r.'\"]=call_mobile;'.\"\\n\"; fwrite($dp,$line); } } # генерируем шаблоны для правила набора выхода без 9ки $linecode = '8'; foreach($regs as $op => $reg) { foreach($reg as $r) { fwrite($dp,\"\\t[\\\"_\"); echo \"\\t[\\\"_\"; echo $linecode.$r.'\"]=call_mobile;'.\"\\n\"; $line = $linecode.$r.'\"]=call_mobile;'.\"\\n\"; fwrite($dp,$line); } } fwrite($dp,\"\\tinclude = {\\\"out_trunk\\\"};\\n\"); fwrite($dp,\"}\\n\"); fclose($dp); call_mobile — это функция которая обрабатывает события выхода на сотовые. Второе — нам нужно применить изменения в Астериске: #-------------------------------------------------------- ob_implicit_flush(true); set_time_limit(0); #Основные настройки $host=\"192.168.xxx.xxx\"; # айпишник сами вставите $port=\"5038\"; $user=\"login\"; $pass=\"password\"; $wrets=\"\"; #открываем сокет $socket = fsockopen(\"$host\",\"$port\"); if (!$socket) exit(\"no connect to ats\"); #авторизация fputs($socket, \"Action: login\\r\\n\"); fputs($socket, \"Events: off\\r\\n\"); fputs($socket, \"UserName: $user\\r\\n\"); fputs($socket, \"Secret: $pass\\r\\n\\r\\n\"); fputs($socket, \"Action: command\\r\\n\"); fputs($socket, \"command: module reload pbx_lua\\r\\n\\r\\n\"); fputs($socket, \"Action: logoff\\r\\n\\r\\n\"); #читаем ответ while (!feof($socket)) { $line = fread($socket,8192); echo $line; } fclose($socket); # там далее идут две функции оригинального скрипта... Третье — сам скрипт вешаем в crone и забываем про его существование :) У меня скрипт исполнялся раз в сутки. На самом деле можно избежать громоздкой записи экстеншена и реализовать парсинг собития выхода на внешку через функцию, но тут спорный вопрос — не факт что это будет оптимально. Описание событий всё ровно составляется не руками, а автоматом, поэтому можно после написания вообще забыть про эту проблему. Про маршруты непосредственно самих звонков (какие направления через что или кого пропускать) тут вы уже сами решайте. У меня стояло около 8 gsm шлюзов. Для выхода на сотовые использовались два сотовых оператора с интересными тарифами. Эконимия должна быть экономной:). Всё. До свиданья!", "image": [], "tag": ["Asterisk", "lua", "def-коды"], "rating": ["+4"], "bookmarks": ["43"], "views": ["4,2k"], "comments_count": []},
{"author": ["alexeyknyshev"], "date": [" 8 ноября 2015 в 16:25"], "hubs": ["NoSQL", "Lua"], "type_label": ["Tutorial"], "text": "Многие знают про возможность хранить процедуры в sql базах данных, про это написано немало пухлых руководств и статей. Однако мало кто знает, что схожие возможности имеются и в Redis, начиная с версии 2.6.0. Но так как Redis не является реляционной БД, то и принципы описания хранимых процедур достаточно сильно отличаются. Хранимые процедуры в Redis — практически полноценные Lua скрипты (на момент написания статьи в качестве интерпретатора используется Lua 5.1). Дальнейшее повествование предполагает базовое знакомство с API Redis, а также, что процесс redis-server запущен на localhost:6379. Если вы новичок в Redis, то вам стоит перед прочтением следующего материала ознакомиться с краткой информацией о том, что такое Redis. А также пройти, хотя бы частично данное интерактивное руководство. Hello world! Используя redis-cli вернём из базы строку «Hello world!»: redis-cli EVAL 'return \"Hello world!\"' 0 Результат: \"Hello world!\" Давайте разберёмся, что только что произошло: Вызов встроенной в Redis команды EVAL с двумя аргументами. Первый return \"Hello world!\" — тело функции Lua. 0 — количество ключей Redis, которое будет передано в качестве параметров нашей функции. Пока мы не передаём ключи redis в качестве параметров, т.е. указываем 0. Интерпретация текста программы на сервере и возврат Lua-string значения Преобразование Lua-string в redis bulk reply Получение результата в redis-cli redis-cli выводит bulk reply на stdout Хранимые процедуры в Redis это обычные функции Lua, а следовательно и принцип получения и возврата аргументов аналогичен. Замечание: Lua поддерживает mul-return (возврат более чем одного результата из функции). Но чтобы возвратить несколько значений из redis, нужно использовать multi bulk reply, а из Lua в него отображаются таблицы, пример ниже не будет работать так, как вы возможно ожидаете: redis-cli EVAL 'return \"Hello world!\", \"test\"' 0 \"Hello world!\" Результат усекается до одного возвращаемого значения (первого). Hello %username%! Двигаемся дальше. Так как функции без аргументов особого интереса не представляют, добавим обработку аргументов в нашу функцию. Согласно документации функция, выполняемая через EVAL, может принимать произвольное количество аргументов через Lua таблицы KEYS и ARGV. Воспользуемся этим, чтобы поприветствовать %username%, если строка, содержащая его имя, передана в качестве аргумента, а иначе поприветствуем Habr. Вызываем без аргументов, массив-таблица ARGV в Lua пустая, т.е и ARGV[1] вернёт nil redis-cli EVAL 'return \"Hello \" .. (ARGV[1] or \"Habr\") .. \"!\"' 0 Результат: \"Hello Habr!\" А теперь в качестве параметра передадим строку «Иннокентий»: redis-cli EVAL 'return \"Hello \" .. (ARGV[1] or \"Habr\") .. \"!\"' 0 'Иннокентий' Результат: \"Hello \\xd0\\x98\\xd0\\xbd\\xd0\\xbd\\xd0\\xbe\\xd0\\xba\\xd0\\xb5\\xd0\\xbd\\xd1\\x82\\xd0\\xb8\\xd0\\xb9!\" Замечание: Redis хранит строки в utf8 и для того, чтобы избежать каких-либо проблем на стороне клиента в redis-cli символы, не входящие в ascii, выводятся в виде escape последовательностей. Чтобы увидеть читаемую строку в bash можно сделать так: echo -e $(redis-cli EVAL 'return \"Hello \" .. ARGV[1] .. \"!\"' 0 'Иннокентий') Доступ к API Redis из скриптов В каждый Lua скрипт интерпретатор загружает эти библиотеки: string, math, table, debug, cjson, cmsgpack Первые 4 — стандартные для Lua. 2 последние — для работы с json и msgpack соответственно. Для того чтобы взаимодействовать с данными в нашем хранилище в Lua экспортирован модуль 'redis'. Воспользовавшись функцией call в данном модуле, мы можем выполнять команды в формате, соответствующем командам из redis-cli. Рассмотрим использование redis.call на примере скрипта, который проверяет, существует ли пользователь в нашей базе, а если существует, то проверяет соответствие пары логин — пароль. Создадим в нашей базе тестовый набор данных, содержащий пары логин — пароль. redis-cli HMSET 'users' 'ivan' '12345' 'maria' 'qwerty' 'oleg' '1970-01-01' OK Убедимся, что всё действительно ОК: redis-cli HGETALL 'users' 1) \"ivan\" 2) \"12345\" 3) \"maria\" 4) \"qwerty\" 5) \"oleg\" 6) \"1970-01-01\" На вход скрипту будем подавать один аргумент, json строку в формате: { \"login\":\"userlogin\", \"password\":\"userpassword\" } Скрипт, должен возвращать 1, если пользователь существует и пароль в json совпал с паролем в базе, иначе 0. Если входной формат ошибочен, например не был передан аргумент скрипту (ARGV[1] == nil) или в json отсутствует одно из требуемых полей, возвратим читаемую строку, содержащую информацию об ошибке. Для разбора и упаковки json redis экспортирует в Lua модуль cjson. В нашем скрипте мы воспользуемся функцией decode из данного модуля. В качестве параметра функция принимает Lua-string, в которой содержится json, а возвращаемым значением является Lua-таблица, строковыми ключами которой являются json-поля. Создадим файл login.lua со следующим содержимым. Код скрипта login.lualocal jsonPayload = ARGV[1] if not jsonPayload then return 'No such json data' end local user = cjson.decode(jsonPayload) if not user.login then return 'User login is not set' end if not user.password then return 'User password is not set' end -- вызов redis API из Lua аналогичен стандартному API redis. local expectedPassword = redis.call('HGET', 'users', user.login) if not expectedPassword then return 0 end if expectedPassword ~= user.password then return 0 end return 1 Примеры использования: Пароли совпадают redis-cli EVAL \"$(cat login.lua)\" 0 '{\"login\":\"maria\",\"password\":\"qwerty\"}' (integer) 1 Пароли не совпадают redis-cli EVAL \"$(cat login.lua)\" 0 '{\"login\":\"maria\",\"password\":\"12345\"}' (integer) 0 В json отсутствует поле с паролем redis-cli EVAL \"$(cat login.lua)\" 0 '{\"login\":\"maria\",\"pwd\":\"12345\"}' \"User password is not set\" Не передан аргумент, содержащий json redis-cli EVAL \"$(cat login.lua)\" 0 \"No such json data\" Замечание: Всё ключи в Redis, а также работа с ними через SET и GET, имеют строковое представление. В Redis нет типа integer, и float тоже нет. Важно это понимать. В следующем примере мы возвращаем значение ключа test как строку: redis-cli SET test 5 OK Узнаем тип хранимого значения: redis-cli TYPE test string Вернём, но уже через скрипт: redis-cli EVAL \"return redis.call('GET', 'test')\" 0 \"5\" При этом нам никто не запрещает вернуть integer (в качестве integer bulk reply): redis-cli EVAL \"return tonumber(redis.call('GET', 'test'))\" 0 (integer) 5 Будьте осторожны с передачей Lua-number в качестве параметра функции redis.call: redis-cli EVAL \"return redis.call('SET', 'test', 5.6)\" 0 OK Значение усекается до меньшего целого redis-cli EVAL \"return tonumber(redis.call('GET', 'test'))\" 0 (integer) 5 Но что же там действительно внутри: redis-cli GET test \"5.5999999999999996\" Как «правильно»: redis-cli EVAL \"return redis.call('SET', 'test', tostring(5.6))\" 0 OK redis-cli GET test \"5.6\" По всей видимости преобразование Lua-number идёт не в интерпретаторе Lua, а в нативной части Redis, написанной на Си. На сегодня всё. Смотрите также redis.io/commands/eval www.redisgreen.net/blog/intro-to-lua-for-redis-programmers redislabs.com/blog/5-methods-for-tracing-and-debugging-redis-lua-scripts", "image": ["https://habrastorage.org/getpro/habr/post_images/71c/291/32d/71c29132d2412014c6064114be362655.png"], "tag": ["redis", "lua", "хранимые процедуры"], "rating": ["+16"], "bookmarks": ["107"], "views": ["16,4k"], "comments_count": ["44"]},
{"author": ["Sayman_nsk"], "date": ["14 ноября 2014 в 15:51"], "hubs": ["Разработка систем связи", "Lua", "Asterisk"], "type_label": [], "text": "И снова здрасьте! IVR — сегодня это даже не фишка, а некий стандарт работы предприятия. В некоторых случаях многие, как клиенты, так и конкуренты считают, что если этого самого IVR нет, то «там» низкое качество предоставляемых услуг. Этой штукой нынче никого не удивишь. Однако, мы же говорим про реализацию IVR на языке lua под Астериском. И если вы переходите от обычного плана набора к Lua, то тут можно кое-что пояснить. Предположим, что нужные файлы для меню у вас уже есть и они лежат в нужной папке. Возможно, что на старом конфиге они даже использовались. Тогда, при описании голосового меню на Lua делаем (я делал) так: Описываем где-то в начале файла табличку с файлами. Всё удобнее в одном месте при необходимости менять: mhold = { m_hello = \"custom/message_01\"; -- Приветствие m_menu = \"custom/message_02\"; -- описание меню m_thx = \"custom/message_05\"; -- Спасибо за выбор нашей компании... good_day = \"custom/wav_gd_2\"; -- типа \"Хорошего вам дня\"... comerc = \"custom/com_1\"; -- Нажмите для того-то 1 live = \"custom/live_2\"; -- ну и т.д. другие варианты выбора и нажатий. other = \"custom/other_3\"; } Таким образом вы описали в табличке поля с указанием применяемых файлов. В моём случае — файлы с приветствием, какие-то благодарственные слова и выборка меню. Так же был резервный (на всякий случай) вариант, при котором каждое меню было разбито на свой файл… Далее, в первой статье я в описании входящих звонков, в функции foo() указал вызов ivr(). Так вот, фактически в моём примере это работало так: Событие — Входящий звонок. Вызов foo(). Проверка некоторых условий -> проигрывание приветствия -> вызов ivr(). Само приветствие я проигрывал до вызова ivr(). function ivr(d) app.noop(\"Включено голосовое меню.\") app.noop(\"DID: \"..d) app.background(mhold.m_menu,\"\",\"\",\"menu\") app.waitexten(3) return end Не такая уж и навороченная функция. app.background тут и есть вызов из ядра астериска голосового меню. Но при этом нужно так же сделать описание события menu в экстеншинах: menu = { [\"1\"] = function(c,e) app.noop(\"Calling from menu by 1\") app.playback(mhold.m_thx) CallSKS() -- на обработчик вызова СКС end; [\"2\"] = function(c,e) app.noop(\"Calling from menu by 2\") app.playback(mhold.m_thx) app.goto(\"local_ext\",\"4690\",1) -- тут и далее я вызываю абонентов сразу группами. end; [\"3\"] = function(c,e) app.noop(\"Calling from menu by 3\") app.playback(mhold.m_thx) app.goto(\"local_ext\",\"4579\",1) end; [\"4\"] = function(c,e) app.noop(\"Calling from menu by 4\") app.playback(mhold.m_thx) CallSKS() -- тоже вариант обращения в клиентскую службу. end; }; При этом в описании входящих звонков from_trunk нужно добавить обработку таймаута, иначе если клиент не сделал выбор в течении нужного времени, клиент услышит короткие гудки, а в консоли астера вы увидите ошибку исполнения кода. from_trunk = { t = function() app.playback(mhold.m_thx) app.goto(\"local_ext\",\"7090\",1) end; -- далее остальная часть описания событий... Про IVR кажется всё. Теперь ещё один момент: ограничение времени звонка. Да, к сожалению мне и такое приходилось делать. Были отдельные кадры в компании, которые любили по межгороду просто десятками минут, а за месяц — часами болтать с друзьями, подругами, братьями и т.д. Конечно, таких наказывали рублём, но позиция руководства была такой, что на работе надо работать. Попросили ограничить болтунов во времени. В нижеследующем примере будет показано, как можно сделать это глобально, с выборкой направления (хотя возможно не самый лучший вариант). -- где-то внутри функции trunk_test if string.len(num) > 7 and not string.find(string.sub(num,1,4),\"8383\",1) then app.noop(\"Действует ограничение на длительность звонка 10 минут!!!\") app.dial(string.format(\"%s%s,60,tTL(600000:480000:60000)\",trunk.startel,num)) else app.noop(\"Звонок по городу.\") app.dial(string.format(\"%s%s,60,tT\",trunk.startel,num)) end В данном случае я сделал выборку по количеству символов в набираемом номере. Если количество символов превышает количество символов нашего города, исключая код нашего города, тогда это звонок по межгороду. Сотовые местные обрабатываются отдельно, поэтому под это правило не попадают (в прошлой статье про DEF-коды). А вот сотовые межгорода — попали. В моём примере действует ограничение на 10минут. за 7 (или 8?) минут абонент слышит лёгкий beep. В данной функции можно добавить обработку только конкретных «злодеев». Можно этих злодеев занести в таблицу и по ней уже смотреть, а можно в базу mysql и данные от туда вытаскивать, кому как удобно… Всё. Всем до свиданья!", "image": [], "tag": ["asterisk", "lua", "телефония"], "rating": ["+7"], "bookmarks": ["100"], "views": ["7,2k"], "comments_count": ["9"]},
{"author": ["starius"], "date": ["14 ноября 2014 в 11:57"], "hubs": ["Lua"], "type_label": [], "text": "Обсудим, как сделать шлюз из Интернета в скрытые сайты Tor. Сеть Tor — это система прокси-серверов, позволяющая устанавливать анонимное сетевое соединение. С помощью Tor можно анонимно подключаться к обычным серверам и хостить непрослушиваемые серверы в самой сети Tor. В последнем случае создается скрытый сервер в зоне onion. Имя сервера включает 16 букв и цифр (фингерпринт). Как можно заходить на скрытые серверы: установить Tor и направить через него трафик браузера. Tor-браузер — это portable-приложения, которое включает всё необходимое; однако не все люди устанавливают Tor-браузер, поэтому нужен способ показать содержимое скрытого сервера обычному пользователю сети. На помощь приходят сервисы tor2web, предоставляющие прямой доступ к скрытым сайтам. Сайт Hidden Wiki (kpvzxxbbraaigawj.onion) можно открыть в обычном браузере (kpvzxxbbraaigawj.tor2web.fi). Если пользователь подключается к сайту через tor2web, то он теряет анонимность в обмен на доступ к скрытому сайту без установки Tor. Приведу список подобных сервисов, некоторые из которых закрылись. *.Tor2web.org (3 сервера) *.Tor2web.fi *.Tor2web.blutmagie.de *.onion.sh (отключен) *.onion.to (отключен) *.onion.lu (отключен) *.t2w.pw (отключен) *.tor2web.ae.org (отключен) Рассмотрим существующие способы запустить tor2web-сервис, после чего я поделюсь своим собственным. Проект Tor2web-3.0? Tor2web-3.0 — важная часть проекта GlobaLeaks, которая облегчает доступ пользователей сети к скрытым серверам. Пример сайта: kpvzxxbbraaigawj.tor2web.org К проекту Tor2web-3.0 подключено 3 сервера. Можно установить Tor2web на свой сервер и примкнуть к их сети. Отключенные серверы .lu и .to принадлежат тем же людям. Tor2web-3.0 устанавливается как отдельная служба. Код написан на Python. К Tor2web-3.0 практически нет нареканий, но мне хотелось избежать дополнительного участника (пользователь — Nginx — Tor2web-3.0 — Tor — целевой сайт). Кроме того, мне не по душе сетевой софт, написанный на Python. Polipo? Polipo — HTTP-сервер, который умеет перенаправлять подключения в SOCK5-сервер. Раньше Polipo использовался для этой цели в составе Tor-браузера. Можно было бы выстроить цепочку: Nginx — Polipo — Tor. Как и в случае с Tor2web-3.0, возникает лишний участник, так как Nginx не умеет проксировать трафик через SOCK5-сервер. Кроме того, для нормального отображения сайтов хочется заменять в ответе сервера onion-ссылки ссылками на шлюз: s/.onion/.onion.xx/ Патчим Nginx? Существует патч для Nginx, который добавляет возможность проксировать трафик через SOCK5-сервер. На самом деле, протокол SOCKS5 очень простой, поэтому странно, что до сих пор нет официального модуля. Это решение выглядит заманчивым, но оно не доведено до ума: пришлось бы патчить Nginx при каждом обновлении. Хочется иметь решение, которое бы работало на обычном Nginx из коробки Debian Wheezy. Кроме того, нет возможности заменять ссылки в ответе сервера. Пишем модуль для Nginx на Lua Nginx давно поддерживает возможность встраивать сценарии на Lua. Коду на Lua предоставляется широкий круг возможностей, в том числе манипуляции с сокетами прямого доступа. К сожалению, модуль для подключения к SOCKS5-серверу я не нашел, поэтому написал свой. Для каждого запроса устанавливается соединение с программой Tor через порт 9050, проходит рукопожатие SOCKS5 и передаётся адрес целевого сайта. После этого сокет используется, как если бы это был прямой сокет к целевому сайту. Запрос пользователя считывается в память, редактируется и передаётся серверу. Ответ сервера считывается, редактируется (замена ссылок) и передается пользователю. Все операции неблокирующие. Эту часть я оформил как отдельный модуль onion2web. При первом подключении к сайту пользователь видит заглушку с формой подтверждения захода на сайт. Это нужно, чтобы нельзя было включать картинки со скрытых сервисов в страницы обычных сайтов. Модуль socks5 содержит функции, с помощью которых сокет пробрасывается через SOCK5-сервер. Функции описаны на страничке модуля. Модуль onion2web содержит одну функцию handle_onion2web, которая обслуживает tor2web-шлюз. Пример использования см. ниже. Есть возможность задать адрес и порт тора и отключить форму подтверждения захода на сайт. Недоработки: реализован очень простой HTTP-клиент версии 1.0, в котором отключены keep-alive и сжатие передаваемых данных. Запрос и ответ читаются целиком в память, после чего передаются получателю. Это увеличивает расход памяти и замедляет передачу информации, особенно в направлении от сайта к пользователю. Подозреваю, что с SOCKS5-сервером нужно общаться в отдельной сопрограмме. Возникнут сложности с подменой адресов в ответе сервера (граница блоков данных может прийтись на заменяемый адрес). Форма загрушки не содержит защиты от CSRF и всегда перенаправляет на главную страницу (лучше перенаправлять на путь, который был открыт изначально). Ответ сервера надо редактировать более аккуратно: заменять ссылки только в HTML и только в атрибутах. На этом варианте я и остановился и использовал его для своего tor2web-шлюза. К недостаткам самого сайта можно отнести отсутствие SSL. Думаю, есть и другие недостатки. И вообще пока решение скорее костыльное. Как поднять свой tor2web-шлюз Нужны домен, сервер и wildcard SSL-сертификат на этот домен. В домене нужно прописать всем поддоменам IP-адрес нашего сервера: На сервере потребуется Tor, Nginx со свежим ngx_lua и мой модуль onion2web для подключения к SOCKS5-серверу из Nginx. В Debian Wheezy есть пакет nginx-extras, который содержит слишком старый ngx_lua. (Этой старый ngx_lua не поддерживает некоторых используемых методов, например, ngx.req.raw_header.) Версия nginx-extras из wheezy-backports содержит достаточно свежий ngx_lua. Модуль onion2web можно установить через luarocks (это автоматически установит модуль socks5 как зависимость). Установка для Debian Wheezy: # echo deb http://ftp.us.debian.org/debian/ wheezy-backports main > /etc/apt/sources.list.d/wheezy-backports.list # apt-get update # apt-get install tor luarocks nginx-extras/wheezy-backports # luarocks install onion2web В Nginx создаем такой сайт: server { listen 80; server_name *.onion.gq; location / { default_type text/html; content_by_lua ' require(\"onion2web\").handle_onion2web(\".onion.gq\"); '; } } Домен фигурирует в конфиге в двух местах: server_name и внутри Lua-кода. Сайт готов: kpvzxxbbraaigawj.onion.gq Исходники модуля socks5: github.com/starius/lua-resty-socks5 Исходники модуля onion2web: github.com/starius/onion2web", "image": ["https://habrastorage.org/getpro/habr/post_images/cc6/375/1eb/cc63751eb0554695e51e885642fb24bd.png", "https://habrastorage.org/getpro/habr/post_images/6b4/697/5b2/6b46975b2b8c2bf7ae6aee0ae0ea6135.png", "https://habrastorage.org/getpro/habr/post_images/137/b26/587/137b26587832161aa9cccade616cd85a.png", "https://habrastorage.org/getpro/habr/post_images/773/a13/45d/773a1345d47678ba85f68f0d7f4ec5a2.jpg", "https://habrastorage.org/getpro/habr/post_images/119/914/8f2/1199148f2c93671a9e8d4818ab5e9a5f.png", "https://habrastorage.org/getpro/habr/post_images/3c2/2cf/d02/3c22cfd0247271075b30c554771a5eae.png"], "tag": ["tor", "tor2web", "onion", "onion2web", "nginx", "lua", "openresty", "ngx_lua", "web-proxy", "тор", "луа", "веб-прокси"], "rating": ["+18"], "bookmarks": ["186"], "views": ["20,1k"], "comments_count": ["8"]},
{"author": ["JDTamerlan"], "date": ["13 января 2015 в 09:55"], "hubs": ["Lua", "C++"], "type_label": [], "text": "Привет всем! Несколько лет назад меня начал беспокоить вопрос создания статических (создаваемых и изменяемых до процесса компиляции) перечислений. Перечислений я хотел не простых, которые реализованы в С/С++, а с набором дополнительных возможностей, в том числе и ассоциированными столбцами данных произвольного типа, своего рода статическая база данных с доступом по уникальному идентификатору. Тогда в моем понимании ясно выделились три типа объектов, которые могут быть уникальным идентификатором: числовой индекс, числовой идентификатор, символьный идентификатор. При попытке применить каждый из них для решения задачи перехода от ключа к значению сформировались основные их недостатки и преимущества: Числовой индекс — это уникальное целочисленное значение, элемент последовательного массива, для С/С++ это диапазон [0;n), где n — размер массива. Если мы видим индекс 5, то это подразумевает, что обязательно есть и индексы [0;4]. Примеры: индекс классического С-массива, хеш-таблица, адрес ячейки физической памяти. Краткий вывод: скорость обработки максимальная, сопровождаемость минимальная. Числовой идентификатор — это уникальное целочисленное значение, которое лишено обязанности быть последовательным. Примеры: дескриптор произвольного (файл, сокет, устройство) объекта, идентификатор потока, адрес какой-то переменной или функции в процессе. Краткий вывод: скорость обработки высокая, сопровождаемость средняя. Символьный идентификатор — это уникальное строковое значение, которое, в отличие от чисел, само по себе наделено некоторым логическим смыслом. Примеры: препроцессорное определение с помощью #define, классическое перечисление с помощью enum, название переменной в программе, ключ в объекте json, значение в формате XML. Краткий вывод: скорость обработки минимальная, сопровождаемость максимальная. Основная задача проекта EnumGenerator — сгенерировать перечисление, которое удобно, безопасно и эффективно объединяет эти идентификаторы в единую конструкцию. Чтобы к одному значению можно было обратиться тремя способами: Очень быстро по числовому индексу. Для основного использования в тексте программы. Пример: обычное перечисление. Быстро и гибко по числовому идентификатору. Для сохранения значения в энергонезависимое хранилища и безопасное восстановление из него. Для обмена данными с другими программами, которые могут иметь более старую или более новую версию этого же перечисления. Пример: база данных, протокол сетевого взаимодействия. Удобно и наглядно по символьному идентификатору. Для сохранения значения в конфигурационный файлы, который может редактироваться человеком, и безопасное восстановление из него. Пример: файл конфигурации *.ini, *.json, *.yaml,*.xml. Входные данные EnumGenerator, перечисление Color3 в таблице Excel: Выходные данные EnumGenerator: Перечисление Color3 в файле 'Enums.hpp'class Color3 { public: enum Value { Black = 0, //! men in black Blue = 1, //! blue ocean Green = 2, //! green forest Invalid = 3, Red = 4, //! lady in red White = 5 //! white snow }; static const int ValueCount = 6; static const Value ValueInvalid = Invalid; Color3(Value val = ValueInvalid) : m_ValueCur(val) {} Color3(const Color3 &other) : m_ValueCur(other.m_ValueCur) {} explicit Color3(int val) : m_ValueCur(ValueInvalid) { int index = NS_JDSoft::NS_EnumGenerator::ValueFindLinear(IDInteger, ValueCount, val); if (index >= 0) m_ValueCur = Value(index); } explicit Color3(const char * val) : m_ValueCur(ValueInvalid) { int index = NS_JDSoft::NS_EnumGenerator::StringFindBinary(StringValues, ValueCount, val); if (index >= 0) m_ValueCur = Value(index); } Color3 &operator =(Value val) { m_ValueCur = val; return *this; } Color3 &operator =(const Color3 &other) { m_ValueCur = other.m_ValueCur; return *this; } bool operator ==(Value val) const { return m_ValueCur == val; } bool operator ==(const Color3 &other) const { return m_ValueCur == other.m_ValueCur; } bool isValid() const { return m_ValueCur != ValueInvalid; } Value toValue() const { return m_ValueCur; } int toInt() const { return IDInteger[m_ValueCur]; } const char * toString() const { return StringValues[m_ValueCur]; } static const char * enumName() { return \"Color3\"; } private: static const char * const StringValues[ValueCount]; static const int IDInteger[ValueCount]; Value m_ValueCur; }; Перечисление Color3 в файле 'Enums.cpp'const char * const Color3::StringValues[Color3::ValueCount]= { \"Black\", \"Blue\", \"Green\", \"Invalid\", \"Red\", \"White\" }; const int Color3::IDInteger[Color3::ValueCount] = { 0, 255, 65280, -1, 16711680, 16777215 }; Пример использования перечисления Color3 в тестовом проекте Qt: #include \"Enums.hpp\" ... // Создание объекта перечисления и проверка невалидности его значения Color3 colorPen; QCOMPARE(colorPen.isValid(), false); // isValid() QVERIFY(colorPen == Color3::Invalid); // operator ==(Value val) // Проверка правильности основных преобразований QCOMPARE(colorPen.toValue(), Color3::Invalid); // toValue() QCOMPARE(colorPen.toInt(), -1); // toInt() QCOMPARE(colorPen.toString(), \"Invalid\"); // toString() // Задание валидного значения colorPen = Color3::Red; // operator =(Value val) QCOMPARE(colorPen.isValid(), true); // Проверка правильности основных преобразований QCOMPARE(colorPen.toValue(), Color3::Red); QCOMPARE(colorPen.toInt(), 0xFF0000); QCOMPARE(colorPen.toString(), \"Red\"); // Создание объекта с известным значением QCOMPARE(Color3(Color3::Green).toString(), \"Green\"); QCOMPARE(Color3(0x00FF00).toString(), \"Green\"); QCOMPARE(Color3(\"Green\").toString(), \"Green\"); // Сравнение объектов QVERIFY(Color3(0x0000FF) == Color3(\"Blue\")); // operator ==(const Color3 &other) Как попробовать EnumGenerator? Скачать проект на свой компьютер, Download zip и распаковать его. Запустить файл Enums.lua в интерпретаторе lua. Самый простой способ для пользователей windows: 1) Скачать минимальную версию интерпретатора lua и распаковать его. 2) Щелкнуть правой кнопкой мыши по файлу 'Enums.lua', кликнуть «Открыть» или «Открыть с помощью» и выбрать распакованный файл 'lua.exe'. Убедиться, что в директории сгенерировались файлы 'Enums.hpp' и 'Enums.cpp'. Готово! :) Как использовать EnumGenerator в своем проекте? Попробовать EnumGenerator как описано в предыдущем пункте. Переместить директорию с файлом 'EnumGenerator.lua' в стабильное место. Путь к директории с файлом 'EnumGenerator.lua' будем называть 'ENUMGENERATOR_PATH'. Открыть файл 'Enums.lua' и отредактировать его так, чтобы переменная EnumGenerator содержала полный путь к генератору. Для этого и последующих проектов это нужно сделать один раз. Скопировать файлы 'Enums.xls' и 'Enums.lua' в директорию своего проекта. Отредактировать файл 'Enums.xls' в Excel или OpenOffice для своих перечислений. Сохранить отредактированный файл 'Enums.xls' как есть, дополнительно сохранить его в формате csv в файл 'Enums.csv' и закрыть редактор. Запустить файл Enums.lua из директории своего проекта в интерпретаторе lua и убедиться, что генерация прошла успешно: При запуске в консольном режиме скрипт пишет «Successfully completed!». При запуске из другой программы код возврата интерпретатора равен 0. Схема прохождения данных при использовании EnumGenerator: Вот пример, который наглядно демонстрирует основные возможности использования генератора, файл Excel. Рассмотрим часть этого файла более подробно: Структура входного файла: Файл состоит из независимых частей-блоков, [0;∞]. Каждая часть (Part) начинается словом «PartBegin» и заканчивается словом «PartEnd» в самой левой ячейке. После «PartBegin» в этой же ячейке в круглых скобках указываются обязательные и опциональные параметры этой части, пример: PartBegin(Type=Enum, Name=Country). Все строки между «PartBegin» и «PartEnd» являются телом части (PartData). Последовательность частей учитывается. Тело части (PartData) состоит из 0-го столбца (самый левый), который определяет тип всей строки и последующих ячеек [0;∞]. Сейчас реализовано 3 типа: Header — заглавие данных, Comment — комментарий, \"\"(пустая строка) — содержит основные данные в соответствии с заглавием. Заглавие данных (Header) описывает обязательный идентификатор столбца и возможные дополнительные параметры. Надеюсь, это выглядит наглядным, простым и логичным. Буду рад отзывам и советам по улучшению, спасибо! Связанные ссылки: String enum — строковые enum Ещё одна реализация Enums для Python", "image": ["https://habrastorage.org/files/fb3/52b/b11/fb352bb11a024eeb9288c94a6132b130.png", "https://habrastorage.org/files/650/627/b8c/650627b8c86b45d293f40f15c6090788.png", "https://habrastorage.org/files/ede/db8/e57/ededb8e5723a4f6b8941845e03170970.png"], "tag": ["excel", "csv", "lua", "кодогенерация", "c++", "enumerations", "enum"], "rating": ["+4"], "bookmarks": ["24"], "views": ["4,5k"], "comments_count": ["9"]},
{"author": ["Adda_Ald"], "date": ["30 января 2015 в 00:21"], "hubs": ["Lua"], "type_label": ["Перевод"], "text": "Один итальянский магазинчик нащупал новые способы использования Телеграма (и ранее WhatsApp'а), установив его на одноплатный миниатюрный компьютер Raspberry Pi. Как выясняется, мессенджер можно использовать для удалённого общения с собственной техникой. Ниже – перевод статей (1, 2) с сайта Instructables.com. Если есть уточнения по переводу, напишите об этом в комментариях. I. Telegram на Raspberry Pi Шаг первый: инсталляция Понадобится: Raspberry Pi B or B+, с последней версией Raspbian, или карта MIcroSD на 8Гб класса 10 с той же предустановленной Raspbian. Сначала обновите пакеты программ: sudo apt-get update sudo apt-get upgrade Установите библиотеки: readline или libedit, openssl и (если вы хотите использовать конфигурацию) libconfig и liblua. Если вам удобнее без них, проставьте --disable-libconfig и --disable-liblua соответственно. sudo apt-get install libreadline-dev libconfig-dev libssl-dev lua5.2 liblua5.2-dev libevent-dev make Клонируйте архив GitHub git clone --recursive https://github.com/vysheng/tg.git && cd tg ./configure make Выполнение этой команды займёт некоторое время, после чего установка будет завершена. Upd: запустите мессенджер и настройте аккаунт, введя номер телефона и(ли) ник. См. Шаг второй: автоматическая отправка сообщений Чтобы автоматически отправить сообщение, создайте файл sudo nano /home/pi/tg.sh с таким содержимым: #!/bin/bash to=$1 msg=$2 tgpath=/home/pi/tg cd ${tgpath} (echo \"msg $to $msg\"; echo \"safe_quit\") | ${tgpath}/bin/telegram-cli -k tg-server.pub -W Сохраните и закройте его, дав разрешение на действия: sudo chmod -R 0655 /home/pi/tg.sh Протестируйте его с помощью /home/pi/tg.sh Name_lastname \"your message\" Чтобы отправить фото, создайте файл sudo nano /home/pi/tg_photo.sh и впишите в него #!/bin/bash to=$1 msg=$2 tgpath=/home/pi/tg cd ${tgpath} (echo \"send_photo $to $msg\"; echo \"safe_quit\") | ${tgpath}/bin/telegram-cli -k tg-server.pub -W Сохраните и закройте его, дав разрешения: sudo chmod -R 0655 /home/pi/tg_photo.sh и протестируйте с помощью /home/pi/tg_photo.sh Name_Lastname /folder/photo.png II. Дистанционное управление Raspberry Pi через Telegram Телеграм – весьма разносторонний мессенджер для отправки мгновенных сообщений, в котором можно работать, используя один телефонный номер, одновременно на нескольких устройствах. В предыдущем обзоре мы увидели, как его установить, как отправлять текст и медиафайлы. Мы также убедились, что в Raspberry можно настроить автоматическую отправку сообщений через Telegram. На этот раз мы попросим Raspberry выполнить конкретное действие как функцию полученного сообщения: например, мы могли бы послать слово «photo», чтобы Raspberry прислал нам фотографию дома, или «lamp», чтобы он повернул лампу, или «open», чтобы открыть дверь гаража. Начнём. Шаг первый: инсталляция Начинаем на основе описанных выше действий. Чтобы перехватить новое входящее сообщение, мы создаём файл action.lua (я опускаю описание языка Lua со ссылкой на официальный сайт, так как хабраюзеры с ним, очевидно, знакомы. — Прим. пер.): sudo nano /home/pi/tg/action.lua со следующим содержимым: function on_msg_receive (msg) if msg.out then return end if (msg.text=='ping') then send_msg (msg.from.print_name, 'pong', ok_cb, false) end end function on_our_id (id) end function on_secret_chat_created (peer) end function on_user_update (user) end function on_chat_update (user) end function on_get_difference_end () end function on_binlog_replay_end () end Сохраните и закройте файл. Теперь, когда входящее сообщение – «ping», Телеграм отвечает сообщением «pong». Перейдите в tg cd /home/pi/tg и напишите: bin/telegram-cli -k tg-server.pub -W -s action.lua Попробуйте отправить сообщение. Если всё верно, Телеграм отвечает только на «ping» (не на «PING»), и мы должны увидеть что-то вроде этого: Окей, давайте попробуем что-то более занятное. Установите камеру Raspberry (см. этот туториал) и создайте новую папку, куда по умолчанию будут сохраняться фотографии с этой камеры. sudo mkdir /home/pi/camera Создайте новый файл «camera.ch» sudo nano /home/pi/camera/camera.sh вот с этой начинкой #!/bin/bash raspistill -w 800 -h 600 -o /home/pi/camera/photo.jpg Сохраните и закройте его, дав разрешение на действия sudo chmod -R 0655 /home/pi/camera/camera.sh Отредактируйте «action.lua» sudo nano /home/pi/tg/action.lua и добавьте эти строки в функцию on_msg_receive: if (msg.text=='photo') then os.execute('/home/pi/camera/camera.sh') send_photo (msg.from.print_name, '/home/pi/camera/photo.jpg', ok_cb, false) end Шаг второй: тест bin/telegram-cli -k tg-server.pub -W -s action.lua Теперь, если вы пошлёте сообщением слово «photo», Raspberry ответит фотографией. Чтобы задать дополнительные команды, просто измените файл «action.lua», добавив новый блок «if». Например, можно активировать выключатель или запросить статус сигнализации.", "image": ["https://habrastorage.org/files/225/0f8/da5/2250f8da5ea2443db721e03f5f5e70ce.jpg", "https://habrastorage.org/files/16d/d87/1aa/16dd871aa7a14da281c8c1b77cf5a371.png", "https://habrastorage.org/files/dd7/1aa/bd0/dd71aabd05b040eaaf0d64890bafa363.png", "https://habrastorage.org/files/40d/874/41d/40d87441d6ad43d69ef422c9192552a7.jpg", "https://habrastorage.org/files/8cd/647/884/8cd6478841944232a01f36d3a390d0df.png", "https://habrastorage.org/files/d0d/6c6/1b2/d0d6c61b2eb246cba91ccaacdc23c17d.png", "https://habrastorage.org/files/8d2/8ed/46f/8d28ed46fc384eb1af25529484889a2b.png", "https://habrastorage.org/files/63f/d5d/ad3/63fd5dad359641e48c1e6deb92a0a261.jpg", "https://habrastorage.org/files/40d/874/41d/40d87441d6ad43d69ef422c9192552a7.jpg"], "tag": ["raspberry", "telegram", "lua", "умный дом"], "rating": ["+36"], "bookmarks": ["618"], "views": ["72,1k"], "comments_count": ["62"]},
{"author": ["dannote"], "date": ["16 ноября 2014 в 11:51"], "hubs": ["Lua", "Программирование", "Разработка веб-сайтов"], "type_label": [], "text": "Синтаксис Lua позволяет реализовать шаблоны в стиле PHP буквально несколькими регулярными выражениями. Для начала посмотрим, что из этого выйдет. Подстановка переменных <a href=\"<%url%>\"><%label%></a> Логические конструкции Будет <? if 1 > 2 then ?> лучше <? else ?> хуже <? end ?> Циклы <ul> <? for i = 1, 9999 do ?> <li>ФЗ №<%i%></li> <? end ?> </ul> Подключение других шаблонов <html> <script><? require \"scripts\" ?></script> <style><? require \"styles\" ?></style> ... <? require 'tracking' ?> И любые другие конструкции на Lua <? function warn() ?> <b>Вы совершаете уголовно наказуемое деяние!</b> <? end ?> ... <? warn() ?> ... <? --[[ ?> Больше нечего скрывать <? --]] ?> И это все собирается одной командой в обычный модуль Lua: (echo 'return function(_)_[=['; sed -e 's/[][]=[][]/]=]_\"\\0\"_[=[/g; s/<%/]=]_(/g; s/%>/)_[=[/g; s/<[?]/]=] /g; s/[?]>/ _[=[/g'; echo ']=] end') < template.tpl > template.lua На самом деле, для запуска потребуется написать еще одну короткую функцию: function template.print(data, args, callback) local callback = callback or print local function exec(data) if type(data) == \"function\" then local args = args or {} setmetatable(args, { __index = _G }) setfenv(data, args) data(exec) else callback(tostring(data)) end end exec(data) end Установка Маленькая библиотека из трех функций доступна в Moon Rocks: luarocks install template luarocks, в свою очередь, имеется в репозиториях Ubuntu: sudo apt-get install luarocks Проект на GitHub.", "image": [], "tag": ["lua", "lua-nginx-module", "шаблонизаторы", "спагетти"], "rating": ["+15"], "bookmarks": ["27"], "views": ["6,3k"], "comments_count": ["20"]},
{"author": ["TeamMRG"], "date": ["21 июля 2014 в 14:32"], "hubs": ["Lua", "Блог компании Mail.Ru Group", "Программирование"], "type_label": [], "text": "13 и 14 сентября (суббота и воскресенье) в Москве, в офисе Mail.Ru Group пройдёт крупнейшая ежегодная конференция, посвящённая языку программирования Lua — Lua Workshop 2014. Эта международная англоязычная конференция проводится в этом году в 9-й раз. В 2012 году она проходила в Рестоне (США), в 2013 — в Тулузе (Франция), ну а в этом году конференция приезжает в Москву. Если вы пишете на Lua, вопрос посещать или не посещать конференцию не возникнет: когда ещё будет возможность вживую пообщаться с создателем языка и автором «Programming in Lua» Роберто Иерусалимским? Да и просто (бесплатно!) поучаствовать в конференции, узнать больше о вашем языке программирования из первых рук. Если же вы ещё не пишете на Lua, стоит заметить, что конференция обещает быть крайне насыщенной. Lua используется далеко не только в индустрии компьютерных игр, но и является встроенным языком расширений в таких инструментах web-программирования как Redis, nginx, Tarantool, OpenResty. При этом Lua стоит в стороне от mainstream, JavaScript, Node.js, MongoDB и прочих. Видимо, поэтому уже сейчас в списке участников конференции можно заметить таких гуру, как Игорь Сысоев. :) И конечно же, если вы ещё не пишете на Lua, то пора начинать писать на Lua! Программа конференции ещё только формируется, но уже известно о целом ряде интересных докладов: о внутреннем устройстве Lua, LuaJIT и технологии tracing just-in-time compilation, об экосистеме Lua и создании пакетов и модулей для Lua, о будущем языка и новых возможностях — Lua 5.2 и Lua 5.3. Итак, ждём всех на Lua Workshop Moscow 2014, регистрация открыта и бесплатна, количество мест ограничено! http://www.lua.org/wshop14.html http://luaconf.ru/ Видео и слайды докладов с предыдущих конференций доступны здесь: http://www.lua.org/wshop13.html#abstracts http://www.lua.org/wshop12.html", "image": ["https://habrastorage.org/getpro/habr/post_images/583/2af/bde/5832afbde06b11a608ef885d8502ae87.png"], "tag": ["Lua Workshop", "mail.ru", "lua"], "rating": ["+30"], "bookmarks": ["14"], "views": ["4,8k"], "comments_count": ["14"]},
{"author": ["maisvendoo"], "date": ["16 января 2015 в 02:51"], "hubs": ["D", "Lua", "Программирование"], "type_label": [], "text": "Предисловие Данная заметка не будет слишком уж объемной, а скорее даже наоборот, небольшой. Достаточно продолжительное время я слежу за серией статей о языке D, публикуемой на Хабре. Ознакомившись с рядом источников, начиная от Википедии и заканчивая официальными руководствами по данному языку, пришел к выводу о целесообразности использования оного в своих научных проектах. Главный проект по докторской диссертации зашел в состояние тупика, требовал переработки (всплыл ряд механических вопросов). Переработку проекта и изучение нового для меня языка было решено совместить. Сказано сделано — большая часть кода довольно быстро была перенесена с C/C++ на D. Не смотря на различные мнения по поводу D бытующие в среде разработчиков ПО, язык пришелся мне по вкусу. Одна беда — в старом варианте проекта для задания параметров модели поезда и изменения логики работы без перекомпиляции использовался Lua-скриптинг. Те кто сталкивается с ним по роду деятельности знают, что существует хорошо разработанный и достаточно документированный API для разработки на C/C++. Что касается Lua-скриптинга в D, то существует ряд проектов, например LuaD, привносящий в программы на D возможность работы с Lua. Однако LuaD рассчитан на предыдущую версию 5.1. Попадался мне проект и для 5.2 — DerelictLua, однако навскидку с «легкого пинка» завести его не удалось. При наличии времени можно разобраться, но времени как всегда нет. Пришлось напрячь мыслительные мощности и придумать более быстрое и простое решение. Если читателю интересно, что из этого вышло, добро пожаловать под кат. 1. Вызов C-функций из программы на D Реализуется это не просто, а очень просто — в модуле D пишем прототип функции, указывая что она расположена во внешнем модуле и использует C-соглашение о вызове функций extern(C) double my_C_func(int param1, double param2); Естественно, внешний модуль надо тем или иным способом скомпоновать с программой на D. В этой связи возникла первая идея — реализовать работу с Lua на C, а прототипы прописать в модуле на D и скомпилировать всё в одну программу. Был даже переделан скрипт сборки проекта (использую SCons) таким вот образом SConstruct для компиляции программы из модулей на C/С++ и D#-------------------------------------------------------------------- # Project globals #-------------------------------------------------------------------- source_dir = 'src/' d_include_path = 'src/D/' release_target_dir = 'bin/release/' debug_target_dir = 'bin/debug/' target_name = 'train' #-------------------------------------------------------------------- # Release build configuration #-------------------------------------------------------------------- release_env = Environment( CC='gcc', CXX='g++', DMD='dmd', DPATH=d_include_path, LINK='gcc', CPPFLAGS='-O3', DFLAGS='-O' ) release_env.VariantDir(release_target_dir, source_dir, duplicate=0) d_sources = Glob(release_target_dir + 'D/*.d') c_sources = Glob(release_target_dir + 'C/*.c') c_obj = release_env.Object(c_sources) d_obj = release_env.Object(d_sources) release_env.Program(release_target_dir + target_name, d_obj + c_obj, LIBS=['phobos2', 'lua']) #-------------------------------------------------------------------- # Debug build configuration #-------------------------------------------------------------------- debug_env = Environment( CC='gcc', CXX='g++', DMD='dmd', DPATH=d_include_path, LINK='gcc', CPPFLAGS='-g3', DFLAGS='-g' ) debug_env.VariantDir(debug_target_dir, source_dir, duplicate=0) d_sources = Glob(debug_target_dir + 'D/*.d') c_sources = Glob(debug_target_dir + 'C/*.c') c_obj = debug_env.Object(c_sources) d_obj = debug_env.Object(d_sources) debug_env.Program(debug_target_dir + target_name, d_obj + c_obj, LIBS=['phobos2', 'lua']) После успешного чтения тестового Lua-скрипта пришло понимание того, что сущностей слишком много — зачем писать модуль на C, если можно написать его на D, а необходимые функции экспортировать непосредственно из liblua.so?!? К тому же на D можно реализовать уже необходимый мне функционал, оформив его скажем в виде класса (так было сделано в предыдущей C++-версии проекта). Вооружившись руководством к Lua 5.2 и лежащими в /usr/include/ заголовочными файлами я приступил. Первоначально была мысль экспортировать только нужные мне функции и остановится на этом. Но потом мне стало стыдно — наверняка результаты этой работы могут пригодится кому-нибудь ещё. Поэтому C API к Lua был практически полностью портирован на D. 2. D-библиотека для работы с Lua API Результат доступен на GitHub В архиве содержаться следующие файлы lua.d — прототипы основных функций lualib.d — функции для работы с библиотеками Lua lauxlib.d — дополнительные функции luaconf.d — описание некоторых типов и констант Что касается последнего файла то он портирован в той части, что используется внутри остальных модулей. Эту работу ещё предстоит проделать. В остальном данная библиотека позволяет использовать интерфейс к Lua из программы на D, так, как это делается при разработке на C/C++. Перечисленные модули подключаются к проекту на D и он компонуется с библиотекой liblua.so (ключ линкера -llua, если речь идет GNU/Linux). Реализованы все функции, описанные в Lua C API. При написании модулей все макросы в оригинальных заголовках, реализующие упрощенные вызовы базовых функций API, были заменены функциями. Для проверки был написан крошечный скрипт на Lua test.lua -- Глобальная переменная целого типа nv = 2 -- Функция, вычисляющая квадрат аргумента my_number_sqr = function(x) return x*x end Для его чтения пишем такой код на D, подключая нужные библиотеки main.d module main; import std.stdio; import lua; import lualib; import lauxlib; //------------------------------------------------------------------- // //------------------------------------------------------------------- void main() { // Получаем состояние интерпретатора Lua и грузим все библиотеки lua_State *lua_state = luaL_newstate(); luaL_openlibs(lua_state); // Выполняем тестовый скрипт if (luaL_dofile(lua_state, \"test.lua\")) { writeln(\"Error\"); } // Читаем целочисленное значение // Запоминаем вершину стека Lua int top = lua_gettop(lua_state); // Кладем в стек значение nv lua_getglobal(lua_state, \"nv\"); // Снимаем полученное значение со стека lua_Integer tmp = lua_tointeger(lua_state, -1); // Восстанавливаем стек while (top - lua_gettop(lua_state)) lua_pop(lua_state, 1); // Вызываем функцию my_number_sqr top = lua_gettop(lua_state); lua_getglobal(lua_state, \"my_number_sqr\"); double x = 8; lua_pushnumber(lua_state, x); lua_pcall(lua_state, 1, 1, 0); double ret = lua_tonumber(lua_state, 01); while (top - lua_gettop(lua_state)) lua_pop(lua_state, 1); // Выводим результат writeln(\"readed integer nv = \", tmp); writefln(\"sqr(%f) = %f \", x, ret); lua_close(lua_state); } Собираем его, не забыв прилинковать liblua.so (скрипт сборки может быть и проще, но отдельно писать было лень). SConstruct для компиляции тестовой программы#-------------------------------------------------------------------- # Project globals #-------------------------------------------------------------------- source_dir = 'src/' d_include_path = 'src/D/' release_target_dir = 'bin/release/' target_name = 'test_lua_api' #-------------------------------------------------------------------- # Release build configuration #-------------------------------------------------------------------- release_env = Environment( CC='gcc', CXX='g++', DMD='dmd', DPATH=d_include_path, LINK='gcc', CPPFLAGS='-O3', DFLAGS='-O' ) release_env.VariantDir(release_target_dir, source_dir, duplicate=0) d_sources = Glob(release_target_dir + 'D/*.d') d_obj = release_env.Object(d_sources) release_env.Program(release_target_dir + target_name, d_obj, LIBS=['phobos2', 'lua']) имея на выходе readed integer nv = 2 sqr(8.000000) = 64.000000 Вместо заключения Большинство функций пока что не тестировалось, собственно в моем проекте используется пока чтение полей таблиц и вызов Lua-функций. Для хорошей проверки данный код следует безвозмездно отдать народу, что я и делаю. Надеюсь, кому-нибудь пригодится. Благодарю за внимание к моему труду. P.S.: Код придется серьезно поправить. Допустим, для корректной работы со строками пришлось внести некоторые коррективы в lua_tostring(...) string lua_tostring(lua_State *L, int idx) { return to!string(lua_tolstring(L, idx, null)); } добавив преобразование в string. Что ж, по мере использвания коррективы будут внесены", "image": [], "tag": ["Язык D", "Lua-скриптинг", "программирование", "библиотеки D"], "rating": ["+18"], "bookmarks": ["31"], "views": ["5,5k"], "comments_count": ["13"]},
{"author": ["AterCattus"], "date": [" 9 июля 2014 в 17:14"], "hubs": ["Lua"], "type_label": ["Перевод"], "text": "от пер. Исходный материал датируется 2001 годом, так что некоторые моменты могут показаться забавными. Так же все отсылки на «сегодня», «в настоящий момент» и т.п. относятся к тому периоду. Изложение ведется от лица автора, как и в оригинале. Все ссылки добавлены мною. Изложение организовано в хронологическом порядке. Мы начнем с наших экспериментов, легших в основу создания Lua в 1993, и пройдемся через восемь лет обсуждений, решений, работы и развлечений. Введение Есть старая шутка: «верблюд — это лошадь, разработанная комитетом». Среди разработчиков языков программирования эта шутка практически столь же популярна, как и легенда о разработанных комитетами языках. Легенда поддерживается такими языками, как Algol 68, PL/I и Ada, разработанными комитетами и не удовлетворившими ожиданий. Однако, кроме комитетов, существует альтернативное объяснение частичного провала этих языков: все они были рождены большими. Каждый из них следовал нисходящему процессу проектирования, при котором язык полностью описывается еще до того, как программист может попробовать его в деле, да и даже до появления первого компилятора. С другой стороны, множество успешных языков проявили себя еще до полной своей проработки. Они следовали восходящему процессу проектирования, появившись как небольшие языки со скромными целями. Когда люди начинали использовать подобный недостаточно проработанный язык, то в него добавлялись новые возможности (или, иногда, удалялись), вносилась ясность в неоднозначные места (или, наоборот, все делали еще запутаннее). Поэтому, путь развития является важной темой при изучении языка программирования. К примеру, SIGPLAN уже проспонсировала две конференции по истории языков программирования. В этом документе описывается история языка программирования Lua. С момента своего появления в качестве языка для пары собственных специфичных «домашних» проектов, Lua ушел дальше наших самых оптимистичных ожиданий. По нашему мнению главные причины такого успеха лежат в нашем подходе к проектированию языка: сохранить сам язык простым и компактным, а его реализацию простой, компактной, быстрой, переносимой и свободной. Lua был разработан (или, точнее, выдвинут) комитетом; пусть и маленьким — всего с тремя членами, — но комитетом. Задним числом мы понимаем, что первоначальная разработка языка небольшим комитетом положительно сказалась на языке. Мы добавляли новую возможность только по единодушному согласию, в противном же случае она откладывалась на будущее. Значительно проще добавлять новые возможности впоследствии, чем удалять их. Подобный процесс разработки позволял сохранять язык простым; и простота языка — это наш самый ценный вклад. Другие наиболее значимые качества Lua — скорость, компактность и переносимость, произошли от его простоты. С первых версий у Lua были «настоящие» пользователи, а не только мы одни. Они вносили важный вклад в язык обсуждениями, жалобами, пользовательскими отчетами и вопросами. С другой стороны, наш маленький комитет играл важную роль: его структура давала нам достаточно инертности, чтобы прислушиваться к пользователям без следования всем их предложениям. Начало Наш первый опыт в TeCGraf (от пер. «группа технологий компьютерной графики Католического университета Рио-де-Жанейро в Бразилии»), связанный с разработкой своего ЯП, произошел в приложении для ввода данных. Инженерам PETROBRAS (бразильская нефтяная компания) по несколько раз в день требовалась подготовка файлов с исходными данными для симуляторов. Это был скучный и подверженный ошибкам процесс, так как программы симуляции требовали строго форматированные исходные файлы, состоявших обычно из простых колонок чисел без каких либо указаний какое число что означает. Конечно же, каждое число имело определенный смысл, понятный инженерам с первого взгляда на диаграмму конкретной симуляции. PETROBRAS обратились к TeCGraf за созданием графического фронтенда к подобным исходным данным. Числа могли вводиться интерактивно после простого клика в соответствующую часть диаграммы — и это было значительно более простой и наглядной задачей, нежели редактирование числовых колонок. Более того, это позволило добавить проверку и расчет зависимых величин по исходным данным, снижая тем самым объем данных требуемых от пользователя, а заодно увеличивая надежность всего процесса в целом. Для упрощения разработки этого приложения в TeCGraf мы решили программировать все единообразно, разработав простой декларативный язык для описания всех задач по входным данным. Вот пример секции типичной программы на данном языке, названном нами DEL (data entry language): :e gasket \"gasket properties\" mat s # material m f 0 # factor m y f 0 # settlement stress t i 1 # facing type :p gasket.m>30 gasket.m<3000 gasket.y>335.8 gasket.y<2576.8 Выражение :e объявляет сущность (названную в примере «gasket»), у которой есть несколько полей со значениями по умолчанию. Выражение :p накладывает некоторые ограничения на значения в gasket, реализуя таким образом проверку данных. В DEL есть также выражения для описания входных и выходных данных. Сущность в DEL это, в общем-то, структура или запись в традиционных ЯП. Разница в том, что ее имя появляется также в графическом метафайле, содержащем диаграмму, с помощью которой инженеры вводят данные как было описано ранее. Этот простой язык доказал свою успешность как в TeCGraf, упрощая разработку, так и среди пользователей простотой адаптации приложений по вводу данных. Вскоре пользователям понадобилось больше возможностей от DEL, таких как булевы выражения для контроля готовности сущности к вводу данных, и DEL становился тяжелее. Когда пользователи начали спрашивать про условные блоки и циклы, стало ясно, что нам нужен полноценный язык программирования. Примерно в тоже время мы начали работать над другим проектом для PETROBRAS, названным PGM: настраиваемый генератор отчетов для литологических профилей. Как видно из названия, отчеты, создаваемые этой программой, должны были хорошо настраиваться: пользователь мог создавать и позиционировать треки, выбирать цвета, шрифты и тексты; у каждого трека могла быть сетка, имеющая свои настройки (логарифмическая/линейная, с вертикальными и горизонтальными отсечками, и т.д.); каждая кривая имела собственный автоматический масштаб; и многое другое. Все эти настройки задавались конечными пользователями, обычно геологами или инженерами, а программе следовало работать на небольших машинах, таких как PC с MS-DOS. Мы посчитали, что лучший способ настройки приложения возможен через специализированный язык описаний, который мы назвали Sol: акроним от Простой Объектный Язык (Simple Object Language), а заодно это переводилось с португальского как «солнце». Та как генератор отчетов использовал множество различных объектов со множеством атрибутов у каждого, мы решили не вводить эти объекты и атрибуты в язык. Вместо этого, язык позволял описывать типы. Основной задачей интерпретатора было прочитать описание, проверить корректность описания объектов и атрибутов, и передать информацию в основную программу. Для реализации взаимодействия между основной программой и интерпретатором последний был реализован как C библиотека, слинкованная с основной программой. Таким образом, основная программа имела полный доступ ко всей информации о конфигурации через API библиотеки. Более того, программа могла зарегистрировать callback-функцию на каждый описываемый тип данных, вызывавшуюся интерпретатором при создании объекта данного типа. Вот типичный пример кода на Sol: - объявляем тип 'track', с числовыми атрибутами 'x' и 'y', - плюс бестиповый атрибут 'z'. для 'y' и 'z' заданы значения по умолчанию. type @track { x:number,y:number= 23, z=0} - объявляем тип 'line', с атрибутами 't' (трек) - и 'z' (список чисел). - у 't' есть значение по умолчанию - трек (тип 'track') с атрибутами x=8, y=23, и z=0. type @line { t:@track=@track{x=8},z:number*} - создаем объект 't1' типа 'track' t1 = @track { y = 9, x = 10, z=\"hi!\"} - создаем линию (тип 'line') 'l' с t=@track{x=9, y=10} - и z=[2,3,4] (список) l = @line { t= @track{x=t1.y, y=t1.x}, z=[2,3,4] } На синтаксис Sol оказали сильное влияние BiBTeX и UIL (User Interface Language), язык описания интерфейса пользователя в Motif. В марте 1993 мы завершили первую реализацию языка Sol, но никогда не представляли ее. В середине 1993 мы поняли, что DEL и Sol можно объединить в единый более мощный язык. Программа визуализации литологических профилей вскоре потребовала поддержки процедурного программирования для создания более сложных слоев. С другой стороны, программам по вводу данных так же требовались описательные средства для программирования их пользовательского интерфейса. Итак, мы решили, что нам нужен полноценный язык программирования с присваиваниями, управляющими структурами, процедурами, и всяким таким. Так же в языке нужны были средства описания данных по аналогии с Sol. Более того, так как множество потенциальных пользователей языка не были профессиональными программистами, то в языке следовало избегать сложного синтаксиса (и семантики). Наконец, реализация нового языка должна была быть хорошо портируемой. Требование портируемости обернулось одним из основных достоинств: тем двум приложениям (от пер. судя по всему имеются ввиду DEL и Sol) следовало быть портируемыми, и таким же должен был быть язык. PETROBRAS, как госконтора, не мог выбирать конкретное аппаратное обеспечение, так как оно закупалось с очень жесткими ограничениями на трату государственных денег. Из-за этого в PETROBRAS было весьма разнообразное собрание компьютеров, на каждом из который должно было работать прграммное обеспечение, создаваемое в TeCGraf для PETROBRAS: сюда входили PC DOS, Windows (3.1 на тот момент), Macintosh и все возможные Unix. В этот момент мы могли бы взять существующий язык, а не создавать еще один новый. Главными кандидатами были Tcl и, с большим отставанием, Forth и Perl. Perl — это не язык расширений. Плюс, в 1993 Tcl и Perl работали только на Unix платформах. Так же у всех трех языков сложный синтаксис. И ни один из них не имел хорошей поддержки описания данных. Так что мы начали работу над новым языком. Вскоре мы поняли, что для наших целей в языке не нужно объявлять типы данных. Вместо этого мы могли использовать сам язык для написания функций проверки типов, основанных на базовых языковых возможностях рефлексии (таких как информация о типе во время выполнения (от пер. речь про RTTI)). Присваивание вида t1 = @track {y = 9, x = 10, z=\"hi!\"} допустимое в Sol, так же допустимо в новом языке, но с другим смыслом: оно создает объект (в данном случае ассоциативную таблицу) с указанными полями, а затем вызывает функцию track для проверки объекта (и, иногда, для простановки значений по умолчанию). Так как язык был измененной версией Sol («солнце»), друг в TeCGraf предложил имя Lua («луна» по португальски), и так родился язык Lua. Lua наследовал от Sol синтаксис записей и конструирования списков, но объединил их реализацию с использованием ассоциативных таблиц: записи использовали строки (имена полей) в качестве индексов; списки же использовали целочисленные индексы. Кроме этих возможностей описания данных в Lua не было новых концепций, так как нам был нужен легкий язык общего применения. Итак, мы начали с небольшого набора управляющих структур, синтаксис которых был заимствован из Modula (while, if, repeat until). Из CLU мы взяли множественное присваивание и возврат нескольких значений как результата вызова функции (значительно более понятный подход, чем in-out параметры или передача по ссылке). Из C++ мы взяли идею локальности области видимости переменных в месте их объявления. Одной из небольших (даже мелких) инноваций был синтаксис конкатенации строк. Так как язык позволял неявное приведение строк к числам, использование оператора \"+\" было бы двусмысленным, то мы добавили синтаксис \"..\" (две точки) для такой операции. Споры вызвало использование \";\" (точки с запятой). Мы считали, что требование использования точки с запятой несколько запутает инженеров, знающих FORTRAN, с другой же стороны не использование ее запутает тех, кто знает C или Pascal. В конце концов, мы пришли к решению опциональности использования точки с запятой (типичное решение комитета). Первоначально язык Lua имел семь типов данных: числа (хранящиеся в формате с плавающей точкой), строки, (ассоциативные) таблицы, nil (тип данных с уникальным значением так же названным nil), userdata (простой C'шный указатель для представления структур данных C внутри Lua), Lua функции и C функции. (Спустя восемь лет эволюции языка единственным изменением в этом списке стала лишь унификация Lua и С функций в единый тип). Для сохранения компактности языка мы не включили булевый тип данных. По аналогии с Lisp, nil приводится к false, тогда как все остальные значения приводятся к true. Это одна из немногих экономий о которой мы теперь иногда жалеем. Lua также перенял из Sol подход к реализации в качестве библиотеки. Реализация следовала принципу, поддерживаемому сейчас Экстремальным Программированием: «самая простая реализация, которая может работать». Мы использовали lex для лексического сканера и yacc для синтаксического парсера. Парсер переводил программу в байткод, который затем выполнялся простым стековым интерпретатором. У языка была очень маленькая стандартная библиотека и было очень легко добавлять новые функции в C. Несмотря на простую реализацию – или, возможно, из-за нее – Lua превзошел наши ожидания. Оба прокта (PGM и ED) успешно использовали Lua (а PGM все еще используется). В конце концов и остальные проекты в TeCGraf начали использовать Lua. Первые годы (1994–1996) Новые пользователи создают новые запросы. Не удивительно, что одним из первых запросов было увеличение производительности Lua. Применение Lua для описания данных поставили нетипичную проблему для обычного скриптового языка. Вскоре после того, как мы начали использовать Lua, мы заметили его потенциал для использования в качестве языка для графических метафайлов. Возможности описания данных в Lua позволили использовать его как графический формат. В сравнении в другими программируемыми метафайлами использование Lua давало все преимущества полноценного процедурного языка. Формат VRML, к примеру, использует Javascript для моделирования процедурных объектов, что приводит к неоднородности (и, следовательно, неясности) кода. С Lua объединение процедурных объектов в описании сцены происходит естественно. Фрагменты процедурного кода могут быть объединены с декларативными выражениями для моделирования сложных объектов при сохранении общей ясности. Программа по вводу данных (ED) была первой, использовавшей Lua для своих графических метафайлов. Было обычным делом иметь диаграммы с тысячами частей, описываемых тысячами элементов в Lua в файле на сотни килобайт. Это значило, что с точки зрения языков программирования Lua справляется с огромными программами и выражениями. А то, что Lua компилировал такие программы «на лету» (как «just-in-time» компилятор), означало и так весьма высокую скорость самого Lua компилятора. Первой жертвой погони за производительснотью стал lex. Замена сканера, генерируемого lex, на самописный код практически удвоило скорость Lua компилятора. Мы также создали новые опкоды для конструкторов. Исходный код для конструктора списков выглядел так: @[30, 40, 50] что превращалось в подобный байткод: CREATETABLE PUSHNUMBER 1 # индекс PUSHNUMBER 30 # значение SETTABLE PUSHNUMBER 2 # индекс PUSHNUMBER 40 # значение SETTABLE PUSHNUMBER 3 # индекс PUSHNUMBER 50 # значение SETTABLE С новой схемой код стал выглядеть так: CREATETABLE PUSHNUMBER 30 # значение PUSHNUMBER 40 # значение PUSHNUMBER 50 # значение SETTABLE 1 3 # задание элементов с индексами от 1 до 3 Для длинных конструкторов не было возможности сложить все их элементы в стек перед сохранением. Из-за этого генератор кода время от времени выдавал опкод SETTABLE для сброса стека. (С тех пор мы всегда пытались улучшить время компиляции. Сейчас Lua компилирует программу с 30000 присваиваний в шесть раз быстрее Perl, и в восемь раз быстрее Python). Мы выпустили новую версию Lua с этими оптимизациями в июле 1994 под именем Lua 1.1. Версия была доступна для скачивания по ftp. Предыдущая версия Lua 1.0 никогда не была доступна публично. Спустя некоторое время мы также выпустили первую документацию с описанием Lua. У Lua 1.1 была ограниченная пользовательская лицензия. Язык можно было свободно использовать в академических целях, но не для коммерческого использования. (Несмотря на лицензию, сам язык всегда был с открытым исходным кодом). Но такая лицензия не работала. Большинство конкурентов, таких как Perl и Tcl, были свободны. Более того, ограничения коммерческого использования мешали даже академическому использованию, так как некоторые академические проекты планировали в последствии выйти на рынок. Так что выпуск следующей версии языка, Lua 2.1, был свободным. Lua версии 2 Lua 2.1 (выпущенный в 1995), принес много важных изменений. Одно из них было не в самом языке, а в процессе разработки: мы считали, что стоит всегда пытаться улучшить язык, пусть даже ценой небольшой обратной несовместимости. В версии 2.1 мы внесли много несовместимостей с версией 1.1 (но предоставили инструменты для помощи в переносе кода). Мы выкинули синтаксис @ из конструкторов таблиц и унифицировали использование фигурных скобок и для записей и для списков. Выбрасывание @ было тривиальным изменением, но изменило восприятие языка, не только его внешность. Что более важно, мы упростили семанику конструкторов. В Lua 1.1 конструкция @track{x=1, y=10} имела особый смысл. В Lua 2.1 конструкция track{x=1, y=10} является синтаксическим сахаром для track({x=1, y=10}), то есть она создает новую таблицу и передает ее единственным параметром в функцию track. С самого начала мы разрабатывали Lua как язык расширений, в связи с чем программы на C могли регистрировать свои собственные функции, прозрачно вызываемые из Lua. С таким подходом было легко расширять Lua предметно-ориентированными примитивами, что позволяло конечному пользователю адаптировать язык под конкретные задачи. В версии 2.1 мы ввели понятие fallback'ов: определенные пользователем функции, которые вызываются Lua в случае неопределенных ситуаций. (от пер. Этот подход является своеобразным надмножеством перегрузки операторов. Принцип похожий, но возможностей больше). Lua становится языком, который можно расширять двумя путями: расширение набора «примитивных» функций и расширением их семантики через fallback'и. Вот почему сейчас мы называем Lua расширяемым языком расширений. Мы объявили fallback'и для арифметики, сравнения операторов, конкатенации строк, доступа к таблицам и т.д. (от пер. подробнее тут и несколько наперед тут). После задания пользователем, подобная функция вызывается всякий раз, когда операнды этой операции не подходят по своим типам. К примеру, при сложении двух значений, одно из которых не является числом, вызывается fallback, а результат его вызова используется в качестве итоговой суммы. Особый интерес представляет собой (и является главной причиной появления fallback'ов) операция доступа к таблице: если при выполнении x=a[i] значением a[i] является nil (от пер. т.е. таблица a не содержит поля i), то вызывается (если задана) fallback функция, чей результат используется как значение для a[i]. Этот простой новый функционал позволил программистам реализовать различные семантики доступа к таблицам. В частности, можно реализовать некоторый вид наследования через делегирование: function Index (a,i) if i == \"parent\" then -- чтобы избежать цикла return nil end local p = a.parent if type(p) == \"table\" then return p[i] -- возможнен повторный вызов функции Index else return nil end end setfallback(\"index\", Index) Этот код поднимается по цепочке «родителей», пока не найдет нужного поля или не достигнет конца. С этим кодом следующий пример выведет «red» даже если у b нет поля с цветом. a = Window{x=100, y=200, color=\"red\"} b = Window{x=300, y=400, parent=a} print(b.color) Нет никакой магии или жестко прописанного поведения в делегировании через поле «parent». Это выбор разработчика. Он может использовать другое имя для поля, или реализовать более сложное множественное наследование, позволяя полю «parent» самому быть таблицей, обходимой последовательно, либо как-то еще. Еще один fallback будет вызван для выражения a[i] в случае, если a вообще не является таблицей. Это fallback «gettable», срабатывающий для получения значения a[i] в ситуации вида x=a[i], и fallback «settable», срабатывающий при записи в a[i] в ситуации вида a[i]=x. Есть много возможностей использования этих табличных fallback'ов. Межязыковое взаимодействие это очень мощная возможность: когда a хранит значение типа userdata (указатель на что-либо в C коде), fallback реализует прозрачный доступ к значениям внутри структур данных основной программы. Наше решение не зашивать жестко подобные поведения в реализации языка привело к одному из основных концептов Lua: мета-механизмам. Вместо замусоривания языка множеством возможностей, мы предоставили пути реализации этих возможностей тем и только тем, кому это нужно. Мета-механизм fallback'ов позволяет Lua поддерживать ООП в контексте некоторых реализуемых видов наследования и перегрузки операторов. Мы даже добавили немного синтаксического сахара для описания и использования «методов»: функции могут объявляться в формате a:f(x,y,z), и в этом случае при вызове добавляется скрытый параметр self, делающий вызов a:f(10,20,30) эквивалентным a.f(a,10,20,30). В мае 1996 мы выпустили Lua 2.4. Основным нововведением этой новой версии был внешний компилятор, названный luac. Эта программа компилировала Lua код и сохраняла байткод и таблицы строк в бинарный файл. Формат такого файла был выбран для простой загрузки и переносимости между различными платформами. С luac программы могли избежать парсинга и кодогенерации во время запуска, что было накладно, особенно для больших статичных программ, таких как графические метафайлы. Наша первая публикация по Lua уже тогда рассматривала возможность внешнего компилятора, но нам это потребовалось только после широкого распространения Lua в TeCGraf и огромных графических метафайлов с Lua кодом, создаваемых графическими редакторами. Кроме ускорения загрузки luac позволяет так же выполнять проверку синтаксиса при компиляции и защиту исходного кода от изменений пользователем. Однако предварительная компиляция не ускоряет выполнение, так как Lua и так всегда предварительно компилирует исходный код перед выполнением. luac реализован в «режиме клиента», то есть он использует модули, реализующие Lua как с простого клиента, даже не смотря на то, что используются приватные заголовочные файлы для доступа ко внутренним структурам данных, требующих сохранения. Одним преимуществом такой политики является разделение реализации ядра Lua на четко разделенные модули. Благодаря этому, сейчас легко удалить модули парсинга (лексер, парсер и кодогенератор), занимающие 40% кода ядра Lua 4.0, оставив лишь крошечный модуль загрузки предварительно скомпилированных фрагментов кода. Это может быть полезно для очень маленьких реализация Lua для встраивания в небольшие устройства вроде мобильных телефонов или роботов (к примеру, Crazy Ivan, робот побеждавший в RoboCup в 2000 и 2001 в Германии, имел «мозги» реализованные на Lua). Представление миру (1996–2000) В июне 1996 мы опубликовали академическую статью про Lua в Software: Practice & Experience (от пер. по ссылке скачивание за денежку. нашел в другом месте судя по всему тот же самый материал и конвертнул в pdf, если кому интересно). В декабре 1996 журнал Dr. Dobb's опубликовал статью про Lua. Данные публикации, нацеленные на разные сообщества, привели к международной известности Lua. Вскоре после статьи в Dr. Dobb's мы получили множество писем про Lua. Одно из первых писем было следующим: From: Bret Mogilefsky <mogul@lucasarts.com> To: \"'lua@icad.puc-rio.br'\" <lua@icad.puc-rio.br> Subject: LUA rocks! Question, too. Date: Thu, 9 Jan 1997 13:21:41 -0800 Привет... Прочитав статью Dr. Dobbs про Lua, я с нетерпением проверил его, и результат превысил все мои возможные ожидания! Его элегантность и простота поразили меня. Мои поздравления за разработку столь хорошо продуманного языка. Обо мне: я работаю над адвенчурой в LucasArts Entertainment Co. и хочу попробовать заменить наш старый скриптовый язык SCUMM на Lua. [...] Оказалось, что Bret Mogilefsky был ведущим программистом Grim Fandango, основной адвенчуры LucasArts в 1997 году. В другом письме он пишет нам, что «ОГРОМНАЯ часть игры написана на Lua» (акцент авторский). Это первое использование Lua в игре привлекло к языку внимание множества игровых разработчиков во всем мире. Спустя некоторое время Lua все чаще стал появляться в игровых группах новостей вроде rec.games.programmer и comp.ai.games. Вследствие небольшого размера, хорошей производительности, переносимости и простоты интеграции Lua приобрел большую популярность для расширения функционала игр. В наше время некоторые игровые компании применяют Lua (к примеру LucasArts, BioWare, Slingshot Game Technology и Loewen Entertainment) и знание Lua является конкурентным преимуществом при поиске работы в игровой индустрии. По нашей оценке половина пользователей Lua вовлечены в разработку игр, но сложно посчитать точнее из-за большой секретности в игровой индустрии. К примеру, хоть Bret Mogilefsky и адаптировал Lua для Grim Fandango, но подробности не доступны публике. Встраивание скриптового языка в игру дает несколько преимуществ. Скриптовый язык можно использовать для описания спрайтов и физики объектов, управления AI и персонажем, а так же для взаимодействия с устройствами ввода. К примеру, движок может ничего не знать о таких вещах, как «урон», «скорость», «оружие», и т.п. Выбор простого языка позволяет игровым дизайнерам использовать программируемые инструменты. Это крайне важно для разработки игр, так как позволяет дизайнерам экспериментировать с их творениями. Скриптовые языки также способствуют быстрому прототипированию и облегчают реализацию отладчиков. Не так давно, в 2000, LucasArts выпустили другую игру, использующую Lua, Escape from Monkey Island, которая была четвертой в серии адвенчур Monkey Island. В этой игре в дань уважения Lua авторы переименовали внутриигровой бар из SCUMM (ранее используемый разработчиками язык программирования) в Бар Lua. Помимо широкого использования в компьютерных играх (к примеру, Grim Fandango, Baldur's Gate, MDK2, Escape from Monkey Island) Lua используется во многих других сферах по всему миру. Одним из первых мест применений Lua вне PUC-Rio (от пер. тот самый католический университет Рио-де-Жанейро, подразделением которого является TeCGraf) была Смитсоновская астрофизическая обсерватория. Они разработали обобщенную программу апертуры для имитации воздействия потока фотонов на физические препятствия. Данная программа была частью усилий по продвижению программы AXAF (объект продвинутой рентгеновской астрофизики) — третьей из четырех Великий Космических Обсерваторий NASA. Performance Technologies использовали Lua для реализации интерфейса командной строки для CPC4400 — ethernet свич с возможностью горячей замены. Используя Lua в качестве скриптового языка для CPC4400, пользователь может связывать происходящие события (такие как статус соединения, изменения топологии, тревоги RMON) со скриптами на Lua. Tollgrade Communications использовали Lua в их продукте нового поколения для тестирования телефонной сети DigiTest. Lua использовался для пользовательского интерфейса, автоматизированных тестовых скриптов и результатов анализа. Lua так же используется в InCor Heart Institute (Instituto do Coração, São Paulo) в Бразилии, в CEPEL (иследовательский центр государственной электроэнергетической компании ELETROBRAS) так же в Бразилии, в Weierstrass Institute в Берлине, в берлинском техническом университете, и во множестве других мест. В 1998 Cameron Laird и Kathryn Soraiz в их колонке про скриптовые языки в журнале SunWorld подсчитали, что «в мире где-то около нескольких сотен тысяч Lua программистов». По их мнению это «небольшое число пользователей», но для нас это явный знак к росту популярности языка. Lua версии 3 Lua 3.0 (июль 1997) заменила fallback'и на более мощный концепт теговых методов. Fallback'и были глобальными по своей природе: пользовательские функции вызывались всякий раз при возникновении события, при этом можно было задать лишь одну функцию на конкретное событие. Это усложняло комбинирование Lua модулей, которые, к примеру, использовали различный подход к реализации наследования. Хоть и была возможность реализации цепочек вызова fallback функций, этот подход был медленным и склонным к ошибкам, и вряд ли кто-то стал бы им пользоваться. С версии Lua 3.0 программист мог создавать теги и связывать с ними таблицы и userdata. Методы тегов — это, по существу, все теже fallback'и, выбираемые согласно тегу оператора. С тегами и методами тегов различные таблицы (и userdata) могли использовать различные fallback функции для своих операций. Концепция тегов предлагается Lua для пользовательских типов. Другими словами, тег это просто число, представляющее новый тип. Когда вы ассоциируете таблицу с конкретным тегом, на самом деле вы объявляете новый тип для этой таблицы: тип (или тег) указывает как он реализует эти операторы. При первоначальном введении fallback'ов, большинство из них описывало поведение Lua в ошибочных ситуациях, таких как обращение к индексу не у таблицы или попытка вызова не функции. Так что мы считали, что fallback'и — это механизм обработки исключительных ситуаций. С введением пользовательских тегов, fallback'и (называемые теперь методами тегов) стали основным механизмом для описания поведения новых типов, даже не смотря на то, что мы все еще используем их для расширения поведения базовых типов. Несмотря на новое положение дел, мы еще долгое время воспринимали методы тегов как механизмы обработки ошибок и не могли связать теги с типами. Лишь недавно мы поняли всю значимость пользовательских тегов и методов тегов как механизма для создания пользовательских типов. Lua 4.1 закрепит это понимание позволяя пользователям задавать имена для таких новых типов (сейчас имена есть только у базовых типов). В Lua 3.0 так же появилась поддержка условной компиляции в формате похожего на C препроцессора. Как и любая языковая возможность, добавить эту было очень легко (хоть это и усложнило лексер), и вскоре программисты начали ее использовать (программисты используют любые возможности языка). При появлении нового функционала, сразу растет спрос на его дальнейшее развитие. Одним из самых частых запросов было добавление макросов, но продолжительное обсуждение так и не вылилось в четкое предложение ни в списке рассылок, ни между нами. Каждое из предложений требовало огромных изменений в лексере и парсере, не показывая при этом явной выгоды. Так что препроцессор оставался статичным с Lua 3.0 и до версии 3.2 (в течение двух лет). В конце концов мы решили, что препроцессор причинял больше вреда, чем приносил пользы, делая код громоздким и заманивая пользователей в бесконечные обсуждения, и удалили его в Lua 4.0. И без препроцессора Lua стал чище. На протяжении лет мы стремились сделать Lua проще и удалить темные углы языка, которые мы когда-то считали новыми возможностями, но которые использовались лишь редкими программистами, а в последствии и вообще стали считаться ошибками. Lua версии 4 До версии 3.2 только одно «состояние» Lua-машины могло быть активно в один момент. У нас было API для смены состояния, но оно было несколько неудобно для использования. Для упрощения при разработке API мы не включали явный параметр состояния в функции — было лишь одно единственное глобальное состояние. Теперь понятно, что это было ошибкой. К моменту выхода Lua 3.2 стало ясно, что многие приложения будут проще, если они смогут удобно работать с несколькими Lua состояниями. Например, мы делали специальную версию Lua 3.2, включенную в CGILua — расширение браузеров для отдачи динамических страниц (от пер. все-таки имеется ввиду серверная сторона) и CGI программирования на Lua. Ранее, LucasArts делала нечто подобное для Lua 3.1. При обсуждении наших планов по Lua 3.3 высочайший приоритет был у API с явными состояниями. Однако, это поднимало вопрос обратной совместимости. В конце концов, из-за несовместимостей мы решили переписать API для следующей версии, которой стала Lua 4.0. Теперь API не только содержит явные состояния, но оно так же стало проще и эффективней. Мы боялись, что переход на новое API будет не самым гладким, так как это был первый случай серьезных изменений в API со времен Lua 1.1. Мы получили несколько жалоб в списке рассылок, но в целом изменение вообще не оказалось травмирующим. Многие Lua программисты не взаимодействовали непосредственно с API, многие использовали его только через автоматические инструменты, а многие считали, что преимущества превышают цену перехода. Мы выпустили Lua 4.0 в ноябре 2000. Кроме нового API, эта версия принесла много других небольших улучшений, например цикл. Всякий работавший с языками программирования знает, как легко «разжигаются холивары» по этому вопросу. Интересной особенностью этих войн является то, что чем обыденнее тема, тем жарче обсуждение. К примеру, люди с большим удовольствием обсуждают использование точки с запятой, нежели функций высшего порядка. Одной из причин этого, конечно, является то, что значительно больше людей имеют представление по первой теме, нежели чем по второй. Но другая более важная причина заключается в сильной зависимости обыденности темы от уровня знания языка. Если язык не используют для создания удивительных и продуманных инструментов, если у него нет хорошей хватки — им никто не будет пользоваться. С версии 1.1 конструкция for была в пожеланиях большинства пользователей Lua. Основной причиной недовольства была забывчивость людей выполнять инкремент в конце итерации цикла while, что приводило к зацикливанию. Мы довольно скоро согласились с этим. Но, хоть мы все и были согласны с необходимостью цикла for, мы не могли согласиться с конкретными синтаксическими конструкциями для него. Мы считали конструкцию в стиле Pascal (или Modula) слишком ограничивающей, так как она не предполагала итерации по элементам таблицы или по строкам файла. Более того, перевод идентификатора to в список зарезервированных слов привел бы к недопустимой обратной несовместимости. С другой стороны, цикл for в стиле C не подходил к Lua. С введением замыкаций и анонимных функций в версии 3.1 (июль 1998) мы решили использовать для итераций функции высшего порядка. (На самом деле, необходимость в for была одной из основных причин введения анонимных функций в Lua). Lua 3.1 вышла с двумя предопределенными функциями для итерирования: foreach(table, f) foreachi(table, f) Функция foreach применяет f для всех пар ключ-значение, выбранных в произвольном порядке из заданной таблицы. Функция foreachi похожа, но рассматривает таблицу как список (или массив): она перебирает только элементы с числовыми ключами в порядке возрастания значений ключей. Хоть мы и предоставили только эти два способа обхода, было легко создать новые итераторы. Но хоть и просто было создавать новые, но за более чем два года практически никто их не делал. Первой причиной был дискомфорт для многих программистов использовать анонимные функции и функции высших порядков в процедурном языке. А второй и, на наш взгляд, значительно более важной причиной было отсутствие необходимости для большинства разработчиков в других итераторах. Это означает, что многие годы мы пытались добиться того, что не нужно реальному пользователю. С пониманием этого, мы быстро разработали два формата цикла for: для числовой итерации и для обхода таблиц. Оператор for был одним из самых удачных изменений в языке с первой версии. Во первых, он охватывал наиболее часто используемые применения циклов, в то время как для самых обобщенных циклов был доступен while. Во вторых, из-за его строгого формата было легко добавить для реализации специальные опкоды, сделавшие числовую итерацию с пустым телом цикла более чем в два раза быстрее аналогичного цикла через while. Заключение Сейчас у Lua устоявшаяся пользовательская база. Активен список рассылки почти на 500 человек из более чем 30 различных стран мира. На сайте (www.lua.org) примерно 500 посетителей в день из 50 стран. Язык используют в спектре от адвенчур до веб-сверверов и до тестирования телефонной сети для Ethernet свичей. Несколько ftp серверов предлагают исходные коды Lua, а также несколько других сайтов распространяют версии для конкретных платформ, таких как DLL для Windows, SIS для EPOC, RPM для Linux, бинарники для RISC OS, и т.д. Более того, некоторые журналы распространяют Lua на добавочных CD дисках (к примеру Dr. Dobb's, Linux Magazine France и японский C Magazine). Основной вклад Lua как языка заключается в предоставлении мета-механизмов вместо функциональности. Успех Lua как продукта пришел из его простоты, небольшого размера и портируемости реализации, позволивших использовать Lua на множестве различных платформ, включая небольшие устройства вроде palm'ов, КПК, специализированных плат и роботов. Cameron Laird и Kathryn Soraiz предсказали в 1998, что «неизбежный взрыв повсеместного использования встраиваемых устройств (компьютеров в вашей машине, ванной, и кухонной технике) может пойти лишь на пользу Lua». Тогда мы не обратили на это особого внимания, но они были правы. Также Lua внес вклад в академическую деятельность благодаря нескольким тезисам и публикациям как о самом языке, так и о его технологическом использовании. Успех имеет свою цену. В процессе эволюции языка обратная совместимость все сильнее сдерживала инновации. Тем не менее, мы не позволяли совместимости остановить прогресс — это лишь один из многих ингредиентов (пусть даже и сильный) в алхимии дизайна языков. Наконец, удержать язык — это гораздо больше, чем просто разработать его. Всецелое внимание к деталям важно во всех аспектах: дизайне языка, создании сообщества пользователей и прислушивания к их словам, придерживаясь в тоже время исходных проектных решений. Благодарности Lua бы никогда не было без помощи многих людей. Каждый в TeCGraf принимал какое-либо участие: использование языка, его обсуждение, распространение за пределы TeCGraf. Особая благодарность Marcelo Gattass, главе TeCGraf, кто всегда поддерживал нас и давал нам полную свободу касательно языка и его реализации. Lua был реально первым продуктом TeCGraf, публично доступным в интернете еще даже до подъема популярности. Без пользователей Lua был бы просто еще одним языком. Пользователи и их цели — это максимальная проверка для языка. От них мы получали отчеты о багах, недостатках дизайна, новых путях восприятия реальности. Особая благодарность членам списка рассылки за их обсуждения, предложения и, в основном, за терпение к нашему время от времени авторитарному подходу. от пер. Если тема будет интересна, то могу собрать информации по более новым версиям Lua, а так же про реализацию luajit. Спасибо, что дочитали :)", "image": [], "tag": ["lua", "история", "TeCGraf", "DEL", "Sol"], "rating": ["+39"], "bookmarks": ["83"], "views": ["17,6k"], "comments_count": ["8"]},
{"author": ["Ovoshlook"], "date": ["17 августа 2015 в 10:30"], "hubs": ["Программирование", "Lua", "Asterisk"], "type_label": [], "text": "Как и все АSTERISK'еры я не раз сталкивался с проблемой того, что на PBX существует несколько транков, которые используются для исходящей связи. И как у многих, у моих заказчиков тоже часть этих транков является основными, а остальные играют роль резервных, на случай падения/занятости/чего-либо еще первых. Стандартным механизмом решения такой проблемы считается следующий пример: exten => _<Че то там>,1,Dial(SIP/trunk/<Че то там>) exten => _<Че то там>,n,GotoIf($[\"${DIALSTATUS}\" != «ANSWER»]?Dial_Another_Prov:Hangup) exten => _<Че то там>,n(Dial_Another_Prov),Dial(SIP/trunk2/<Че то там>) exten => _<Че то там>,n(hangup),Hangup() Ну или вот такой пример, который впрочем лежит на просторах сети [macro-safedial] exten => s,1,Set(DIALSTART=${EPOCH}) exten => s,n,Dial(${ARG1},${ARG2},${ARG3},${ARG4}) exten => s,n,Goto(s-${DIALSTATUS},1) exten => s-NOANSWER,1,GotoIf($[\"${DTIME}\" = «0»]?here) exten => s-NOANSWER,n,Hangup exten => s-NOANSWER,n(here),Verbose(1,Need failover for \"${ARG1}\") exten => s-BUSY,1,Busy exten => s-CHANUNAVAIL,1,Verbose(1,Need failover for \"${ARG1}\") exten => s-CONGESTION,1,Congestion exten => _s-.,1,Congestion exten => s-,1,Congestion Через какое-то время мне начали претить такие решения, исходя из соображений их громозкости и увеличения количества резервных каналов у одного из заказчиков, у которого стоял вопрос во что бы то ни стало дозвониться до клиента. Оно в общем то и понятно: телефония должна всегда оставаться телефонией, и работать. На то оно и PBX — чтобы автоматизировать работу и избавить от головных болей. Между делом переводя всех своих подопечных с обычного диалплана на lua было принято решение — воять. Что ж. У нас под руками отличный рабочий инструмент — целый ЯЗЫК программирования. Который, как и многие его собратья, умеет работать с сетевыми интерфейсами. А это значит что мы можем использовать это свойство на свои блага. Чего бы не посмотреть на состояния транков и уже затем вызвать доступный? Нужно всего то: 1. Подключиться к AMI 2. Получить имена транков 3. Получить их статусы И так. Первым делом цепляем библиотеку сокетов: local socket = require(\"socket\") Для анализа транков я буду использовать AMI (как уже наверное все догадались исходя из названия). Так как AMI работает по tcp стеку, то его я и опишу: tcp = socket.tcp() tcp:settimeout(100) Далее я описываю контекст из которого будут вызываться транки и навешиваю на него нужную нам функцию. Скажем… outgoing_calls_external_dst По сути эта функция- есть сущность контекста. То есть аналог контекста в extensions.conf (Это я расписывать кодом не буду. Все есть на wiki.asterisk.org) Здесь я, при получении звонка подключусь к AMI интерфейсу своего asterisk: tcp:connect(\"127.0.0.1\", 5038) result = tcp:receive() tcp:send(\"Action: Login\\r\\n\") tcp:send(\"Username: pr\\r\\n\") tcp:send(\"Secret: 1\\r\\n\\r\\n\") LoginIsOk = 0 while LoginIsOk == 0 do result=tcp:receive() -- перебираем входящие сообщения пока не встретим сообщение о удачном соединении. if string.find(result,\"Authentication accepted\")~=nil then LoginIsOk = 1 end if string.find(result,\"Response: Error\")~=nil then LoginIsOk = 2 end end Дальше в общем-то начинается самое интересное. Запрашиваем у ASTERISK все пиры. «Зачем все?» — спросит читатель. «Ведь есть же SIPshowregistry!». Да. Есть. Но во-первых он покажет нам только транки с регистрацией, а во-вторых, если провайдер стал недоступен, а время регистрации еще не истекло, то информация о состоянии транка все равно будет невалидной. «Но SIPpeers покажет и клиентов тоже!» — и это будет правильным замечанием. поэтому нужно подготовить транки. В sip/users/<Куда вы там еще кто складывает свои транки> для каждого транка я: 1. Включил qualify 2. Прописал параметр description = line То есть иными словами — все что описано как line и есть транк. Почему это важно? потому что SIPpeers вернет нам вот такое описание для каждого пира. Более того — он вернет вам это в том порядке, в котором они прописаны у вас в файле/таблице mysql Channeltype: SIP ObjectName: mysupertrunk ChanObjectType: peer IPaddress: -none- IPport: 0 Dynamic: yes AutoForcerport: no Forcerport: yes AutoComedia: no Comedia: yes VideoSupport: no TextSupport: no ACL: no Status: UNKNOWN RealtimeDevice: no Description: line В общем то распарсив все что есть из пиров на сервере мы таким образом отлично отделим зерна от плевел и сложим зерна в одну корзину под названием trunks: tcp:send(\"Action: SIPpeers\\r\\n\\r\\n\") while result ~= \"EventList: start\" do result = tcp:receive() end trunks = {} i = 1 while result ~= \"Event: PeerlistComplete\" do result = tcp:receive() if string.find(result,\"ObjectName\")~=nil then ObjectName = splitted_value(result,\": \") --splitted_value - это самописная функция, которая разделяет строку на подстроки и возращает результат end if string.find(result,\"Description\")~=nil then Description = splitted_value(result,\": \") end if Description == \"line\" then trunks[i] = ObjectName i = i + 1 Description=nil -- обязательно обнуляем переменную. Иначе попадем в бесконечный цикл. end end В общем то теперь у нас есть массив/табличка всех транков на нашем ASTERISK. осталось только выяснить какой из них доступен и позвонить через него. Сделать это можно через SIPpeerstatus: for key,val in pairs(trunks) do tcp:send(\"Action: SIPpeerstatus\\r\\n\") tcp:send(\"Peer: \"..val..\"\\r\\n\\r\\n\") while result~=\"Event: SIPpeerstatusComplete\" do result=tcp:receive() if string.find(result,\"PeerStatus:\")~=nil then status=split(result,\": \") --split еще одна самописная функция, которая делит подстроку и возвращает таблицу. Предыдущая функция включает в себя эту if status[2]==\"Reachable\" then app.Dial(\"SIP/\"..val..\"/\"..extension) end end end end Ну и не забываем закрыть за собой дверь)) tcp:send(\"Action: Logoff\\r\\n\\r\\n\") while result~=\"Response: Goodbye\" do result=tcp:receive() end tcp:close() Это в общем-то самый простой пример того, как можно использовать AMI непосредственно в самом диалплане. Так же ничего не мешает узнавать и занятость каналов. Необходимо будет только распарcить вывод команды sip show inuse. Прикручивается сюда и mysql коннекторы и redis, и все что угодно при необходимости. Без костылей. P.S. Для ленивых есть целая библиотека ami-lua. Только вот с документацией там… никак.", "image": [], "tag": ["asterisk", "lua", "programming", "voip"], "rating": ["+7"], "bookmarks": ["106"], "views": ["10,6k"], "comments_count": ["12"]},
{"author": ["Faiver_bes"], "date": [" 1 сентября 2014 в 19:41"], "hubs": ["Lua"], "type_label": [], "text": "Я думаю ни для кого не будет секретом, что у Awesome есть «узкое место», если мы запускаем внешний скрипт, который например должен считать данные из файла, или интернета и вернуть результат в виджет или саму систему, то мы периодически можем наблюдать явлениие «фриза», т.е. когда система перестает реагировать на нажатия клавиш и мыши до получения результата обработки (правда активный клиент при этом продолжает работать). Чаще всего это происходит при использовании io.popen или awful.util.pread У меня такая ситуация случалась не однократно, например, при прослушивании музыки в moc/mocp при смене трека у меня вызывается внешний скрипт который получает данные о треке и загружает обложку альбома, если она есть и отображает их. Но периодически (т.к. скрипт тестировался на ноутбуке) система «зависала». Долго не мог понять почему же это происходит, а затем выяснил, что если в этот момент диск сильно нагружен чем нибудь, то данные на чтение ставятся в очередь и в результате, т.к. вывод результата зависит от ответа, система «подвисала». Проблему удалось частично решить через «костыли» в виде вешнего скрипта, который через 'echo $result | awesome-client -' пересылал данные. Или другой вариант, есть виджеты отображающие свободное место на диске (например раздела /), работающие чаще всего через 'df -h', но если у нас есть на диске раздел ntfs, то периодически он может «отваливаться», и в этот момент система перестает реагировать. Одним из решений является сохранение вывода команды в файл, а затем его чтение оттуда. Но опять же это тот еще «костыль». Согласитесь, очень неприятно, когда для простейших действий приходится изобретать костыли. А тем временем, в Awesome, существует такая замечательная вещь как DBus, которая позволяет осуществлять взаимодействие различных компонентов системы и приложений. ==Что такое DBus== D-Bus — это система межпроцессного взаимодействия, которая предоставляет приложениям несколько шин для передачи сообщений. Она обеспечивает бес проблемную связь десктопных приложений между собой и связь между десктопными приложениями и системными сервисами. Поддерживается не только широковещательная рассылка сообщений (сигналов), но и удалённый вызов методов. Т.е. возможно из Awesome, внешнего приложения или вашего виджета послать запрос на обработку каких либо данных, а получить результат обработки через шину DBus, и наконец вызвать функцию обработчик этого события. И при этом никаких «зависаний», ведь мы не заставляем Awesome ожидать результат. Для работы с Dbus можно использовать стандартные утилиты 'dbus-send' — для отправки сигналов в приложения из скриптов или оболочки, и 'dbus-monitor' — которая позволяет отслеживать все сигналы посылаемые между приложениями и/или системой. Если же вы хотите получить более полные данные о том какие приложения зарегистрированы в dbus, какие методы они могут вам предоставить, можно воспользоваться сторонней утилитой из комплекта KDE 'qdbus' — это консольная утилита имеющая минимальные зависимости и занимающая чуть менее 1Мб. Если вы запустите dbus-monitor, то будете отслеживать все сигналы пересылаемые приложениями и системой. Но если вас интересует какой либо конкретный сигнал, то можно отфильтровать вывод: dbus-monitor \"interface='ru.gentoo.kbdd' \" В данном случае мы будем получать сигналы о смене раскладки клавиатуры посылаемые kbdd. За более подробными сведениями обращайтесь LOR. В принципе dbus-monitor удобно использовать для отладки ваших скриптов. Но нас то интересует возможность взаимодействия наших скриптов и Awesome. Для посылки сигнала в Awesome вы можете использовать следующий код: dbus-send --session --dest=org.naquadah.awesome.awful /ru/console/mocp ru.console.mocp.songChanged Разберем, что здесь и к чему. --session — указывает на то что используется сессионная (а не системная) шина передачи данных. Т.е. сессионная шина это пользовательская шина, к которой подключаются запущенные от имени пользователя приложения, в то время как системная шина чаще всего не имеет своего пользователя (сервисы HAL, сетевой стек, bluetooth и т.д.) --dest=org.naquadah.awesome.awful — здесь мы указываем кто будет являться получателем нашего сигнала, в данном случае это Awesome /ru/console/mocp — уникальное имя объекта (обычно имя сервиса, путь к объекту и интерфейс), в нашем случае создаем его сами. ru.console.mocp.songChanged — используемый метод, по сути вызываемая функция которая и порождает сигнал, в случае если используется приложение. Также аналогично можно использовать и посылку сигналов из Awesome различным приложениям, например, чтобы переключить трек в различных плеерах, поменять статус в Pidgin и т.д. При этом преимуществом данного способа будет то, что не требуется запускать копию терминала, и передавать ему команду для обработки, что пусть и не сильно, но нагружает ресурсы системы, на создание терминала, обработку команды в нем, а потом и уничтожение этого терминала. Об этом способе и примерах поговорим чуть позже. Как видите все достаточно просто. Но ведь этого недостаточно. Одно дело послать сообщение, что отработала такая то функция, а другое передать еще и результат в сигнале. Такая возможность есть, вы можете через Dbus сигналы передавать данные для ваших виджетов или функций. Например тот же kbdd передает помимо самого сигнала еще и выбранную раскладку ( в виде числа, а в другой функции и название раскладки, поэкспериментируйте). Если же вы используете другой менеджер раскладки, то и там та же ситуация. Наиболее тяжелый сигнал в KDE, там передается очень много информации, в том числе и двоичной. Поддерживаемые типы данных: string, byte, boolean, int16, uint16, int32, uint32, int64, uint64, dooble, object_path ==Практическая реализация== ===Работа с файловой системой=== Все изменения мы будем вносить только в rc.lua. Сначала создадим виджет который будет отображать информацию: --Awesome 3.4 fs_root = widget({type = \"textbox\"}) fs_root.text = \"Занято:\" --Awesome 3.5 fs_root = wibox.widget.textbox() fs_root:set_text(\"Занято:\") Затем создадим таймер, который будет запрашивать данные: fs_timer = timer ({timeout = 600}) --раз в 10 минут fs_timer:add_singal (\"timeout\", function () awful.util.spawn_with_shell(\"dbus-send --session --dest=org.naquadah.awesome.awful /ru/console/df ru.console.df.fsValue string:$(df -h --output='pcent' /home | sed '1d;s/ //g' )\" ) end ) fs_timer:start() если вы используете Awesome 3.5, то просто замените add_singal на connect_signal И обновляем значение, при получении сигнала: dbus.request_name(\"session\", \"ru.console.df\") dbus.add_match(\"session\", \"interface='ru.console.df', member='fsValue' \" ) dbus.add_singal(\"ru.console.df\", function (...) local data = {...} local dbustext = data[2] fs_root.text = \"Занято: \" .. dbustext --для 3.5 fs_root:set_text(\"Занято:\" .. dbustext) end ) Все, перезапускаем Awesome! Преимуществом данного способа будет то, что Awesome не будет ждать (и соответственно висеть) пока обрабатывается вызванный код. В случае если вы вызываете одну и ту же команду с разными параметрами, можно вернуть вторым значением этот параметр, и соответственно в самом Awesome его проверить и вызывать нужный обработчик. На нашем примере чуть чуть модифицируем функцию таймера: path = '/home' fs_timer:add_singal (\"timeout\", function () awful.util.spawn_with_shell(\"dbus-send --session --dest=org.naquadah.awesome.awful /ru/console/df ru.console.df.fsValue string:$(df -h --output='pcent' \" ..path.. \" | sed '1d;s/ //g' )\" string:\"..path) end ) dbus.request_name(\"session\", \"ru.console.df\") dbus.add_match(\"session\", \"interface='ru.console.df', member='fsValue' \" ) dbus.add_singal(\"ru.console.df\", function (...) local data = {...} local dbustext = data[2] local dbuspath = data[3] if dbustext == '/' then fs_root.text = \"Занято: \" .. dbustext --для 3.5 fs_root:set_text(\"Занято:\" .. dbustext) elseif dbustext == '/home' then fs_home.text = \"Занято: \" .. dbustext --для 3.5 fs_home:set_text(\"Занято:\" .. dbustext) end end ) ===Взаимодействие с mocp=== К сожалению сам mocp не поддерживает dbus, но он может вызывать внешнюю команду при смене трека (и не только, за подробностями к документации). В конфиге для mocp я добавил свой обработчик: OnSongChange = \"/home/user/script/changesong.sh %f %a %t %d %r %n\" Здесь мы передаем все необходимые значения: путь к файлу, исполнитель, название, время, альбом, для того, чтобы потом не дергать mocp еще раз, чтобы получить эти данные, как указано в изначальных версиях этих скриптов. Затем, создаем скрипт (changesong.sh) для получения обложки и формирования текста: #!/bin/bash # changesong.sh #файл с обложкой по умолчанию DEFAULT_COVER=\"/home/user/Images/no-cover.jpg\" [ -n \"$1\" ] && FULLDIR=`dirname \"$1\"` [ -n \"$FULLDIR\" ] && COVERS=`ls \"$FULLDIR\" | grep \"\\.jpg\\|\\.png\\|\\.gif\"` if [ -z \"$COVERS\" ]; then COVERS=\"$DEFAULT_COVER\" else TRYCOVERS=`echo \"$COVERS\" | grep -i \"cover\\|front\\|folder\\|albumart\" | head -n 1` if [ -z \"$TRYCOVERS\" ]; then TRYCOVERS=`echo \"$COVERS\" | head -n 1` if [ -z \"$TRYCOVERS\" ]; then TRYCOVERS=\"$DEFAULT_COVER\" else TRYCOVERS=\"$FULLDIR/$TRYCOVERS\" fi else TRYCOVERS=\"$FULLDIR/$TRYCOVERS\" fi COVERS=\"$TRYCOVERS\" fi MTITLE= \" Исполнитель: $2 Название: $3 Альбом: $5 Трек: $6 Время: $4\" dbus-send --session --dest=org.naquadah.awesome.awful /ru/console/mocp ru.console.mocp.songChanged \\ string:\"$MTITLE\" \\ string:\"$COVERS\" #обязательно помещаем переменную в кавычки, т.к. иначе некорректно передается строка (особенность bash) Даем скрипту права на исполнение: chmod +x changesong.sh Добавляем обработчик в Awesome: dbus.request_name(\"session\", \"ru.console.mocp\" dbus.add_match(\"session\", \"interface='ru.console.mocp', member='songChanged' \") dbus.add_signal(\"ru.console.mocp\", function(...) local data = {...} coverart_nf = naughty.notify({icon = data[3], icon_size = 100, text = data[2], position = \"bottom_left\"}) end ) Хотя результат и будет тем же самым, что и в изначальном варианте, но разница будет в том, что система не зависнет если жесткий диск будет занят, плюс мы используем один скрипт вместо 2х в первоначальной версии. Также в скрипте мы не производим проверку на состояние mocp (переключение состояния пауза/воспроизведения) и запущенно ли вообще приложение, если вам это необходимо, добавьте соотвествующий код. ==Посылка сигнала из Awesome== Стандартный Awesome к сожалению не имеет функции для отправки сигналов dbus, по крайней мере на wiki нет ни слова об этой возможности. Поэтому приходится использовать отправку сигналов через shell, например это можно сделать следующим образом (на примере переключателя клавиатуры kbdd): --виджет клавиатуры kbdwidget = widget({type = \"textbox\", name = \"kbdwidget\"}) kbdwidget.border_color = beautiful.fg_normal kbdwidget.border_width = 1 kbdwidget.text = '<span color=\"#F8EC5D\"><b> Eng </b></span>' next_layout=1 function changeKeyboardLayout(keyboard_layout) awful.util.spawn( \"dbus-send --type=method_call --session --dest=ru.gentoo.KbddService /ru/gentoo/KbddService ru.gentoo.kbdd.set_layout uint32:\".. keyboard_layout ) end dbus.request_name(\"session\", \"ru.gentoo.kbdd\") dbus.add_match(\"session\", \"interface='ru.gentoo.kbdd',member='layoutChanged'\") dbus.add_signal(\"ru.gentoo.kbdd\", function(...) local data = {...} local layout = data[2] lts = {[0] = '<span color=\"#F8EC5D\"><b> Eng </b></span>', [1] = '<span color=\"#FF3000\"><b> Рус </b></span>'} kbdwidget.text = \" \"..lts[layout]..\" \" if layout == 1 then next_layout = 0 else next_layout = 1 end end ) kbdwidget:buttons(awful.util.table.join(awful.button({}, 1, function () changeKeyboardLayout(next_layout) end))) Здесь мы через нажатие на виджет левой кнопкой мыши меняем раскладку клавиатуры, посылая сообщение об этом через dbus. Также необходимо добавить в автозагрузку сам kbdd, иначе ничего не будет работать. Кстати если у вас не работают виджеты в русской раскладке(например после изменения раскладки на русскую при нажатии на виджет не меняется раскладка на английскую) прочтите статью известные проблемы. ==Поиск нужных сигналов приложений== Большинством приложений можно напрямую управлять через dbus, т.е. можно переключать треки, переводить приложения в полноэкранный режим, менять статусы и т.д. Для получения списка всех возможных сигналов и методов запустите приложение (без этого не произойдет регистрации доступных событий), после чего запустите qdbus, найдите нужный интерфейс, например: qdbus | grep clementine Получим следующий вывод: org.mpris.MediaPlayer2.clementine org.mpris.clementine Затем, запустим: qdbus org.mpris.clementine Получим следующиее: / /Player /TrackList /org /org/mpris /org/mpris/MediaPlayer2 А затем вызовем: qdbus org.mpris.clementine /Player И получим все возможные методы и сигналы для данного приложения. Например, нас интересует переключение на следующий трек, метод для этого выглядит следующим образом: method void org.freedesktop.MediaPlayer.Next() В данном случае метод не требует каких либо параметров, поэтому просто вызываем его: dbus-send --type=method_call --session --dest=org.mpris.clementine /Player org.freedesktop.MediaPlayer.Next Собственно, все. Дальше экспериментируйте и ищите сами. ==Отслеживание сигналов из скриптов== Если вы хотите выполнить более сложные задания, чем вызов отдельных методов, то вы можете написать скрипт командной оболочки, содержащий dbus-send команды, или используйте язык более высокого уровня, для упрощения задачи. Существуют D-Bus привязки для Python, Ruby и Java языков. В следующем примере, будет показан скрипт на Python, который меняет статус в Pidgin на “Away from keyboard”, при активизации скринсейвера. Здесь имеются два аспекта D-Bus: скрипт ждет сигнала от скринсейвера, и затем он вызывает метод в Pidgin. Сразу оговорюсь, скрипт не мой, ссылка на оригинал приведена ниже, но не описать эту возможность взаимодействия я просто не мог. pidgin_screensaver.py #!/usr/bin/env python def pidgin_status_func(state): obj = bus.get_object(\"im.pidgin.purple.PurpleService\", \"/im/pidgin/purple/PurpleObject\") pidgin = dbus.Interface(obj, \"im.pidgin.purple.PurpleInterface\") status = pidgin.PurpleSavedstatusFind(\"afk\") if status == 0: status = pidgin.PurpleSavedstatusNew(\"afk\", 5) if state: pidgin.PurpleSavedstatusSetMessage(status, \"Away from keyboard\") pidgin.PurpleSavedstatusActivate(status) import dbus, gobject from dbus.mainloop.glib import DBusGMainLoop dbus.mainloop.glib.DBusGMainLoop(set_as_default=True) bus = dbus.SessionBus() bus.add_signal_receiver(pidgin_status_func, dbus_interface=\"org.gnome.ScreenSaver\", signal_name=\"ActiveChanged\") loop = gobject.MainLoop() loop.run() Давайте разберем этот скрипт. Функция pidgin_status_func устанавливает ваш статус в Pidgin. Она получает объект im/pidgin/purple/PurpleObject и интерфейс im.pidgin.purple.PurpleInterface из сессионной шины. Далее, вызывается метод интерфейса. Он создает новый “saved status” тип, после проверки существования типа статус с именем “afk” (“afk” означает “Away From Keyboard”, и 5 — это вид “away” статуса). Далее функция проверяет переменную state, которая является аргументом функции pidgin_status_func (я объясню, что означает этот аргумент далее). Если аргумент правдив, то сообщению нового статуса “afk” присваивается значение “Away from keyboard”, и статус активируется. В результате Pidgin показывает ваш статус как “afk\", с сообщением “Away from keyboard”. Теперь мы должны вызвать эту функцию вместе с активизацией скринсейвера. Поэтому, запускаем dbus.mainloop и соединяемся к сессионной шине. Далее добавляем приемник сигнала, который слушает сигнал ActiveChanged от интерфейса org.gnome.ScreenSaver. Если/когда сигнал срабатывает, он вызывает функцию pidgin_status_func. Так как сигнал ActiveChanged имеет булев аргумент, обозначающий текущее состояние заставки (1 — активная, 0 — не активная), то мы используем только один аргумент (state) в функции pidgin_status_func. Для постоянного прослушивания запускаем бесконечный цикл, работающий пока работает скрипт. Вообще, у многих приложений есть интерфейс dbus, поэтому возможности по их управлению очень обширны, и ограничены только Вашей фантазией и желанием! ==Ссылки по теме== Введение в DBus OpenNET D-Bus Tutorial LOR Управление Linux десктопом через D-Bus Update 1. Небольшое обновление: ru.gentoo.kbdd заменен на ru.gentoo.KbddService т.к. менялось только название, без изменения самой раскладки. Дополнительно вынесена отдельно функция по изменению раскладки, т.к. удобно автоматически менять раскладку при вызове Mod4+r или Mod4+p (перед вызовом добавил changeKeyboardLayout(0)", "image": [], "tag": ["awesome wm", "dbus"], "rating": ["+26"], "bookmarks": ["72"], "views": ["10,4k"], "comments_count": ["7"]},
{"author": ["OldFisher"], "date": ["22 сентября 2014 в 15:40"], "hubs": ["Lua", "C++"], "type_label": [], "text": "Здравствуйте, коллеги. Хочу познакомить вас с моим небольшим проектом, который, надеюсь, сможет пригодиться и вам. С Lua я познакомился несколько лет назад, когда подыскивал внедряемый скриптовой язык, отличающийся скромным размером и высокой производительностью. Lua не только отвечает этим запросам, но и подкупает удивительной простотой и выразительностью. Не могу сказать, что я недоволен Lua API: это отличный набор функций, удобный и простой в использовании. Интеграция языка в своё приложение и добавление собственных расширений не вызвали трудностей, никаких «подводных камней» тоже не возникло. Но всё же при использовании этого API, ориентированного на Си, меня не оставляла мысль, что этот процесс мог бы быть и поудобнее. Первая попытка сделать удобную объектно-ориентированную обёртку потерпела неудачу: имеющимися средствами мне не удалось создать что-то заслуживающее существования, всё выходило чересчур громоздко и неочевидно. А потом появился C++11, который снял все мешавшие мне препятствия (точнее говоря — добавил то, чего не хватало), и головоломка постепенно начала складываться. Второй заход оказался удачным, и в результате я сумел создать достаточно легковесную библиотеку-обёртку с естественным синтаксисом большинства операций. Эта библиотека, которую я назвал Lua API++, призвана служить удобной заменой для Lua API. Этой статья, написанная по мотивам моего выступления на Lua Workshop, поможет познакомиться с основными понятиями Lua API++ и предоставляемыми ей возможностями. Основные действующие лица Знакомство следует начинать с основных понятий, используемых библиотекой, и взаимоотношений между ними. Как и следовало ожидать, эти понятия отражены в соответствующих типах. StateState — владелец состояния Lua. Это самостоятельный тип, практически не связанный с остальной частью библиотеки. Помимо контроля над созданием и уничтожением состояния, он предоставляет только средства для выполнения файлов, строк и Lua-совместимых функций. Ошибки, возникающие в ходе их работы, преобразуются в исключения. LFunctionВсё остальное в библиотеке происходит внутри LFunction, функций специального формата, совместимых с Lua API++. Это аналог Lua-совместимых функций, которым в свою очередь было дано название CFunction. Особый формат функции понадобился в основном для того, чтобы впустить нашего следующего персонажа: ContextContext — это контекст функции, а также центр доступа ко всем возможностям Lua. С его помощью можно получить доступ к глобальным переменным, аргументам функции, реестру и upvalues. Можно управлять сборщиком мусора, сигнализировать об ошибках, передавать множественные возвращаемые значения и создавать замыкания. Проще говоря, через Context делается всё то, что не относится непосредственно к операциям над значениями, которые являются прерогативой нашего замыкающего: ValueВ отличие от предыдущих понятий, которым однозначно соответствовал одноимённый класс, «значение» в Lua API++ несколько расплывчато (хотя класс Value, конечно же, есть). В первую очередь это связано с политикой «открытых границ», которая позволяет свободную миграцию нативных значений в Lua и наоборот. Везде, где ожидаются значения Lua, можно подставлять нативные значения поддерживаемых типов и они автоматически «переедут» на стек Lua. Операторы неявного преобразования типов помогут переезду значения в обратном направлении, а в случае несовместимости реального и ожидаемого типа известят нас об этом при помощи исключения. Кроме этого, значения в Lua в зависимости от их происхождения могут быть представлены разными типами, поддерживающими общий интерфейс. Этот интерфейс реализует все допустимые операции над значениями: явное и неявное преобразование в нативные типы, вызовы функций, индексацию, арифметические операции, сравнение, проверку типов, запись и чтение метатаблиц. ValrefЭто ссылка на размещёное на стеке значение, а если точнее — то даже не столько на значение, сколько на конкретный слот на стеке Lua. Valref не занимается размещением или удалением значений на стеке, а сосредоточен исключительно на операциях над значением. В документации к Lua API++ Valref служит образцом, которому следует интерфейс других типов, представляющих значения. TemporaryС временными значениями, которые являются результатом операций, несколько сложнее. Это значения, которые будут помещены (а может, и не будут) на стек в результате операции, использованы единожды, а затем удалены. К тому же, аргументы операции сами по себе могут быть результатами других операций, да ещё и без гарантий успеха. Да и использование бывает разное: при индексации в результате чтения на стеке создаётся новое значение взамен ключа, а в результате записи — со стека удаляются ключ и записанное значение. А как насчёт необходимости строго соблюдать очерёдность размещения аргументов операций? И что делать с неиспользованными объектами? Многие, вероятно, уже догадались, к чему я клоню. Временные значения представлены proxy-типами. Они незримо для пользователя конструируются при помощи шаблонов и воспроизводят интерфейс Valref. Пользоваться ими легко, просто и удобно, но допустите ошибку, и компилятор «порадует» вас объёмистым сочинением, изобилующим угловыми скобками. ЯкориЯкори названы так потому, что позволяют «прикнопить» к стеку одно или несколько значений. Value — универсальный «якорь» для одного значения, Table специализирован для таблиц, а Valset хранит несколько значений. Теперь, когда главные действующие лица нам представлены, можно приступить к более подробному разбору того, что мы с ними можем делать. StateУ State есть конструктор по умолчанию, выполняющий все необходимые для инициализации контекста действия. Альтернативный конструктор позволяет задействовать пользовательскую функцию управления памятью. Можно запросить «сырой» указатель на объект состояния, используемый в Lua API, функцией getRawState. В комплекте идут функции runFile, runString и call, которые позволяют смастерить простейший интерпретатор: Простейший интерпретатор#include <iostream> #include <luapp/lua.hpp> using namespace std; using namespace lua; void interpretLine(State& state, const string& line) { try { state.runString(line); // Пытаемся выполнить строку } catch(std::exception& e) { // О неудаче и её причинах нам сообщат в исключении cerr << e.what() << endl; } } void interpretStream(State& state, istream& in) { string currentLine; while(!in.eof()) { // Читаем поток по строкам и каждую интерпретируем getline(in, currentLine); interpretLine(state, currentLine); } } int main() { State state; interpretStream(state, cin); } Обработка ошибок Подход, используемый библиотекой, заключается в том, чтобы не путаться под ногами у Lua, поэтому диагностируются либо те ошибки, которые связаны с работой самой библиотеки, вроде попыток создать Table не из таблицы, либо те, которые понадобится (возможно) перехватывать в пользовательском коде, вроде ошибок приведения типов. Библиотека не пытается диагностировать заранее те ошибки, которые могут обнаружиться при вызове Lua API. Поэтому попытка, например, использовать вызов функции на значении, которое на самом деле является числом, не вызовет исключения. Она будет обнаружена внутри вызова lua_call и вызовет ошибку в стиле Lua (прерывание выполнения и возврат к ближайшей точке защищённого вызова). LFunction Вообще-то библиотека поддерживает «прозрачную» обёртку функций, оперирующих поддерживаемыми типами (и даже функций-членов). Достаточно просто упомянуть имя функции там, где ожидается Lua-значение. Но если мы хотим получить доступ ко всем удобствам Lua, предоставляемым Lua API++, надо писать L-функции в соответствии с таким прототипом: Retval myFunc(Context& c); Здесь всё просто: наша функция получает Context, а Retval — специальный тип, помогающий с удобством возвращать произвольное количество значений через функцию Context::ret. Шаблон mkcf позволяет сделать из LFunction то, с чем подружится Lua:int (*myCfunc)(lua_State*) = mkcf<myFunc>; Таким образом мы можем явно создавать обёртки для нашей функции. «Прозрачная» обёртка тоже сработает, но накладные расходы будут чуть выше. С другой стороны, mkcf будет создавать отдельную функцию-обёртку в каждом случае. Так или иначе, но в любом случае «обёртка» будет создавать объект Context, передавать его нашей функции, а по завершении работы передавать в Lua возвращаемые через Retval значения. Все исключения, вышедшие за пределы оборачиваемой функции, будут перехвачены и преобразованы в ошибку Lua. Функция, возвращающая себя саму? Дайте две!Retval retSelf(Context& c) { return c.ret(retSelf, mkcf<retSelf>); // Вернём сразу две функции, созданные по-разному } Context Контекст функции — это центральный узел доступа к Lua. Всё, что не связано непосредственно с работой со значениями, выполняется через Context. Не стану отвергать намёки на явное сходство с god object, но в данном случае такое решение диктуется архитектурой Lua API. Через Context можно управлять сборщиком мусора, можно узнать номер версии и количество размещённых на стеке значений. Он неявно преобразуется в lua_State* на случай, если надо поколдовать с Lua API напрямую. На этот же случай предусмотрено волшебное слово (точнее, статическая константа сигнального типа) initializeExplicitly, позволяющее создавать Context явно, за пределами LFunction. Возврат значенийКак бы ни было приятно просто указывать в операторе return возвращаемые из функции значения, это невозможно. Пришлось сделать выбор между двумя ближайшими альтернативами: хитрый «стартер» с перегрузкой оператора запятой или вызов функции. Победила дружба функция. Поэтому LFunction и требует возвращать Retval, создать который можно лишь обращением к методу Context со скромным названием ret. Это особенная функция: после её вызова прекращается работа со стеком, чтобы не скинуть с него наши значения, поэтому употреблять её следует лишь непосредственно в операторе return. В вызове ret можно перечислить столько возвращаемых значений, сколько понадобится. Сравнениеreturn ctx.ret(1, \"two\", three); Эквивалентный код: lua_pushinteger(ctx, 1); lua_pushstring(ctx, \"two\"); lua_pushvalue(ctx, three); return 3; Сигнализация об ошибкахУтверждая, что единственный способ создать Retval — обратиться к функции ret, я не погрешил против истины, но есть один нюанс… С формальной точки зрения имеется ещё и функция error, которая тоже возвращает этот тип. Только на самом деле до создания Retval не доходит, потому что из этой функции не происходит возврата. Максимум, на который можно рассчитывать — передать своё сообщение механизму обработки ошибок Lua. Документация по Lua API рекомендует применять вызов lua_error в операторе return, чтобы обозначить тот факт, что исполнение функции прерывается во время вызова. Тот же самый подход применяется и в Lua API++, потому-то error и объявлена возвращающей Retval. В качестве аргумента принимается Lua-значение с сообщением об ошибке, и конкатенация тут будет вполне уместна, тем более что зачинателем может выступить функция where, создающая строку, описывающую текущую функцию. Это же значение используется, если сообщение вообще не указывать. if(verbose) return ctx.error(ctx.where() & \" intentional error \" & 42); else return ctx.error(); // То же самое, что return ctx.error(ctx.where()); Эквивалентный кодif(verbose) { luaL_where(ctx, 0); lua_pushstring(ctx, \" intentional error \"); lua_pushinteger(ctx, 42); lua_concat(ctx, 3); return lua_error(ctx); } else { luaL_where(ctx, 0); return lua_error(ctx); } Доступ к окружениюНаш Context, очевидно, является первоисточником значений. В самом деле, откуда ещё им взяться? Нам в пользование предоставляются объекты доступа, оформленные как открытые члены класса Context, позволяющие дотянуться до разных интересных мест окружения. Все они позволяют осуществлять как чтение, так и запись значений. В первую очередь это args, аргументы функции. В отличие от других объектов доступа, для каждого из которых создавался специальный недоступный для пользователя тип, здесь применяется обычный константный Valset. Его константность означает лишь то, что мы не можем изменять его размер, а вот переписывать значения аргументов — на здоровье. Поскольку Valset создавался как STL-совместимый контейнер, нумерация элементов в нём начинается с 0. В остальных случаях библиотека придерживается правил Lua и подразумевает, что индексация начинается с 1. if(ctx.args.size() > 1 && ctx.args[0].is<string>()) {...}; Эквивалентный код if(nArgs > 1 && lua_isstring(ctx, 1) ) {...}; На втором месте стоит доступ к глобальным переменным. Объект global индексируется строками. ctx.global[\"answer\"] = 42; // Если такой глобальной переменной не было, теперь появится Эквивалентный кодlua_pushinteger(ctx, 42); lua_setglobal(ctx, \"answer\"); Если наша LFunction по совместительству является замыканием, то к хранящимся в ней значениям мы можем обратиться через upvalues с целочисленным индексом (начиная с 1, всё правильно). Способа узнать количество хранимых значений нет: предполагается, что это и так известно. Реестр Lua, доступный через registry, используется двумя способами. По строковым ключам там хранятся метатаблицы для пользовательских данных. Целочисленные ключи задействуются при использовании реестра в качестве хранилища значений. Ключ создаётся вызовом registry.store и в дальнейшем применяется для чтения и записи в registry, стирание значения и освобождение ключа происходит при записи nil. auto k = ctx.registry.store(ctx.upvalues[1]); // decltype(k) == int ctx.registry [k] = nil; // Ключ k освободился и может снова стать результатом store Эквивалентный кодlua_pushvalue(ctx, lua_upvalueindex(1)); auto k = luaL_ref(ctx, LUA_REGISTRYINDEX); luaL_unref(ctx, LUA_REGISTRYINDEX, k); ФункцииЯ только что упомянул о том, что Lua позволяет создавать замыкания. В объекте Context для этого применяется функция closure, которая получает CFunction и те значения, которые будут храниться в замыкании. Результат — временный объект, то есть полноценное Lua-значение. Вместо CFunction мы можем указать сразу LFunction, но у этой лёгкости есть своя цена. В получившемся замыкании будет зарезервировано первое upvalue (там хранится адрес функции, поскольку обёртка одна и та же для любой LFunction). Эта же функция применяется и для прозрачной миграции LFunction с теми же последствиями. В этом состоит отличие от шаблона mkcf, который ничего не резервирует, но зато создаёт отдельную функцию-обёртку для каждой функции. А ещё можно создавать чанки: скомпилированный код Lua. Непосредственно текст компилируется методом chunk, а содержимое файла при помощи load. Для случаев «выполнил и забыл» есть runString и runFile, точно такие же, как и в State. С точки зрения использования чанк — обычная функция. Замыкания можно создавать и из несовместимых функций при помощи метода wrap. Он автоматически создаёт обёртку, которая берёт аргументы со стека Lua, преобразует их в значения, принимаемые нашей функцией, производит вызов и размещает результат на стеке Lua в качестве возвращаемого значения. По умолчанию это работает со всеми поддерживаемыми типами, включая пользовательские данные. А если этого мало (например, нам надо вытворять что-то со строками, хранящимися в vector, то можно и самому указать преобразование в ту или другую сторону при помощи специальных макросов. Именно wrap срабатывает при неявной миграции функций. Братский метод vwrap делает почти всё то же самое, только игнорирует возвращаемое оборачиваемой функцией значение. Миграция значений Lua API++ поддерживает следующие нативные типы: Числовые int unsigned int long long unsigned long long float double Строковые const char* std::string Функции CFunction: int (*) (lua_State*) LFunction: Retval (*) (Context&) Произвольные функции Функции-члены Разное Nil bool LightUserData: void* зарегистрированные пользовательские типы Значения перечисленных в таблице типов могут мигрировать на стек Lua и обратно (за исключением, естественно, Nil и «обёрнутых» функций, которые остаются указателями на обёртки). Обратная миграция осуществляется при помощи встроенных в Value-типы операторов неявного преобразования и при помощи шаблонной функции cast.Если в Lua-значении содержатся данные, которые невозможно преобразовать в то, во что мы пытаемся, будет выброшено исключение. Функция optcast вместо исключений вернёт «запасное» значение. int a = val; auto b = val.cast<int>(); auto c = val.optcast<int>(42); Эквивалентный кодif(!lua_isnumber(ctx, valIdx)){ lua_pushstring(ctx, \"Conversion error\"); return lua_error(ctx); } int a = lua_tointeger(ctx, valIdx); if(!lua_isnumber(ctx, valIdx)){ lua_pushstring(ctx, \"Conversion error\"); return lua_error(ctx); } auto b = lua_tointeger(ctx, valIdx); auto c = lua_isnumber(ctx, valIdx) ? lua_tointeger(ctx, valIdx) : 42; Проверить совместимость с нужным типом можно функцией is, а при помощи type — узнать тип хранимого значения непосредственно. if(val.is<double>()) ...; if(val.type() == ValueTypes::Number) ...; Операции с одиночным значением ПрисваиваниеЕсли у нас есть Value, то в общем случае ему можно что-нибудь присвоить, как другие Value, так и нативные. Но это не относится к некоторым временным значениям, например, к результату вызова функции или длине: оказавшись по левую сторону от знака =, они выдадут мудрёную ошибку. А вот другие временные значения, вроде индексации или метатаблицы, присваивание вполне допускают. По смыслу выполняемого действия несложно догадаться, чему присваивать можно, а чему нельзя. МетатаблицыМетод mt даёт доступ к метатаблице значения, которую можно читать и записывать. { Table mt = val.mt(); val.mt() = nil; } Эквивалентный кодif(!lua_getmetatable(ctx, valIdx)){ lua_pushstring(ctx, \"The value has no metatable\"); return lua_error(ctx); } int mtIdx = lua_gettop(ctx); lua_pushnil(ctx); lua_setmetatable(ctx, valIdx); lua_pop(ctx, 1); ДлинаРабота функции len различается в разных версиях Lua: в режиме совместимости с 5.1 она возвращает нативный size_t, а в режиме 5.2 временное значение. ИндексацияДоступ к элементам таблицы по ключу осуществляется индексированием, ключ может иметь любой поддерживаемый тип. Но надо помнить о том, что при оборачивании функций будут создаваться новые замыкания: void myFunc(); Retval example(Context& c) { Table t(c); t[myFunc] = 42; // Здесь myFunc порождает одно замыкание... assert(t[myFunc].is<Nil>()); // а здесь - уже второе, не равное первому. t[mkcf<example>] = 42.42; // А это у нас CFunction, она идёт \"налегке\" assert(t[mkcf<example>] == 42.42); } Эквивалентный кодvoid myFunc(); int wrapped_void_void(lua_State* s) { if(!lua_islightuserdata(ctx, lua_upvalueindex(1))) { lua_pushstring(ctx, \"Conversion error\"); return lua_error(ctx); } void (*fptr) () = reinterpret_cast<void(*)()>(lua_touserdata(ctx, lua_upvalueindex(1))); fptr(); return 0; } int mkcf_myFunc(lua_State* s) { myFunc(); return 0; } int example(lua_State* ctx) { lua_createtable(ctx, 0, 0); int t = lua_gettop(ctx); lua_pushlightuserdata(ctx, reinterpret_cast<void*>(&myFunc)); lua_pushcclosure(ctx, &wrapped_void_void, 1); lua_pushinteger(ctx, 42); lua_settable(ctx, t); lua_pushlightuserdata(ctx, reinterpret_cast<void*>(&myFunc)); lua_pushcclosure(ctx, &wrapped_void_void, 1); lua_gettable(ctx, t); assert(lua_isnil(ctx, -1)); lua_pushcfunction(ctx, &mkcf_myFunc); lua_pushnumber(ctx, 42.42); lua_settable(ctx, t); lua_pushcfunction(ctx, &mkcf_myFunc); lua_gettable(ctx, t); lua_pushnumber(ctx, 42.42); int result = lua_compare(ctx, -1, -2, LUA_OPEQ); lua_pop(ctx, 2); assert(result == 1); } Вызов функцийВызов Lua-функций осуществляется обычными круглыми скобками. Есть метод call для явного вызова, на тот случай, если надо как-то повыразительнее. Защищённый вызов pcall предохраняет от ошибок. int x = fn(1); int y = fn.call(1); // То же самое int z = fn.pcall(1); // А тут лучше было проверить, возникла ли ошибка Множественные возвращаемые значенияМы только что видели, что результат вызова можно смело использовать как обычное значение. Но как быть с функциями, которые возвращают сразу несколько значений? Возьмём для примера такую функцию на Lua: function mrv() return 2, 3, 4; end У нас есть сразу несколько вариантов. Во-первых, можно вообще игнорировать результаты вызова, никак не используя выражение вызова. Все возвращённые значения будут просто выкинуты. mrv(); Эквивалентный кодlua_pushvalue(ctx, mrvIdx); lua_call(ctx, 0, 0); Во-вторых, можно использовать выражение вызова в качестве обычного Lua-значения. Тогда будет использовано только первое возвращённое значение (или nil, если функция вообще ничего не вернула), а остальные опять же будут выкинуты. Value x = mrv(); // x == 2 Эквивалентный кодlua_pushvalue(ctx, mrvIdx); lua_call(ctx, 0, 1); int x = lua_gettop(ctx); В-третьих, в контексте, подразумевающем последовательность значений (например, параметры функции) выражение вызова подвергнется раскрытию: возвращённые значения станут частью последовательности. print(1, mrv(), 5); // Напечатает 1 2 3 4 5 Эквивалентный кодlua_pushvalue(ctx, printIdx); int oldtop = lua_gettop(ctx); lua_pushinteger(ctx, 1); lua_pushvalue(ctx, mrvIdx); lua_call(ctx, 0, LUA_MULTRET); lua_pushinteger(ctx, 5); int nArgs = lua_gettop(ctx) - oldtop; lua_call(ctx, nArgs, 0); В-четвёртых, можно просто сохранить всё в Valset, придуманный специально для этого. Valset vs = mrv.pcall(); // vs.size() == 3, vs.success() == true Эквивалентный кодint vsBegin = lua_gettop(ctx) + 1; lua_pushvalue(ctx, mrvIdx); bool vsSuccess = lua_pcall(ctx, 0, LUA_MULTRET) == LUA_OK; int vsSize = lua_gettop(ctx) + 1 - vsBegin; Valset запомнит и то, был ли защищённый вызов удачным (это единственный способ получить эту информацию). В случае неудачи он будет содержать сообщение об ошибке. Что приятно, Valset способен раскрываться в списке значений точно так же, как и выражение вызова. print(1, vs, 5); // Напечатает 1 2 3 4 5 Эквивалентный кодlua_pushvalue(ctx, printIdx); int oldTop = lua_gettop(ctx); lua_pushInteger(ctx, 1); lua_pushvalue(ctx, mrvIdx); for(auto i = 0; i < vsSize; ++i) lua_pushvalue(ctx, vsBegin + i); lua_pushinteger(ctx, 5); int nArgs = lua_gettop(ctx) - oldtop; lua_call(ctx, nArgs, 0); Однако этим польза Valset не исчерпывается. Он является STL-подобным контейнерам и к нему можно применять алгоритмы STL, а в качестве «хранимых» значений выступают Valref. Если Valset расположен на стеке последним, то к нему применимы операции добавления и удаления значений push_back и pop_back. Обычно при использовании целикового Valref происходит дублирование содержащихся значений, но если мы возвращаем его из функции (но только один Valset), то его содержимое используется непосредственно. Так можно накапливать возвращаемые значения, количество которых становится известно во время выполнения. Операции с двумя значениями Для выполнения бинарных операций достаточно, чтобы Value-тип присутствовал хотя бы с одной стороны, что позволяет вовлекать в преобразования нативные значения по принципу домино: string s = \"The answer to question \" & val & \" is \" & 42; Эквивалентный кодlua_pushstring(ctx, \"The answer to question \"); lua_pushvalue(ctx, valIdx); lua_pushstring(ctx, \" is \"); lua_pushinteger(ctx, 42); lua_concat(ctx, 4); string s = lua_tostring(ctx, -1); lua_pop(ctx, 1); Знаком & обозначается конкатенация. Цепные конкатенации оптимизируются в единый вызов, «склеивающий» сразу несколько значений. Заодно конкатенация является одним из тех мест, в которых раскрываются выражения вызова и Valset. Сравнения тоже выполняются через Lua, но производят нативные булевские значения. В версии 5.2 доступна и арифметика, включая возведение в степень, под которую был «угнан» символ ^ вместе со своим низким приоритетом. Таблицы У таблиц, представляемых типом Table, интерфейс по сравнению с Valref несколько урезан. Оставлена индексация, проверка длины, метатаблицы, но убраны не относящиеся к таблицам операции вроде вызова функции. Взамен имеется объект доступа raw, осуществляющий прямой доступ к данным, без задействования метатаблиц, а также функция iterate для перебора содержимого таблицы, аналог for_each. Прямой доступ выглядит как обычная индексация и ничем особо не примечателен, а вот iterate принимает функцию (точнее говоря, сойдёт что угодно, лишь бы вело себя как функция), применяемую к парам ключ-значение. Эта функция получает ключ и значение в виде Valref и возвращает true, чтобы продолжить перебор и false, чтобы остановить. А можно ничего не возвращать и просто пройтись по всему содержимому: Table t = ctx.global[\"myTable\"]; t.iterate([] (Valref k, Valref v) { cout << int(k) << int(v); }); Эквивалентный кодlua_getglobal(ctx, \"myTable\"); if(!lua_istable(ctx, -1)){ lua_pushstring(ctx, \"Conversion error\"); return lua_error(ctx); } int t = lua_gettop(ctx); lua_pushnil(ctx); size_t visited = 0; while(lua_next(ctx, t)) { ++ visited; if(!lua_isnumber(ctx, -2) || !lua_isnumber(ctx, -1)){ lua_pushstring(ctx, \"Conversion error\"); return lua_error(ctx); } cout << lua_tointeger(ctx, -2) << lua_tointeger(ctx, -1); lua_pop(ctx, 1); } Результатом iterate будет количество обработанных записей. Однако самые полезные функции в Table — статические методы array и records. Они позволяют сразу создавать заполненные таблицы просто указав их содержимое. fn(Table::array(ctx, \"one\", 42, Table::array(ctx, 1, 2, 3))); // Вложенные таблицы? Легко! Эквивалентный кодlua_pushvalue(ctx, fn); lua_createtable(ctx, 3, 0); lua_pushinteger(ctx, 1); lua_pushstring(ctx, \"one\"); lua_settable(ctx, -3); lua_pushinteger(ctx, 2); lua_pushinteger(ctx, 42); lua_settable(ctx, -3); lua_pushinteger(ctx, 3); lua_createtable(ctx, 3, 0); lua_pushinteger(ctx, 1); lua_pushinteger(ctx, 1); lua_settable(ctx, -3); lua_pushinteger(ctx, 2); lua_pushinteger(ctx, 2); lua_settable(ctx, -3); lua_pushinteger(ctx, 3); lua_pushinteger(ctx, 3); lua_settable(ctx, -3); lua_settable(ctx, -3); lua_call(ctx, 1, 0); Поскольку все значения должны быть привязаны к контексту, в данном случае на него приходится ссылаться явным образом. В остальном вполне очевидно, что array ассоциирует переданные значения с последовательными целочисленными индексами, начиная с 1. Это ещё одно из тех мест, где раскрываются выражения вызова и Valset. Метод records аналогичен, но принимает пары ключ-значение. В этом случае раскрытие вызовов уже было бы неправильным шагом. x.mt() = Table::records(ctx, \"__index\", xRead, \"__newindex\", xWrite, \"__gc\", xDestroy ); Эквивалентный кодlua_createtable(ctx, 0, 3); lua_pushstring(ctx, \"__index\"); lua_pushlightuserdata(ctx, reinterpret_cast<void*>(&xRead)); lua_pushcclosure(ctx, &wrapped_signature_1, 1); lua_settable(ctx, -3); lua_pushstring(ctx, \"__newindex\"); lua_pushlightuserdata(ctx, reinterpret_cast<void*>(&xWrite)); lua_pushcclosure(ctx, &wrapped_signature_2, 1); lua_settable(ctx, -3); lua_pushstring(ctx, \"__gc\"); lua_pushlightuserdata(ctx, reinterpret_cast<void*>(&xDestroy)); lua_pushcclosure(ctx, &wrapped_signature_3, 1); lua_settable(ctx, -3); lua_setmetatable(ctx, x); Пользовательские данные Поддержка пользовательских данных достаточно прямолинейна. После регистрации в этом качестве какого-либо типа он получает равные права с поддерживаемыми нативными значениями, за одним исключением: преобразование в нативный тип должно быть только явным, через метод cast, причём такое преобразование возвращает ссылку. Регистрация осуществляется в два этапа. Сначала при помощи макроса LUAPP_USERDATA мы связываем имя типа с его строковым идентификатором. Затем, во время настройки окружения, необходимо задать соответствующую данному типу метатаблицу. Это можно сделать, проиндексировав registry строкой-идентификатором, но выразительнее сделать специально предназначенным для этого способом: LUAPP_USERDATA(MyType, \"MyType Lua ID\") Retval setup(Context& ctx) { ctx.mt<MyType>() = Table::records(ctx); // То же самое, как если слева написать ctx.registry[\"MyType Lua ID\"] } При миграции в Lua пользовательским данным будет автоматически назначаться соответствующая метатаблица. Она же используется для проверки соответствия типов, поэтому если второй шаг пропустить, «туда» значения будут проезжать свободно, а вот обратно — их уже никто не признает без паспорта метатаблицы. Размещение пользовательских данных в Lua подразумевает, что память для хранения объекта Lua выделяет своими силами и отслеживает через сборщик мусора. Lua API++ использует placement new для корректного конструирования объекта в выделенной памяти, задействуя конструктор перемещения, если таковой имеется. Так что не обязательно ограничиваться POD-типами. Более того, можно даже задействовать динамический полиморфизм, зарегистрировав базовый тип и его потомков под одним и тем же строковым идентификатором. Механизм обёртывания функций позволяет справиться с передачей пользовательских данных по значению и по ссылке. Что особенно приятно, этот механизм работает на функциях-членах, в этом случае подразумевается, что первый аргумент всегда будет ссылкой на наш пользовательский тип. Посмотрим, как это всё работает на примере добавления в Lua числового массива фиксированного размера, проверяющего индексы: #include <vector> using dvec = std::vector<double>; // Используем вектор для хранения данных LUAPP_USERDATA(dvec, \"Number array\") // Связь типа со строковым идентификатором dvec aCreate(size_t size) // Создание массива заданного размера. { // Конструктор - специальная функция и его нельзя обернуть автоматически. return dvec(size); // Благодаря RVO и конструктору перемещения не произойдёт перевыделения хранилища } void aDestroy(dvec& self) // Деструктор - тоже специальная функция и его тоже нельзя обернуть. { self.~dvec(); } void aWrite(dvec& self, size_t index, double val) // Запись данных в массив в соответствии с порядком вызова __newindex { self.at(index) = val; // Для контроля доступа используем at, исключение преобразуется в ошибку Lua } Retval setup(Context& c) { // Настройка окружения c.mt<dvec>() = Table::records(c, // Метатаблица для нашего типа \"__index\", static_cast<double& (dvec::*)(size_t)> (&dvec::at), // Для чтения с контролем индекса используем родную функцию at // поскольку их две (const и не-const), явно выберем одну из перегрузок \"__newindex\", aWrite, \"__len\", dvec::size, // а вот size в vector один, тут совсем просто \"__gc\", aDestroy ); c.global[\"createArray\"] = aCreate; // Функция создания массива будет глобальной return c.ret(); } Заключение Когда я создавал эту библиотеку, то целью ставил создание удобного способа использования Lua без чрезмерных накладных расходов. Она является просто отображением Lua API на С++, без излишеств. В ней даже отсутствует поддержка некоторых возможностей Lua и Lua API (coroutine, string buffers, отладочных функций). Библиотека рассчитана на то, что её будут использовать вместо Lua API, поэтому по умолчанию она не подключает заголовочные файлы Lua. Большинство функций объявлено как inline, а все непосредственные обращения к Lua API вынесены в отдельный исходный файл, который надо компилировать вместе с библиотекой, желательно с использованием Link time code generation (LTO в GCC). Однако есть возможность переключить библиотеку в режим header-only. При этом все до единой функции окажутся объявленными в заголовках как inline и будут подключены заголовки Lua. Внешних зависимостей у библиотеки нет, ей нужны только совместимый со стандартом C++11 компилятор, заголовочные файлы Lua и STL. А вот тесты потребуют ещё Boost Unit Test Framework. По умолчанию библиотека рассчитана на Lua версии 5.2 (а после выхода 5.3 будет переориентирована на новую версию), но есть и режим совместимости с 5.1, полностью совместимый и с LuaJIT. Распространяется Lua API++ под лицензией MIT — та же самая, что у Lua, так что никакой юридической путаницы не возникнет. Библиотека укомплектована полной документацией в формате HTML, включая полный справочник и объяснение основных понятий. Надеюсь, что моя работа принесёт пользу кому-то из вас.", "image": [], "tag": ["Lua", "C++", "C++11"], "rating": ["+30"], "bookmarks": ["115"], "views": ["13,9k"], "comments_count": ["4"]},
{"author": ["starius"], "date": ["15 октября 2014 в 19:08"], "hubs": ["Lua", "Разработка веб-сайтов"], "type_label": [], "text": "Tl;dr Lapis(Lua) = RoR(Ruby) = Django(Python) Вступление Lua — мощный и быстрый скриптовый язык, который очень легко встраивается в C. Разработан в PUC-Rio (Бразилия). LuaJIT — это самая быстрая реализация Lua (JIT-компилятор), настоящее произведение искусства. По некоторым оценкам, имеет шестикратное преимущество перед стандартным интерпретатором Lua и во многих тестах побивает V8. Разработчик Mike Pall (Германия). А ещё LuaJIT может привязать функции и структуры C на стороне Lua (без написания привязок на C): local ffi = require(\"ffi\") ffi.cdef[[int printf(const char *fmt, ...);]] ffi.C.printf(\"Hello %s!\\n\", \"wiki\") Nginx — один из самых эффективных веб-серверов, разработанный Игорем Сысоевым. Многие крупные сайты используют Nginx. Начиная с версии 0.8 появилась возможность напрямую встраивать язык Lua. Lua исполняется в самом процессе Nginx, а не выносится в отдельный процесс, как это происходит в случае с другими языками. Код на Lua в контексте Nginx выполняется в неблокирующем режиме, включая запросы к БД и внешние HTTP-запросы, порожденные веб-приложением (например, запрос к API другого сайта). OpenResty — это сборка Nginx с множеством сторонних модулей, в том числе для неблокирующего доступа к популярным БД. Последние версии используют LuaJIT для исполнения Lua. Разработчик Yichun Zhang (США, место работы: CloudFlare, основной разработчик lua-nginx-module). Sailor MoonScript — это скриптовый язык, который транслируется в Lua. Добавляет синтаксический сахар, упрощает написание некоторых вещей, например списковых выражений; реализует классы с наследованием. Можно сказать, что MoonScript для Lua — это CoffeeScript для JavaScript. Разработчик Leaf Corcoran (США). Lapis — это веб-фрейморк для написания веб-приложений на Lua и MoonScript, который живёт внутри OpenResty. Разработчик Leaf Corcoran (США). Какое же преимущество дает Lua в Nginx? Tl;dr Все возможности языка высокого уровня и эффективное использование ресурсов при больших нагрузках Для ответа вернёмся в далёкое прошлое, когда все сайты обслуживались веб-сервером Apache. Задержки вносят красные узлы и ребра графа. Желтым закрашены компоненты, расположенные на одной машине. Аpache выделял отдельный поток операционной системы, который читал запрос, выполнял обработку и отправлял результат пользователю. (Современный Apache можно научить так не делать.) Получается, сколько активных запросов, столько и потоков ОС, а они стоят дорого. Бóльшая часть времени жизни потока при такой схеме расходуется не на обработку запроса, а на передачу данных по сети, лимитированную скоростью интернета у пользователя. Как с этим бороться? Надо поручить операционной системе следить за передачей данных, чтобы нашему веб-серверу работать только тогда, когда сеть выполнила очередную задачу. Такой подход называется неблокирующим вводом-выводом и реализуется в большинстве современных ОС. Веб-сервер Nginx использует эту возможность, за счёт чего может обслуживать десятки тысяч одновременных запросов, используя всего один поток ОС. Таким образом мы оптимизировали передачу данных между браузером и веб-сервером, но есть ещё одно узкое место, на котором простаивают потоки ОС: работа с базой данных и внешними ресурсами (например, HTTP-API другого сайта). Важно понять, что дело не столько в неизбежных задержках самой базы данных или внешнего API, а в том, что наше веб-приложение бездарно простаивает, пока не получит от них ответ. Обычное решение: уже в самом веб-приложении наплодить потоков, от которых мы так успешно избавились в веб-сервере. Эффективное решение: сделать так, чтобы веб-приложение и база данных общались неблокирующим способом. Веб-приложение направляет запрос в базу данных и сразу же переходит к следующему запросу от пользователя. База данных считает, возвращает результат, а веб-приложение, когда освободится, возвращается к обработке запроса от пользователя, породившего данный запрос к базе данных. Такой подход используется, например, в node.js: БД и внешние API по-прежнему закрашены красным, так как они могут вносить задержку. Преимущество подхода в том, что веб-приложение не просто так их ждёт, а обрабатывает в это время другие запросы. Замечательно! Теперь посмотрим, как происходит программирование внешних HTTP-запросов в node.js: var request = require(\"request\"); request.get(\"http://www.whatever.com/my.csv\", function (error, response, body) { if (!error && response.statusCode == 200) { console.log(\"Got body: \" + body); } }); Допустим, мы хотим скачать файл по URL и что-то с ним сделать. Результат приходится обрабатывать в лямбда-функции. Неудобно? Это неизбежная плата за асинхронность? К счастью, это не так; посмотрим аналогичный код в Lapis: local http = require(\"lapis.nginx.http\") local body, status_code, headers = http.simple(\"http://www.whatever.com/my.csv\") if status_code == 200 then print(body) end Код для Lapis писать удобно, как будто он синхронный, но за кулисами он исполняется полностью асинхронно. Это возможно благодаря активному использованию сопрограмм (coroutines, green threads, а в терминологии Lua просто threads). Весь код, обрабатывающий запрос от пользователя, исполняется в отдельной сопрограмме, а сопрограммы могут останавливаться и продолжаться в определенных местах. В нашем примере такое место было внутри вызова функции http.simple. Почему же сопрограммы эффективнее потоков ОС? Не перетащили ли мы все накладные расходы в приложение? На самом деле, ключевым отличием сопрограмм от потоков ОС является свобода программиста, в каком именно месте сопрограмма засыпает и просыпается. (В случае потоков ОС решение принимает ОС.) Начали запрос к БД — усыпили сопрограмму, породившую запрос. Пришёл ответ от БД — будим сопрограмму и продолжаем её исполнение. Выполняем одновременно много дел и всё в одном потоке ОС! Примечание. Похожий механизм вот-вот появится в node.js. Примечание. Советую прочитать замечательную статью про сопрограммы в контексте C++. В конце статьи получился асинхронный код, записываемый как синхронный, и всё благодаря сопрограммам. Жалко, что в C++ сопрограммы являются скорее хаком, чем общепринятым приёмом. Помимо этого, Lapis исполняется непосредственно в Nginx, что исключает накладные расходы на передачу информации между Nginx и веб-приложением. Конечно, node.js можно использовать как основной веб-сервер, без Nginx, но тогда пропадает возможность использовать разные возможности Nginx. С другой стороны, не каждый решится пустить код на Lua прямо в основной Nginx. В таком случае запускаем отдельный Nginx с Lua от имени отдельного пользователя с урезанными правами, а в основном Nginx прописываем прокси. Эффективность Lapis подтверждается в 10-гигабитном бенчмарке. Lapis занимает лидирующие места на уровне языков C++ и Java. Lapis 1 апреля 2014 года на Хабре была опубликована первоапрельская статья «LUA в nginx: лапшакод в стиле inline php». В статье рассматривался шуточный код, реализующий PHP-подобные шаблоны на Lua. В комментариях к той же статье упомянули о Lapis. Других упоминаний о Lapis на Хабре я не нашел, поэтому решил написать сам. Писать Hello World скучно. Давайте вместо этого напишем простенький веб-прокси на Lapis. Установка OpenResty Установите perl 5.6.1+, libreadline, libpcre и libssl и убедитесь, что доступна команда ldconfig (её родительская папка может отсутствовать в PATH). $ wget http://openresty.org/download/ngx_openresty-1.7.4.1.tar.gz $ tar xzvf ngx_openresty-1.7.4.1.tar.gz $ cd ngx_openresty-1.7.4.1/ $ ./configure $ make # make install Установка Lapis Сначала надо установить LuaRocks (есть в основных дистрибутивах). # luarocks install lapis Создаем веб-приложение Создаем костяк сайта: $ lapis new --lua wrote nginx.conf wrote mime.types wrote app.lua Если бы мы не передали опцию --lua, то был бы создан костяк на языке MoonScript. Теперь реализуем в app.lua логику нашего приложения: на главной странице сайта отображается форма для ввода URL. Форма отправляется на /geturl, где происходит загрузка страницы по указанному URL и передача содержимого в браузер пользователя. local lapis = require(\"lapis\") local app = lapis.Application() local http = require(\"lapis.nginx.http\") app:get(\"/\", function(self) return [[ <form method=\"POST\" action=\"/geturl\"> <input type=\"text\" value=\"http://ip4.me/\" name=\"url\" /> <input type=\"submit\" value=\"Get\" /> </form> ]] end) app:post(\"/geturl\", function(self) local url = self.req.params_post.url local body, status_code, headers = http.simple(url) return body end) return app Главная страница просто выдает HTML-код с формой. Двойные квадратные скобки — ещё одно обозначения для строк в Lua. Страница /geturl получает POST-запрос от формы, достает из него URL, вписанный пользователем в форму, скачивает содержимое по этому URL при помощи функции http.simple (поток ОС при этом не блокируется, см. выше) и показывает результат пользователю. Для работы http.simple нужно изменить nginx.conf: location / { set $_url \"\"; default_type text/html; content_by_lua ' require(\"lapis\").serve(\"app\") '; } location /proxy { internal; rewrite_by_lua ' local req = ngx.req for k,v in pairs(req.get_headers()) do if k ~= \"content-length\" then req.clear_header(k) end end if ngx.ctx.headers then for k,v in pairs(ngx.ctx.headers) do req.set_header(k, v) end end '; resolver 8.8.8.8; proxy_http_version 1.1; proxy_pass $_url; } Этот код создает в Nginx location /proxy, через который Lua совершает внешние запросы. В главный location нужно добавить set $_url \"\"; Подробнее об этом написано в документации. Запустим наш веб-прокси: $ lapis server Нажимаем на кнопку «Get». Сайт ip4.me показывает IP-адрес сервера, на котором запущен Lapis. Если в URL отсутствует path, то в качестве path используется /proxy. Видимо, это баг Lapis'а, по которому уже составлен отчёт. Заключение В Lapis, Lua и Nginx есть ещё много интересного, например, асинхронная работа с БД Postgres, классы-обертки для объектов БД, генерация HTML, мощный язык шаблонов etlua, кеширование переменных между разными процессами-рабочими Nginx, защита от CSRF, два инструмента для тестирования и интерактивная Lua-консоль прямо в браузере. Если статья найдёт читателя, я продолжу рассказ о Lapis в других статьях. Без сомнения, Lapis давно перерос уровень первоапрельской шутки и стремительно набирает позиции в сообществе веб-разработчиков. Желаю приятного изучения этих перспективных технологий! Ссылки документация по Lapis (меню спрятано слева, а сверху есть переключение между Lua и MoonScript) подборка хороших ссылок по Lua (проекты + учебники) документация по HttpLuaModule язык MoonScript мнения об использовании сопрограмм в Web: пессимистичное, оптимистичное исходные коды материалов статьи доступны на GitHub", "image": ["https://habrastorage.org/getpro/habr/post_images/ead/bc1/5b4/eadbc15b429ccd3a11e56f7098bd6381.png", "https://habrastorage.org/getpro/habr/post_images/119/914/8f2/1199148f2c93671a9e8d4818ab5e9a5f.png", "https://habrastorage.org/getpro/habr/post_images/717/6cd/6a2/7176cd6a2550abc85666113c803b6c36.gif", "https://habrastorage.org/getpro/habr/post_images/e66/6d3/5e2/e666d35e241c7f8475bd1151e2814f1d.png", "https://habrastorage.org/getpro/habr/post_images/e6b/d3a/1e3/e6bd3a1e3344a28cf3b6014ccb14cce2.png", "https://habrastorage.org/getpro/habr/post_images/73a/651/233/73a651233b6827e484f64e031a4d395b.png", "https://habrastorage.org/getpro/habr/post_images/3b1/684/bfb/3b1684bfb17cc03fa4aa76d99dcc412c.png", "https://habrastorage.org/getpro/habr/post_images/ead/bc1/5b4/eadbc15b429ccd3a11e56f7098bd6381.png", "https://habrastorage.org/getpro/habr/post_images/777/c3e/366/777c3e3664f5d1085af6d2178db913cc.png", "https://habrastorage.org/getpro/habr/post_images/219/c85/769/219c8576901227da0cda67f77ba5f307.png", "https://habrastorage.org/getpro/habr/post_images/b54/969/8b5/b549698b5d47814d46e616fd18bc49f5.png", "https://habrastorage.org/getpro/habr/post_images/130/131/587/1301315875a9c972e1b98be3f772db94.png", "https://habrastorage.org/getpro/habr/post_images/5ec/50c/a74/5ec50ca74893cc553edb0debbe07d278.png", "https://habrastorage.org/getpro/habr/post_images/907/5ba/5a3/9075ba5a34dbf4a00a0ff873b87db344.png", "https://habrastorage.org/getpro/habr/post_images/18f/ef6/057/18fef6057411f275b588190aa898173b.png", "https://habrastorage.org/getpro/habr/post_images/88d/018/bd1/88d018bd17e3c835e2db1d1b68903fb4.png"], "tag": ["lapis", "lua", "сайт на lua", "веб-разработка", "веб-сервер", "веб-приложение", "node.js", "nonblocking I/O", "asynchronous I/O", "nginx", "luajit", "openresty", "moonscript", "sailor moon", "green threads", "coroutines", "coro", "сопрограммы", "веб-прокси", "etlua"], "rating": ["+46"], "bookmarks": ["227"], "views": ["34,1k"], "comments_count": ["21"]},
{"author": ["yegorf1"], "date": [" 3 августа 2014 в 12:08"], "hubs": ["Lua", "Разработка игр"], "type_label": ["Tutorial"], "text": "Доброго времени суток. Начнем с того, что я не нашел на хабре туториалов по Cocos2d и Lua, поэтому мне пришлось много страдать и чтобы вы не повторяли моих ошибок я решил написать пост. В этой статье я расскажу как создать простую игру используя Сocos2d-x, Cocos Code IDE и Lua. Ранее, я уже писал про создание игр на Love2d. В этой статье я адаптирую старый туториал для кокоса и как это запустить на андроиде (Ни яблока, ни мака у меня нет). Что нам понадобится? Список важных вещей: Java JDK Сам Cocos2d-x. На момент выхода этой статьи вышел Cocos2d-x 3.2 и скачать его можно здесь. Нужно скачать той же разрядности, что и JDK IDE для lua. Разработчики движка постарались и выпустили свой IDE на основе Eclipse. Качаем здесь. [Windows-only]Python 2.7. Лежит вот тут. Если вы хотите писать игры под андроид, то придется скачать еще пару вещей, а именно: Android SDK. Если вы не собираетесь писать под андроид, то лучше найти вкладку «GET THE SDK FOR AN EXISTING IDE» Android NDK. Я использую Android NDK r9, а с r10 возможны проблемы Apache Ant. У меня стоит 1.9.4 Установка Сначала поставим Java JDK и Python. После распакуйте cocos2d-x и Cocos Code IDE (Если вы скачивали zip версию, если нет, просто запустите установку) в удобное для вас место. Распаковываем Android SDK, NDK и Apache Ant так же в удобное место. Путь к ним не должен содержать пробелов во избежание проблем. Открываем папку с SDK, находим SDK Manager. Запускаем и ставим нужные для нас версии API и всю папку Tools. Запускаем Cocos Code IDE. В Window->Preferences->Cocos указываем нужные пути. У меня это выглядит так: . Теперь кликаем по вкладке Lua которая находится во вкладке Cocos и выбираем путь к cocos2d-x: Настроено. Немного теории Cocos2d-x — кроссплатформенный движок, написанный на С++, был создан как копия Cocos2d. Cocos2d использует Object C и может использоваться только для iOS. Теперь поговорим о базовой механике движка и сравним ее с Love2D. У кокоса все объекты находятся в слоях, а слои находятся в сценах. В Love2D ни слоев, ни сцен нет. Плюсы сцен и слоев в том, что с их помощью можно создавать гибкое приложение более простыми способами. Минусы в том, что для просто игры это может быть слишком громоздко и неудобно. В кокосе все представленно объектами и чтобы что-то появилось на экране надо просто добавить это на сцену, а в love2d все представленно простыми переменными и чтобы что-то появилось на экране нужно это каждый кадр рисовать. Это можно описывать достаточно долго поэтому я скажу вывод сейчас, а разницу вы сможете почувствовать сами. Cocos2d-x — большой движок с большим количеством возможностей, однако доступ к ним часто сделан не так как хотелось бы. Love2d — простой, не требующий много знаний, движок с отзывчивым коммьюнити, но с отсутствием многих нужных вещей, которые впоследствии пишут сами пользователи, но делают это вполне удачно. А теперь сам код Создадим новый проект. И у нас будет два файла в исходниках: hello2.lua и main.lua. Если вы не хотите посмотреть на чудо китайского гейм дева, то первый можно сразу удалять, а второй очистить. Он создан для демонстрации возможностей require. Открываем main.lua и видим кучу кода которая нужна чтобы понять как использовать порт под lua. Чтобы увидеть, что это такое нажимаем F11. Можно поиграться. Вот это бегающие существо это собака, а не белка как вы могли подумать. Посмотрели, поигрались и хватит. Удалите hello2.lua и весь код в main.lua и очищаем папку res. В папку res добавляем картинку и называем ее habr.png. Теперь пишем в main следующий код: --Все классы кокоса require \"Cocos2d\" --Все константы кокоса require \"Cocos2dConstants\" -- Функция вывода сообщений cclog = function(...) print(string.format(...)) end -- Эта функция выводит ошибки function __G__TRACKBACK__(msg) cclog(\"\\n----------------------------------------\") cclog(\"LUA ERROR: \" .. tostring(msg)) cclog(debug.traceback()) cclog(\"----------------------------------------\") return msg end collectgarbage(\"collect\") -- Предотвращает утечку памяти collectgarbage(\"setpause\", 100) collectgarbage(\"setstepmul\", 5000) --Теперь можно использовать файлы которые лежат в папках \"src\" и \"res\" cc.FileUtils:getInstance():addSearchResolutionsOrder(\"src\"); cc.FileUtils:getInstance():addSearchResolutionsOrder(\"res\"); --Записываем в константы ширину и высоту экрана SCREEN_WIDTH = cc.Director:getInstance():getWinSize().width SCREEN_HEIGHT = cc.Director:getInstance():getWinSize().height local function main() print(\"Resolution: \" .. SCREEN_WIDTH .. \"x\" .. SCREEN_HEIGHT) --Запускаем главную сцену require \"mainScene.lua\" end --Вызываем функцию main local status, msg = xpcall(main, __G__TRACKBACK__) if not status then error(msg) end В функции main мы вызываем файл mainScene.lua. В нем находится главная сцена игры. Создадим его и напишем туда следующий код: -- Константы local NONE = 0 local ROTATION = 1 local SCALLING = 2 local MOVING = 3 -- Переменные local state, rotation, scale, ox, oy, delta, habrImage, moving -- Эта функция будет вызываться когда палец касается экрана local function onTouchBegan(touch, event) -- Включаем следующие состояние state = (state + 1) % 4 -- И возвращаем переменные к дефолту resetVariables() end -- Эта функция вызывается постоянно, а в dt хранится время с -- прошлого вызова. Если dt == 1.0, то с прошлого вызова прошла -- одна секунда local function update(dt) if state == ROTATION then --крутим картинку rotation = rotation + delta * dt elseif state == SCALLING then --увеличиваем scale = scale + dt * delta elseif state == MOVING then --Здесь немного посложнее, но все же просто: --Каждый раз мы увеличивыем переменную moving, а --потом берем ее за угол для косинису и синуса --и крутим картинку по кругу moving = moving + delta * dt local radius = 50 ox = radius * math.sin(moving) oy = radius * math.cos(moving) end -- В love2d мы использовали эти параметры при рисовании -- Здесь у нас спрайт и нам нужно постоянно менять ему -- все вручную -- Меняем размер habrImage:setScale(scale) -- Меняем угол habrImage:setRotation(rotation) -- Меняем позицию habrImage:setPosition(cc.p(SCREEN_WIDTH / 2 + ox, SCREEN_HEIGHT / 2 + oy)) end local function init() print(\"Creating main scene\") -- Создаем сцену local mainScene = cc.Scene:create() -- Создаем слой с фоновым цветом -- Здесь я бы хотел поставить паузу и рассказать более подробно -- потому что у меня ушло 2 часа чтобы узнать как мне изменить цвет -- фона. 1) В C++ нет функции cc.c4b(r,g,b,a) поэтому мне пришлось -- догадаться, что нужно смотреть не на C++ таких случаях, а на -- cocos2d-x-js, т.к. он более популярен чем cocos2d-x-lua -- и если вы не можете найти нужную функцию в C++, то ищите ее в -- JavaScript версии, однако это не поможет с евентами local gameLayer = cc.LayerColor:create(cc.c4b(255, 255, 255, 255)) -- Создаем спрайт habrImage = cc.Sprite:create(\"res/habr.png\") --Ставим его смещение по центру habrImage:setAnchorPoint(0.5, 0.5) --Ставим позицию на центр экрана habrImage:setPosition(cc.p(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2)) --Добавляем его к слою gameLayer:addChild(habrImage) state = 0 resetVariables() -- Чтобы функция update вызывалась нужно сообщить кокосу, что ее нужно -- вызывать cc.Director:getInstance():getScheduler():scheduleScriptFunc(update, 0, false) -- Создаем лисениры для событий. Хочу обратить внимание, что для каждого -- типа событий есть свой лисенер. local listener = cc.EventListenerTouchOneByOne:create() -- Говорим лисениру, что такой то тип событий связвн с такой то функцией listener:registerScriptHandler(onTouchBegan, cc.Handler.EVENT_TOUCH_BEGAN ) -- Добавляем лисенер к слою local eventDispatcher = gameLayer:getEventDispatcher() eventDispatcher:addEventListenerWithSceneGraphPriority(listener, gameLayer) --Добавляем слой к сцене mainScene:addChild(gameLayer) --Запускаем или если уже что-либо запущено заменяем сцену if cc.Director:getInstance():getRunningScene() then cc.Director:getInstance():replaceScene(mainScene) else cc.Director:getInstance():runWithScene(mainScene) end end function resetVariables() rotation = 0 scale = 1 ox = 0 oy = 0 delta = 20 moving = 0 end --Запускаем сцену init() Теперь немного о помощи с поиском ответов. Во-первых: Порт на луа практически идентичен С++ и основные отличия можно прочесть здесь. Во-вторых: как я ранее писал, если вы не можете найти что-либо в порте С++, то попробуйте поискать эту проблему для JS движка. Он более популярен чем луа, однако в нем есть множество отличий, но очень часто он мне помогал. Чтобы запустить то, что у нас вышло нажмите F11. Чтобы запустить на андроид нажмите на кнопку «Debug configurations» и выберите андроид. Для запуска нужен настроенный adb, но про это и так много статей, поэтому я не буду писать здесь об этом. На этом все Спасибо за прочтение (: Вот что вышло в итоге:", "image": ["https://habrastorage.org/files/ff1/c90/0b1/ff1c900b14d54dffbda58961032a9854.jpg", "https://habrastorage.org/files/9a0/68b/ce0/9a068bce05944c098145844cc4310dd3.PNG", "https://habrastorage.org/files/157/7e8/794/1577e879478349a7a8bc938ef77fff57.PNG", "https://habrastorage.org/files/789/195/51d/78919551dbb64a36bbb11cff10183616.PNG"], "tag": ["Lua", "cocos2d", "cocos2d-x", "gamedev", "game development"], "rating": ["+28"], "bookmarks": ["138"], "views": ["31,3k"], "comments_count": ["16"]},
{"author": ["eliasdaler"], "date": ["20 сентября 2014 в 19:11"], "hubs": ["Lua", "Разработка игр", "C++"], "type_label": ["Tutorial"], "text": "Данная статья — перевод моего туториала, который я изначально писал на английском. Однако этот перевод содержит дополнения и улучшения по сравнению с оригиналом. Туториал не требует знания Lua, а вот C++ нужно знать на уровне чуть выше базового, но сложного кода здесь нет. Когда-то я написал статью про использование Lua с C++ с помощью Lua C API. В то время, как написать простой враппер для Lua, поддерживающий простые переменные и функции, не составляет особого труда, написать враппер, который будет поддерживать более сложные вещи (функции, классы, исключения, пространства имён), уже затруднительно. Врапперов для использования Lua и C++ написано довольно много. С многими из них можно ознакомиться здесь. Я протестировал многие из них, и больше всего мне понравился LuaBridge. В LuaBridge есть многое: удобный интерфейс, exceptions, namespaces и ещё много всего. Но начнём по порядку, зачем вообще использовать Lua c С++? Зачем использовать Lua? Конфигурационные файлы. Избавление от констант, магических чисел и некоторых define'ов Данные вещи можно делать и с помощью простых текстовых файлов, но они не так удобны в обращении. Lua позволяет использовать таблицы, математические выражения, комментарии, условия, системные функции и пр. Для конфигурационных файлов это бывает очень полезно. Например, можно хранить данные в таком виде: window = { title = \"Test project\", width = 800, height = 600 } Можно получать системные переменные: homeDir = os.getenv(\"HOME\") Можно использовать математические выражения для задания параметров: someVariable = 2 * math.pi Скрипты, плагины, расширение функциональности программы C++ может вызывать функции Lua, а Lua может вызывать функции C++. Это очень мощный функционал, позволяющий вынести часть кода в скрипты или позволить пользователям писать собственные функции, расширяющие функциональность программы. Я использую функции Lua для различных триггеров в игре, которую я разрабатываю. Это позволяет мне добавлять новые триггеры без рекомпиляции и создания новых функций и классов в C++. Очень удобно. Немного о Lua. Lua — язык с лицензией MIT, которая позволяет использовать его как в некоммерческих, так и в коммерческих приложениях. Lua написан на C, поэтому Lua работает на большинстве ОС, что позволяет использовать Lua в кросс-платформенных приложениях без проблем. Установка Lua и LuaBridge Итак, приступим. Для начала скачайте Lua и LuaBridge Добавьте include папку Lua и сам LuaBridge в Include Directories вашего проекта Также добавьте lua52.lib в список библиотек для линковки. Создайте файл script.lua со следующим содержанием: -- script.lua testString = \"LuaBridge works!\" number = 42 Добавьте main.cpp (этот код лишь для проверки того, что всё работает, объяснение будет чуть ниже): // main.cpp #include <LuaBridge.h> #include <iostream> extern \"C\" { # include \"lua.h\" # include \"lauxlib.h\" # include \"lualib.h\" } using namespace luabridge; int main() { lua_State* L = luaL_newstate(); luaL_dofile(L, \"script.lua\"); luaL_openlibs(L); lua_pcall(L, 0, 0, 0); LuaRef s = getGlobal(L, \"testString\"); LuaRef n = getGlobal(L, \"number\"); std::string luaString = s.cast<std::string>(); int answer = n.cast<int>(); std::cout << luaString << std::endl; std::cout << \"And here's our number:\" << answer << std::endl; } Скомпилируйте и запустите программу. Вы должны увидеть следующее: LuaBridge works! And here's our number:42 Примечание: если программа не компилируется и компилятор жалуется на ошибку “error C2065: ‘lua_State’: undeclared identifier” в файле LuaHelpers.h, то вам нужно сделать следующее: 1) Добавьте эти строки в начало файла LuaHelpers.h extern \"C\" { # include \"lua.h\" # include \"lauxlib.h\" # include \"lualib.h\" } 2) Измените 460ую строку Stack.h с этого: lua_pushstring (L, str.c_str(), str.size()); На это: lua_pushlstring (L, str.c_str(), str.size()); Готово! А теперь подробнее о том, как работает код. Включаем все необходимые хэдеры: #include <LuaBridge.h> #include <iostream> extern \"C\" { # include \"lua.h\" # include \"lauxlib.h\" # include \"lualib.h\" } Все функции и классы LuaBridge помещены в namespace luabridge, и чтобы не писать «luabridge» множество раз, я использую эту конструкцию (хотя её лучше помещать в те места, где используется сам LuaBridge) using namespace luabridge; Создаём lua_State lua_State* L = luaL_newstate(); Открываем наш скрипт. Для каждого скрипта не нужно создавать новый lua_State, можно использовать один lua_State для множества скриптов. При этом нужно учитывать коллизию переменных в глобальном нэймспейсе. Если в script1.lua и script2.lua будут объявлены переменные с одинаковыми именами, то могут возникнуть проблемы luaL_dofile(L, \"script.lua\"); Открываем основные библиотеки Lua(io, math, etc.) и вызываем основную часть скрипта (т.е. если в скрипте были прописаны действия в глобальном нэймспейсе, то они будут выполнены) luaL_openlibs(L); lua_pcall(L, 0, 0, 0); Создаём объект LuaRef, который может хранить себе всё, что может хранить переменная Lua: int, float, bool, string, table и т.д. LuaRef s = getGlobal(L, \"testString\"); LuaRef n = getGlobal(L, \"number\"); Преобразовать LuaRef в типы C++ легко: std::string luaString = s.cast<std::string>(); int answer = n.cast<int>(); Проверка и исправление ошибок Но некоторые вещи могут пойти не так, и стоит производить проверку и обработку ошибок. Рассмотрим наиболее важные и часто встречающиеся ошибки Что, если скрипт Lua не найден? if (luaL_loadfile(L, filename.c_str()) || lua_pcall(L, 0, 0, 0)) { ... // скрипт не найден } Что, если переменная не найдена? Переменная может быть не объявлена, либо её значение — nil. Это легко проверить с помощью функции isNil() if (s.isNil()) { std::cout << \"Variable not found!\" << std::endl; } Переменная не того типа, который мы ожидаем получить Например, ожидается, что переменная имет тип string, тогда можно сделать такую проверку перед тем как делать каст: if(s.isString()) { luaString = s.cast<std::string>(); } Таблицы Таблицы — это не просто массивы: таблицы — замечательная структура данных, которая позволяет хранить в них переменные Lua любого типа, другие таблицы и ставить ключи разных типов в соответствие значениям и переменным. Таблицы позволяют представлять и получать конфигурационные файлы в красивом и легкочитаемом виде. Создайте script.lua с таким содержанием: window = { title = \"Window v.0.1\", width = 400, height = 500 } Код на C++, позволяющий получить данные из этого скрипта: LuaRef t = getGlobal(L, \"window\"); LuaRef title = t[\"title\"]; LuaRef w = t[\"width\"]; LuaRef h = t[\"height\"]; std::string titleString = title.cast<std::string>(); int width = w.cast<int>(); int height = h.cast<int>(); std::cout << titleString << std::endl; std::cout << \"width = \" << width << std::endl; std::cout << \"height = \" << height << std::endl; Вы должны увидеть на экране следующее: Window v.0.1 width = 400 height = 500 Как видите, можно получать различные элементы таблицы, используя оператор []. Можно писать короче: int width = t[\"width\"].cast<int>(); Можно также изменять содержимое таблицы: t[\"width\"] = 300 Это не меняет значение в скрипте, а лишь значение, которое содержится в ходе выполнения программы. Т.е. происходит следующее: int width = t[\"width\"].cast<int>(); // 400 t[\"width\"] = 300 width = t[\"width\"].cast<int>(); // 300 Чтобы сохранить значение, нужно воспользоваться сериализацией таблиц(table serialization), но данный туториал не об этом. Пусть теперь таблица выглядит так: window = { title = \"Window v.0.1\", size = { w = 400, h = 500 } } Как можно получить значение window.size.w? Вот так: LuaRef t = getGlobal(L, \"window\"); LuaRef size = t[\"size\"]; LuaRef w = size[\"w\"]; int width = w.cast<int>(); Функции Давайте напишем простую функции на C++ void printMessage(const std::string& s) { std::cout << s << std::endl; } И напишем вот это в скрипте на Lua: printMessage(\"You can call C++ functions from Lua!\") Затем мы регистрируем функцию в C++ getGlobalNamespace(L). addFunction(\"printMessage\", printMessage); Примечание 1: это нужно делать до вызова «luaL_dofile», иначе Lua попытается вызвать необъявленную функцию Примечание 2: Функции на C++ и Lua могут иметь разные имена Данный код зарегистрировал функцию в глобальном namespace Lua. Чтобы зарегистрировать его, например, в namespace «game», нужно написать следующий код: getGlobalNamespace(L). beginNamespace(\"game\") .addFunction(\"printMessage\", printMessage) .endNamespace(); Тогда функцию printMessage в скриптах нужно будет вызывать данным образом: game.printMessage(\"You can call C++ functions from Lua!\") Пространства имён в Lua не имеют ничего общего с пространствами имён C++. Они скорее используются для логического объединения и удобства. Теперь вызовем функцию Lua из C++ -- script.lua sumNumbers = function(a,b) printMessage(\"You can still call C++ functions from Lua functions!\") return a + b end // main.cpp LuaRef sumNumbers = getGlobal(L, \"sumNumbers\"); int result = sumNumbers(5, 4); std::cout << \"Result:\" << result << std::endl; Вы должны увидеть следующее: You can still call C++ functions from Lua functions! Result:9 Разве не замечательно? Не нужно указывать LuaBridge сколько и каких аргументов у функции, и какие значения она возвращает. Но есть одно ограничение: у одной функции Lua не может быть более 8 аргументов. Но это ограничение легко обойти, передав таблицу, как аргумент. Если вы передаёте в функцию больше аргументов, чем требуется, LuaBridge молча проигнорирует их. Однако, если что-то пойдёт не так, то LuaBridge сгенерирует исключение LuaException. Не забудьте словить его! Поэтому рекомендуется окружать код блоками try/catch Вот полный код примера с функциями: -- script.lua printMessage(\"You can call C++ functions from Lua!\") sumNumbers = function(a,b) printMessage(\"You can still call C++ functions from Lua functions!\") return a + b end // main.cpp #include <LuaBridge.h> #include <iostream> extern \"C\" { # include \"lua.h\" # include \"lauxlib.h\" # include \"lualib.h\" } using namespace luabridge; void printMessage(const std::string& s) { std::cout << s << std::endl; } int main() { lua_State* L = luaL_newstate(); luaL_openlibs(L); getGlobalNamespace(L).addFunction(\"printMessage\", printMessage); luaL_dofile(L, \"script.lua\"); lua_pcall(L, 0, 0, 0); LuaRef sumNumbers = getGlobal(L, \"sumNumbers\"); int result = sumNumbers(5, 4); std::cout << \"Result:\" << result << std::endl; system(\"pause\"); } Что? Есть ещё что-то? Да. Есть ещё несколько замечательных вещей, о которых я напишу в последующих частях туториала: классы, создание объектов, срок жизни объектов… Много всего! Также рекомендую прочитать этот dev log, в котором я рассказал о том, как использую скрипты в своей игре, практические примеры всегда полезны.", "image": [], "tag": ["с++", "lua", "luabridge", "gamedev", "скрипты", "биндинг", "разработка игр"], "rating": ["+41"], "bookmarks": ["263"], "views": ["38,1k"], "comments_count": ["24"]},
{"author": ["Pugnator"], "date": [" 3 октября 2014 в 10:30"], "hubs": ["Lua", "C"], "type_label": [], "text": "Есть у меня несколько проектов-долгостроев, один из которых — создание компьютера на базе CDP1802. Основную плату моделировал на бумаге и в Proteus. Довольно скоро встал ребром вопрос: как быть с элементами, которые отсутствуют в Proteus? На многих ресурсах подробно описано, как создать свою модель на С++ в Visual Studio. К сожалению, при сборке под линуксом этот вариант не очень удобен. Да и как быть, если не знаешь С++ или нужно редактировать модель на лету для отладки? Да и просто хочется сосредоточиться на моделировании, максимально упростив все остальное. Так появилась идея делать симуляторные модели с помощью скриптов — на Lua. Заинтересовавшихся прошу под кат (гифки на 2Мб). Зачем это надо Если забыть про всякую экзотику, вроде написания модели процессора, я давно отвык что-либо делать в симуляторе — подключил датчики к отладкам разного вида, осциллограф в руки, мультиметр, JTAG/UART и отлаживай себе. Но когда понадобилось проверить логику работы программы при отказе GPS/в движении и тому подобном, пришлось писать эмуляцию GPS на другом микроконтроллере. Когда было необходимо сделать телеметрию для машину под протокол KWP2000, отлаживать «на живую» было неудобно и опасно. Да и если одному — ой как неудобно. Возможность отлаживать/тестировать в дороге или где-то, куда таскать с собой весь джентльменский набор просто неудобно (речь в первую очередь про хобби проекты) — хорошее подспорье, так что место симулятору есть. Visual Studio C++ и GCC Весь софт я пишу под GCC и модель я хотел так же собирать под ним, используя наработанные библиотеки и код, которые собрать под MSVS было бы затруднительно. Проблема заключалась в том, что собранная под mingw32 DLL вешала Proteus. Были перепробованы разные способы включая манипуляции с __thiscall и сотоварищи, а варианты с ассемблерными хаками вызовов не устраивал. Друг moonglow с огромным опытом в таких делах предложил и показал как переписать С++ интерфейс на С, используя виртуальные таблицы. Из удобств, кроме возможности сборки под линуксом «без отрыва от производства», возможность, в теории, писать модели хоть на фортране — было бы желание. Мимикрируем под С++ Идея с «эмуляцией» виртуальных классов на практике выглядит так: Оригинальный С++ заголовок виртуального класса выглядит так class IDSIMMODEL { public: virtual INT isdigital ( CHAR* pinname ) = 0; virtual VOID setup ( IINSTANCE* instance, IDSIMCKT* dsim ) = 0; virtual VOID runctrl ( RUNMODES mode ) = 0; virtual VOID actuate ( REALTIME time, ACTIVESTATE newstate ) = 0; virtual BOOL indicate ( REALTIME time, ACTIVEDATA* newstate ) = 0; virtual VOID simulate ( ABSTIME time, DSIMMODES mode ) = 0; virtual VOID callback ( ABSTIME time, EVENTID eventid ) = 0; }; А вот версия на С; это наш псевдо-класс и его виртуальная таблица struct IDSIMMODEL { IDSIMMODEL_vtable* vtable; }; Теперь создаем структуру с указателями на функции, которые внутри класса (их мы создадим и объявим отдельно) struct IDSIMMODEL_vtable { int32_t __attribute__ ( ( fastcall ) ) ( *isdigital ) ( IDSIMMODEL* this, EDX, CHAR* pinname ); void __attribute__ ( ( fastcall ) ) ( *setup ) ( IDSIMMODEL* this, EDX, IINSTANCE* inst, IDSIMCKT* dsim ); void __attribute__ ( ( fastcall ) ) ( *runctrl ) ( IDSIMMODEL* this, EDX, RUNMODES mode ); void __attribute__ ( ( fastcall ) ) ( *actuate ) ( IDSIMMODEL* this, EDX, REALTIME atime, ACTIVESTATE newstate ); bool __attribute__ ( ( fastcall ) ) ( *indicate ) ( IDSIMMODEL* this, EDX, REALTIME atime, ACTIVEDATA* data ); void __attribute__ ( ( fastcall ) ) ( *simulate ) ( IDSIMMODEL* this, EDX, ABSTIME atime, DSIMMODES mode ); void __attribute__ ( ( fastcall ) ) ( *callback ) ( IDSIMMODEL* this, EDX, ABSTIME atime, EVENTID eventid ); }; Пишем нужные функции и создаем один экземпляр нашего «класса», который и будем использовать IDSIMMODEL_vtable VSM_DEVICE_vtable = { .isdigital = vsm_isdigital, .setup = vsm_setup, .runctrl = vsm_runctrl, .actuate = vsm_actuate, .indicate = vsm_indicate, .simulate = vsm_simulate, .callback = vsm_callback, }; IDSIMMODEL VSM_DEVICE = { .vtable = &VSM_DEVICE_vtable, }; И так далее, со всеми нужными нам классами. Так как вызывать такое из структур не очень удобно, были написаны функции-обертки, какие-то вещи были автоматизированы, были добавлены отсутствующие, часто используемые функции. Даже в процессе написания этой статьи я добавил много нового, посмотрев на работу с другой стороны. «Сделай настолько просто, насколько это возможно, но не проще» В итоге код рос и все более нарастало ощущение, что нужно что-то менять: на создание модели уходило сил и времени не меньше, чем на написания такого же эмулятора для микроконтроллера. В процессе отладки моделей требовалось постоянно что-то менять, экспериментировать. Приходилось пересобирать модель на каждой мелочи, да и работа с текстовыми данными в С оставляет желать лучшего. Знакомые, которым такое тоже было бы интересно, пугались С (кто-то использует ТурбоПаскаль, кто-то QBasic). Вспомнил о Lua: прекрасно интегрируется в С, быстр, компактен, нагляден, динамическая типизация — все что надо. В итоге продублировал все С функции в Lua с теми же названиями, получив полностью самодостаточный способ создания моделей, не требующий пересборки вообще. Можно просто взять dll и описать любую модель только на Lua. Достаточно остановить симуляцию, подправить текстовый скрипт, и снова в бой. Моделирование в Lua Основное тестирование велось в Proteus 7, но созданные с нуля и импортированные в 8-ю версию модели вели себя превосходно. Создадим несколько простейших моделей и на их примере посмотрим, что и как мы можем сделать. Я не буду описывать, как создать собственно графическую модель, это отлично описано тут и тут, поэтому остановлюсь именно на написании кода. Вот 3 устройства, которые мы будем рассматривать. Я хотел сначала начать с мигания светодиодом, но потом решил, что это слишком уныло, надеюсь, не прогадал. Начнем с A_COUNTER: Это простейший двоичный счетчик с внутренним генератором тактов, все его выводы — выходы. У каждой модели есть DLL, которая описывает поведение модели и взаимодействие с внешним миром. В нашем случае, у всех моделей dll будет одна и та же, а вот скрипты — разные. Итак, создаем модель: Описание модели device_pins = { {is_digital=true, name = \"A0\", on_time=100000, off_time=100000}, {is_digital=true, name = \"A1\", on_time=100000, off_time=100000}, {is_digital=true, name = \"A2\", on_time=100000, off_time=100000}, {is_digital=true, name = \"A3\", on_time=100000, off_time=100000}, --тут пропущены однотипные определения для остальных выводов --чтобы не прятать под кат {is_digital=true, name = \"A15\", on_time=100000, off_time=100000}, } device_pins это обязательная глобальная переменная, содержащая описание выводов устройства. На данном этапе библиотека поддерживает только цифровые устройства. Поддержка аналоговых и смешанных типов в процессе. is_digital — наш вывод работает только с логическими уровнями, пока возможен только true name — имя вывода на графической модели. Он должен точно соответствоват — привязка вывода внутри Proteus идет по имени. Два оставшихся поля говорят сами за себя — время переключения пина в пикосекундах. Необходимые функции, объявляемые пользователем На самом деле, нет строгой необходимости создавать что-то в скрипте. Можно вообще ничего не писать — будет модель пустышка, но для минимального функционала нужно создать функцию device_simulate. Эта функция будет вызываться, когда изменится состояние нод (проводников), например, изменится логический уровень. Есть функция device_init. она вызывается (если существует) однократно сразу после загрузки модели. Для установки состояния вывода в один из уровней есть функция set_pin_state, первым аргументом она принимает имя вывода, вторым — желаемое состояние, например, SHI, SLO, FLT и так далее Для начала сделаем так, чтобы на запуске все выводы находились в логическом 0, с помощью однострочника/ Мы можем обращаться к выводу как через глобальную переменную, к примеру, A0, Так и через её имя как строковую константу «А0» через глобальную таблицу окружения _G function device_init() for k, v in pairs(device_pins) do set_pin_state(_G[v.name], SLO) end end Теперь нам нужно реализовать сам счетчик; Начнем с задающего генератора. Для этого есть функция timer_callback, принимающую два аргумента — время и номер события. Добавим в device_init после выставления состояние вывода следующий вызов: set_callback(NOW, PC_EVENT) PC_EVENT это числовая переменная, содержащая код события (её мы должны объявить глобально) NOW означает что вызвать обработчик события нужно через 0 пикосекунд от текущего времени (функция принимает как аргумент пикосекунды) А вот и функция обработчик function timer_callback(time, eventid) if eventid == PC_EVENT then for k, v in pairs(device_pins) do set_pin_bool(_G[v.name], get_bit(COUNTER, k) ) end COUNTER = COUNTER + 1 set_callback(time + 100 * MSEC, PC_EVENT) end end По событию вызывается функция set_pin_bool, которая управляет выводом принимая как аргумент одно из двух состояний — 1/0. Можно заметить, что после переключения вывода снова вызывается set_callback, ибо эта функция планирует непериодические события. Разница в задании времени из-за того, что set_callback будет вызвана в будущем, поэтому нам нужно добавить разницу во времени, а time как раз содержит текущее системное время Итого, вот что вышлоdevice_pins = { {is_digital=true, name = \"A0\", on_time=100000, off_time=100000}, {is_digital=true, name = \"A1\", on_time=100000, off_time=100000}, {is_digital=true, name = \"A2\", on_time=100000, off_time=100000}, {is_digital=true, name = \"A3\", on_time=100000, off_time=100000}, {is_digital=true, name = \"A4\", on_time=100000, off_time=100000}, {is_digital=true, name = \"A5\", on_time=100000, off_time=100000}, {is_digital=true, name = \"A6\", on_time=100000, off_time=100000}, {is_digital=true, name = \"A7\", on_time=100000, off_time=100000}, {is_digital=true, name = \"A8\", on_time=100000, off_time=100000}, {is_digital=true, name = \"A9\", on_time=100000, off_time=100000}, {is_digital=true, name = \"A10\", on_time=100000, off_time=100000}, {is_digital=true, name = \"A11\", on_time=100000, off_time=100000}, {is_digital=true, name = \"A12\", on_time=100000, off_time=100000}, {is_digital=true, name = \"A13\", on_time=100000, off_time=100000}, {is_digital=true, name = \"A14\", on_time=100000, off_time=100000}, {is_digital=true, name = \"A15\", on_time=100000, off_time=100000}, } PC_EVENT = 0 COUNTER = 0 function device_init() for k, v in pairs(device_pins) do set_pin_state(_G[v.name], SLO) end set_callback(0, PC_EVENT) end function timer_callback(time, eventid) if eventid == PC_EVENT then for k, v in pairs(device_pins) do set_pin_bool(_G[v.name], get_bit(COUNTER, k) ) end COUNTER = COUNTER + 1 set_callback(time + 100 * MSEC, PC_EVENT) end end Все остальное — объявление, инициализация модели и так далее делается на стороне библиотеки. Хотя разумеется, все то же самое можно сделать на С, а Lua использовать для прототипирования, благо названия функций идентичны. Запускаем симуляцию и наблюдаем работу нашей модели Возможности отладки Основной целью было облегчение написания моделей и их отладки, поэтому рассмотрим некоторые возможности вывода полезной информации Текстовые сообщения 4 функции для вывода в лог сообщений, причем две последнии автоматически приведут к остановку симуляции out_log(\"This is just a message\") out_warning(\"This is warning\") out_error(\"This is error\") out_fatal(\"This is fatal error\") Благодаря возможностям Lua легко, удобно, быстро и наглядно можно выводить любую нужную информацию: out_log(\"We have \"..#device_pins..\" pins in our device\") Теперь перейдем ко второй нашей модели — микросхемы ПЗУ, и посмотрим на Всплывающие окна Смоделируем нашу ПЗУ и подебажим её во время работы. Объявления выводов тут ничем не отличается, но нам нужно добавить свойств нашей микросхеме, в первую очередь — возможность загрузить дамп памяти из файла: Делается это в текстовом скрипте при создании модели: {FILE=«Image File»,FILENAME,FALSE,,Image/*.BIN} Теперь сделаем так, что при постановке на паузу симуляции можно было посмотреть важную информацию о модели, такую как содержимое её памяти, содержимое адресной шины, шины данных, время работы. Для вывода бинарных данных в удобной форме есть memory_popup. function device_init() local romfile = get_string_param(\"file\") rom = read_file(romfile) mempop, memid = create_memory_popup(\"My ROM dump\") set_memory_popup(mempop, rom, string.len(rom)) end function on_suspend() if nil == debugpop then debugpop, debugid = create_debug_popup(\"My ROM vars\") print_to_debug_popup(debugpop, string.format(\"Address: %.4X\\nData: %.4X\\n\", ADDRESS, string.byte(rom, ADDRESS))) dump_to_debug_popup(debugpop, rom, 32, 0x1000) elseif debugpop then print_to_debug_popup(debugpop, string.format(\"Address: %.4X\\nData: %.4X\\n\", ADDRESS, string.byte(rom, ADDRESS))) dump_to_debug_popup(debugpop, rom, 32, 0x1000) end end Функция on_suspend вызывается (если объявлена пользователем) во время постановки на паузу. Если окно не создано — создадим его. Память передается в библиотеку как указатель, ничего высвобождать потом не нужно — все сделает сборщик мусора Lua. И создадим окно debug типа, куда выведем нужны нам переменные и для масовки сдампим 32 байта со смещения 0x1000: Наконец, реализуем сам алгоритм работу ПЗУ, оставив без внимания OE, VPP и прочие CE выводы function device_simulate() for i = 0, 14 do if 1 == get_pin_bool(_G[\"A\"..i]) then ADDRESS = set_bit(ADDRESS, i) else ADDRESS = clear_bit(ADDRESS, i) end end for i = 0, 7 do set_pin_bool(_G[\"D\"..i], get_bit(string.byte(rom, ADDRESS), i)) end end Сделаем что-нибудь для нашего «отладчика»: создадим программный UART, в который будем выводить содержимое шины данныхdevice_pins = { {is_digital=true, name = \"D0\", on_time=1000, off_time=1000}, {is_digital=true, name = \"D1\", on_time=1000, off_time=1000}, {is_digital=true, name = \"D2\", on_time=1000, off_time=1000}, {is_digital=true, name = \"D3\", on_time=1000, off_time=1000}, {is_digital=true, name = \"D4\", on_time=1000, off_time=1000}, {is_digital=true, name = \"D5\", on_time=1000, off_time=1000}, {is_digital=true, name = \"D6\", on_time=1000, off_time=1000}, {is_digital=true, name = \"D7\", on_time=1000, off_time=1000}, {is_digital=true, name = \"TX\", on_time=1000, off_time=1000}, } -- UART events UART_STOP = 0 UART_START = 1 UART_DATA=2 -- Constants BAUD=9600 BAUDCLK = SEC/BAUD BIT_COUNTER = 0 ----------------------------------------------------------------- DATA_BUS = 0 function device_init() end function device_simulate() for i = 0, 7 do if 1 == get_pin_bool(_G[\"D\"..i]) then DATA_BUS = set_bit(DATA_BUS, i) else DATA_BUS = clear_bit(DATA_BUS, i) end end uart_send(string.format(\"[%d] Fetched opcode %.2X\\r\\n\", systime(), DATA_BUS)) end function timer_callback(time, eventid) uart_callback(time, eventid) end function uart_send (string) uart_text = string char_count = 1 set_pin_state(TX, SHI) -- set TX to 1 in order to have edge transition set_callback(BAUDCLK, UART_START) --schedule start end function uart_callback (time, event) if event == UART_START then next_char = string.byte(uart_text, char_count) if next_char == nil then return end char_count = char_count +1 set_pin_state(TX, SLO) set_callback(time + BAUDCLK, UART_DATA) end if event == UART_STOP then set_pin_state(TX, SHI) set_callback(time + BAUDCLK, UART_START) end if event == UART_DATA then if get_bit(next_char, BIT_COUNTER) == 1 then set_pin_state(TX, SHI) else set_pin_state(TX, SLO) end if BIT_COUNTER == 7 then BIT_COUNTER = 0 set_callback(time + BAUDCLK, UART_STOP) return end BIT_COUNTER = BIT_COUNTER + 1 set_callback(time + BAUDCLK, UART_DATA) end end Производительность Интересный вопрос, который меня волновал. Я взял модель двоичного счетчика 4040, идущего в поставке Proteus 7 и сделал свой аналог. Используя генератор импульсов подал на вход обоим моделям меандр с частотой 100кГц Proteus's 4040 = 15-16% CPU Load Библиотека на С = 25-28% CPU Load Библиотека и Lua 5.2 = 98-100% CPU Load Библиотека и Lua 5.3a = 76-78% CPU Load Не сравнивал исходники, но видимо очень сильно оптимизировали виртуальную машину в версии 5.3. Тем ни менее, вполне терпимо за удобство работы. Да и вопросами оптимизации я даже не начинал заниматься. Весь этот проект родился как спонтанная идея, и ещё много чего нужно сделать: Ближайшие планы Пофиксить явные баги в коде Максимально уменьшить возможность выстрелить себе в ногу Документировать код под Doxygen Возможно, перейти на luaJIT Реализовать аналоговые и смешанные типы устройств С плагин для IDA Разумеется, хотелось бы найти единомышленников, желающих помочь если и не участием в написании кода, то идеями и отзывами. Ведь сейчас многое захардкодено под цели и задачи, которые нужны были мне. Скачать без рекламы и смс Репозиторий с кодом. Готовая библиотека и отладочные символы для GDB лежат тут.", "image": ["https://habrastorage.org/files/691/fd5/6b9/691fd56b988743d4bd342bd5983ee323.jpg", "https://habrastorage.org/files/ba4/772/e29/ba4772e29973427595eba8f4e631b054.png", "https://habrastorage.org/files/d95/9c5/a11/d959c5a11e3c4a678e1bf28a2c9323c7.Gif", "https://habrastorage.org/files/2ba/606/da5/2ba606da569942148a711d4aaf7ea18c.png", "https://habrastorage.org/files/2fd/d8c/ef6/2fdd8cef60d44f02a6ba04355882f14d.png", "https://habrastorage.org/files/38b/239/5f8/38b2395f8e6445ea86eb1b14c59ecdfc.png", "https://habrastorage.org/files/5ed/0d1/77d/5ed0d177da0d4e9b8fe39166ee407e53.Gif", "https://habrastorage.org/files/e2a/5f9/3b4/e2a5f93b47f0424ca2f4c6a97e3fa9bc.Gif"], "tag": ["c", "lua", "proteus", "vsm", "симуляция", "моделирование цепей"], "rating": ["+28"], "bookmarks": ["114"], "views": ["23,4k"], "comments_count": ["4"]},
{"author": ["Demogor"], "date": ["27 сентября 2014 в 22:13"], "hubs": ["Lua", "C#", "Ненормальное программирование"], "type_label": [], "text": "Вчера внезапно узнал, что логи скайпа хранятся в .sqlite. Отлично, подумал я, будет занятие на выходной. Сегодня посмотрел хабру, нашел тему, посвященную описанию самой базы — тема, а также по восстановлению этой самой базы — тема и упоминание программки SkypeLogViewer. Замечательно, подумал я, пора писать очередной упоротый велосипед. Идея проста: выборка и фильтрация чатов через lua — для тех, кто желает немножко попрактиковаться в использовании lua, sql-запросах и lua-аналога linq, а также тем, кого не устраивает стандартный поиск скайпа. Само приложение написано на C#(WPF). Что получилось — смотрите под катом. Итак, начнем с простого — подключения библиотек, необходимых для работы с lua и sqlite. Выбор пал на NLua и System.Data.Sqlite соответственно. Для установки используем NuGet. install-package nlua install-package system.data.sqlite Для удобства и на всяк пожарный делаем небольшой класс-wrapper для lua public class LuaLogic { public Lua lua = new Lua(); //Использование этой функции позволяет зарегестрировать public - метод класса C# для использования из lua public void reg(object target, string funcname) { try { lua.RegisterFunction(funcname, target, target.GetType().GetMethod(funcname)); } catch (Exception ex) { } } //Вызов lua-функции из шарпа public object[] call(string lua_func, params object[] args) { try { var func = lua[lua_func] as LuaFunction; return func.Call(args); } catch (Exception ex) { return null; } } } И да, я в курсе, что многие считают, что Exception обязан выводиться — вот только надобности в этом в данном конкретном случае не вижу. Разметку для gui выкладывать не буду, потому вот описание используемых в коде элементов GUI: output — RichTextBox, для вывода разного рода информации, к примеру, пошлых шуток или ascii-арта runlua — Button, для выполнения lua-кода. Вообще-то можно подвесить на изменение файла при помощи FileSystemWatcher'а, но это уже на любителя accounts — ComboBox, в который будет выводиться список пользователей скайпа, когда-либо логинившихся на компьютере Теперь перейдем, собственно, к коду. Начнем со вспомогательных функций. static LuaLogic logic = new LuaLogic(); public string current_path = \"\"; private List<Dictionary<string, object>> data; //Выполнение запроса к базе. Возвращает данные в более-менее удобном для работы формате. private List<Dictionary<string, object>> _query(string comm) { var result = new List<Dictionary<string, object>>(); using (var db = new SQLiteConnection(@\"data source=\" + current_path)) { db.Open(); using (var command = new SQLiteCommand(comm, db)) { command.CommandTimeout = 999; using (var reader = command.ExecuteReader()) { while (reader.Read()) { result.Add(Enumerable.Range(0, reader.FieldCount) .ToDictionary( reader.GetName, reader.GetValue)); } } } db.Close(); } return result; } //Функция для упаковки результата выборки в понятный lua формат. К сожалению, как работать с List<Dictionary<string, object>> через lua так и не допер. Преобразовывает коллекцию в lua-таблицу, состоящуюю из lua-таблиц. public LuaTable genTable(List<Dictionary<string, object>> d) { logic.lua.NewTable(\"datatable\"); var table = logic.lua.GetTable(\"datatable\"); for(int i=0; i<d.Count; i++) { logic.lua.NewTable(\"f\"); table[i] = logic.lua.GetTable(\"f\"); foreach (var entry in d[i]) { ((LuaTable) table[i])[entry.Key] = entry.Value; } } return table; } /*** Функции, вызываемые из lua ***/ //Собственно, запрос к БД. Вызов перенес на сторону lua для пущего удобства. public void scanDB(string request=null) { if(data!=null) data.Clear(); data = new List<Dictionary<string, object>>(); data = _query(request??\"select from_dispname,body_xml,timestamp from messages order by timestamp desc\"); genTable(data); } //Вывод данных в RichTextBox public void _print(object obj) { Dispatcher.Invoke(() =>output.AppendText(obj + \"\\n\")); } //Еще 1 вариант вывода данных в RichTextBox. Просто так. public void _printblock(string text) { Dispatcher.Invoke(() => output.Document.Blocks.Add(new Paragraph(new Run(text)) { Margin = new Thickness(0) })); } //Очистка RichTextBox public void _clear() { Dispatcher.Invoke(() => output.Document.Blocks.Clear()); } А теперь — логика приложения! public MainWindow() { InitializeComponent(); //Получаем путь до настроек скайпа. Если у вас лежит в другом месте - ну что ж, допилку лобзиком никто не отменял var searchpath = Environment.ExpandEnvironmentVariables(\"%AppData%\\\\Skype\"); var dirs = Directory.GetDirectories(searchpath); //Немного стремный способ получения папок со списком юзеров, но умнее и универсальнее не придумал var userlist = dirs.Where(dir => File.Exists(dir + \"\\\\main.db\")).Select(x=>x.Replace(searchpath+\"\\\\\", \"\")).ToList(); accounts.ItemsSource = userlist; accounts.SelectedItem = accounts.Items[0]; //меняем путь до файла с логами по изменению выбранного значения в ComboBox'е accounts.SelectionChanged += (sender, args) => current_path = Environment.ExpandEnvironmentVariables(\"%AppData%\\\\Skype\") + \"\\\\\" + accounts.SelectedItem + \"\\\\main.db\"; if(userlist.Count>0) current_path = Environment.ExpandEnvironmentVariables(\"%AppData%\\\\Skype\") + \"\\\\\" + userlist[0] + \"\\\\main.db\"; else { _print(\"Зачем тебе читалка логов скайпа, если у тебя даже скайпа нету?\"); } //Регистрируем шарповские функции для вызова из Lua logic.reg(this, \"_print\"); logic.reg(this, \"_clear\"); logic.reg(this, \"_printblock\"); logic.reg(this, \"scanDB\"); runlua.Click += (sender, args) => { try { new Thread(() => { //Подключаем 2 скрипта- для работы с linq-подобными where и select и, собственно, основной скрипт. Lua-linq я честно спер и переделал под свои задачи <a href=\"http://codea.io/talk/discussion/618/linq-for-lua-functional-collection-class/p1\">отсюда</a>. logic.lua.DoFile(@\"scripts\\pseudolinq.lua\"); logic.lua.DoFile(@\"scripts\\script.lua\"); //Вызов функции, в которой хранится lua-логика. Кстати, необязательно, достаточно добавить вызов нужной функции в одном из подгружаемых lua-скриптов logic.call(\"search_pattern\"); }).Start(); } catch (Exception ex) { _printblock(ex.Message); } }; //Старая добрая заглушка, на случай, если нету необходимости сохранения данных и лень возиться с потоками Closing += (sender, args) => Process.GetCurrentProcess().Kill(); } Ну и на закуску — lua-код. pseudolinq.lua LinqArray = {} function LinqArray:new( arr ) Ret = {} Ret.arr = arr; setmetatable( Ret , self ) self.__index = self; return Ret; end --[[function LinqArray:init(items) if items then self:addRange(items) end end]]-- function LinqArray:add(item) table.insert(self.arr, item) end function LinqArray:addRange(items) for k,v in ipairs(items) do self.arr:add(v) end end function LinqArray:where(func) local results = {}; for k, v in ipairs(self.arr) do if func(v) then table.insert(results, v); end end return LinqArray:new(results) end function LinqArray:select(func) local results = {} for k, v in ipairs(self.arr) do _print(func(v)); table.insert(results, func(v)); end return LinqArray:new(results) end script.lua function search_pattern() --подчищаем вывод от предыдущего запроса _clear(); local f = LinqArray:new(datatable); --самая мякотка - linq-подобный фильтр local filtered = f:where(function(x) return string.len(x[\"from_dispname\"])>1; end):select(function(x) return x[\"from_dispname\"]; end); --распечатка полученных сообщений в нужном формате. Просто пример. Использование именно в таком виде необязательно, нежелаемо и вообще, нерекомендуемо. Если что - я предупредил. local i=0; for i=1,#filtered.arr,1 do local arg = filtered.arr[i]; _printblock(arg[\"from_dispname\"]..\": \"); _print(arg[\"body_xml\"]); end end --Собственно, запрос к базе. Результат хранится в памяти для ускорения работы. В данном случае, запрос выполняется только 1 раз, что бы выполнять при каждом перезапуске lua, достаточно убрать проверку if(datatable==nil) then scanDB(\"select * from messages limit 100\"); end Остановлюсь чуть поподробнее на фильтре. Вообще, делать его в linq-подобном формате необязательно, да и сам фильтр можно было делать запросом — но это же хаб «ненормальное программирование», нужно же добавить что-нибудь неочевидное. Остановка завершена. В принципе, это все. Спасибо за внимание!", "image": [], "tag": ["субботним вечером", "я не пил", "C#", "lua", "sqlite", "ненормальное программирование"], "rating": ["+4"], "bookmarks": ["25"], "views": ["7,7k"], "comments_count": ["4"]},
{"author": ["AterCattus"], "date": ["29 июня 2014 в 14:57"], "hubs": ["Lua"], "type_label": ["Tutorial"], "text": "В Lua ООП нет. И оно, в общем-то и не нужно: удобной модульности и функций первого класса достаточно для реализации многих вещей. На этом можно было бы и закончить, но пост не про это. В данном случае я распишу работу с метатаблицами, где в качестве примера шаг за шагом будет реализовываться системка по работе с классами в несколько таком python-стиле. Для понимания нужен хотя бы основной базис языка: таблицы, upvalues. Вариант влоб Начать можно с самого простого примера: local Obj = {} function Obj.spam() print 'Hello world' end --[[ Аналогично можно написать и так: local Obj = { spam = function() print 'Hello world' end, } ]] Obj.spam() -- Hello world Мы получили таблицу с одним ключом, значением которого является функция. Однако внутри самой Obj.spam нельзя получить ссылку на сам Obj (кроме как по имени за счет upvalue), потому что пока нет никаких this/self и т.п. внутри функции. Мы можем «реализовать» это сами: local Obj = {} function Obj.spam(self) print(self) end Obj.spam(Obj) или предоставить это lua: local Obj = {} function Obj.spam(self) print(self) end function Obj:spam2() print(self) end Obj:spam() -- эквивалентно Obj['spam'](Obj), т.е. не просто вызов метода, а сначала получение поля по имени, а затем его вызов, как функции. Obj:spam2() Obj.spam(Obj) -- table: 0x417c7d58 -- table: 0x417c7d58 -- table: 0x417c7d58 Результатом работы будет одна и та же ссылка, т.к. все три self одинаковы. Явное использование a:b вместо a.b(a) можно использовать, при желании, для визуального разграничения методов класса Obj.foo(cls) и методов инстанции a.foo(self). Наивный вариант конструктора мог бы выглядеть так: local Obj = { var = 0, } function Obj:new(val) self:set(val or 0) return self end function Obj:set(val) self.var = val end function Obj:print() print(self.var) end local a = Obj:new(42) a:print() local b = Obj:new(100500) b:print() a:print() -- 42 -- 100500 -- 100500 Происходит переиспользование одной и той таблицы, что приводит к замене a.var внутри b.set. Для разделения нужно выдавать в new новую таблицу: local Obj = { var = 0, } function Obj:set(val) self.var = val end function Obj:print() print(self.var) end function Obj:new(val) -- каждый раз создаем новую таблицу local inst = {} -- добавляем в эту таблицу все, что есть в Obj for k, v in pairs(self) do inst[k] = v end inst.new = nil -- для запрета создания инстанций из инстанций. можно и оставить :) inst:set(val or 0) return inst end local a = Obj:new(42) a:print() local b = Obj:new(100500) b:print() a:print() -- 42 -- 100500 -- 42 Это работает, но уж больно криво, да и нужно повторять каждый раз. Метатаблицы В Lua для каждой таблицы (и userdata, но сейчас не про них речь) можно задавать метатаблицу, описывающую поведение данной таблицы в особенных случаях. Такими случаями могут быть использование в арифметике (перегрузка операторов), конкатенация как строк и т.д. В качестве небольшого примера перегрузки операторов и приведения к строке: local mt = { __add = function(op1, op2) local op1 = type(op1) == 'table' and op1.val or op1 local op2 = type(op2) == 'table' and op2.val or op2 return op1 + op2 end, __tostring = function(self) return tostring(self.val) end, } local T = { val = 0, new = function(self) local inst = {} for k, v in pairs(self) do inst[k] = v end -- метатаблица не является явным полем таблицы, ее нужно назначать явно setmetatable(inst, getmetatable(self)) return inst end, } setmetatable(T, mt) local a = T:new() a.val = 2 local b = T:new() b.val = 3 print(a) print(b) print(a + b) print(a + 10) print(100 + b) -- 2 -- 3 -- 5 -- 12 -- 103 В данном случае нас интересует ключ __index, используемый при обращении к не существующему ключу таблицы, который внутри lua используется следующим образом: Если значением ключа является функция, то та вызывается с передачей ей таблицы и искомого ключа. Результат работы функции используется как значение ключа. Повторное обращение по этому же ключу вновь вызывает функцию (никакого «кеширования»); Если значением ключа является другая таблица, то ключ ищется в ней. Если ключ не находится, то у данной таблицы рекурсивно проверяется ее метатаблица, и так далее. Самый настоящий We need to go deeper. Такой подход позволяет отделить описание класса от создания его экземпляра: local T = {} local T_mt = { __index = T, -- если у таблицы нет ключа, то следует посмотреть в другой таблице } function T.create() -- setmetatable возвращает свой первый параметр в качестве результата return setmetatable({}, T_mt) end function T:set(val) self.val = val or 0 end function T:print() print(self.val) end local a = T.create() a:set(42) local b = T.create() b:set(100500) a:print() b:print() a:print() -- поле инстанции a.foo = 7 print(a.foo) print(b.foo) -- поле класса T.bar = 7 print(a.bar) print(b.bar) Получаемые a и b являются пустыми таблицами, не имеющими ключей new, set и print. Данные методы хранятся в общей таблице T. При таком подходе вызов a:print() на самом деле разворачивается в (только итоговая ветвь исполения): getmetatable(a).__index.print(a) Внутри lua это выполняется очень быстро. При необходимости получить значение только из таблицы, не задействуя магию метатаблиц, можно заменить a.bar на rawget(a, 'bar') / rawset(a, 'bar', value). В качестве дополнительной приятной мелочи можно реализовать более привычный синтаксис конструкторов: local T = {} setmetatable(T, { __call = function(cls) return cls.create() end, }) -- Все! Теперь вместо T.create() можно писать просто T(): local a = T() local b = T() Развитие идеи Теперь можно попробовать собрать все это воедино в общий генератор классов, который будет выглядеть так: local OOP = {} function OOP.class(struct) -- магия return cls -- возвращаем класс, не инстанцию end -- создаем класс из описания публичных полей и методов инстанции local A = OOP.class { val = 0, set = function(self, val) self.val = val or 0 end, print = function(self) print(self.val) end, } -- создаем и используем local a = A:create() a:print() a:set(42) a:print() Реализация в данном объеме весьма простая: function OOP.class(struct) local struct = struct or {} local cls = {} local function _create_instance() local inst = {} for k, v in pairs(struct) do inst[k] = v end return inst end setmetatable(cls, { __index = { create = _create_instance, -- метод класса, не инстанции }, __call = function(cls) return cls:create() -- сахар синтаксиса конструктора end, }) return cls end Всего и делов-то. Для методов класса можно сохранить ссылку на класс внутри таблицы инстанции и воспользоватся ей в последствии: -- ... local function _create_instance() local inst = {} -- ... inst.__class = cls -- ... end -- ... A.clsMeth = function(cls) print('Hello') end -- ... a.__class:clsMeth() -- a.clsMeth() не доступно Гораздо интереснее ситуация с наследованием. Пока разберем единичное: -- метод исключительно ради красивого синтаксиса. необходимости в нем нет function OOP.subclass(parent) return function(struct) return OOP.class(struct, parent) end end local A = OOP.class { -- ... } local B = OOP.subclass(A) { -- B является потомком A welcome = function(self) print('Welcome!') self:print() -- вызов метода предка как своего end, } local b = B() b:print() b:set(100500) b:welcome() Для реализации нужно внести не так уж и много правок: function OOP.class(struct, parent) -- 1. передаем данные по родителю local struct = struct or {} local cls = {} local function _create_instance() local base = parent and parent:create() or nil -- 2. при создании инстанции создаем ее предка local inst = {} -- 3. берем из родителя все его публичные поля if base then for k, v in pairs(base) do inst[k] = v end end for k, v in pairs(struct) do inst[k] = v end inst.__class = cls return inst end setmetatable(cls, { __index = setmetatable( -- 4. метатаблица получает собственную метатаблицу { create = _create_instance, }, { -- если чего нет у текущего класса, то ищем у предка __index = function(_, key) if parent then return parent[key] end end, } ), __call = function(cls) return cls:create() end, }) return cls end Для создания собственных явных конструкторов опишем метод new и будем его вызывать при создании инстанции: -- ... setmetatable(cls, { -- ... __call = function(cls, ...) local inst = cls:create() -- если есть конструктор - вызываем его local new = inst.new if new then new(inst, ...) end return inst end, }) -- ... local A = OOP.class { new = function(self, text) text = text or '' print('Hello ' .. text) end, } local B = OOP.subclass(A) { } A('world') B('traveler') -- Hello world -- Hello traveler Автоматического вызова конструктора (да и вообще любого другого метода) предка мы не реализовывали, соотвественно local B = OOP.subclass(A) { new = function(self, text) print('B says ' .. tostring(text)) end, } B('spam') не приведет к вызову A.new. Для этого опять нужно лишь внести небольшое дополнение в логику работы, реализовав метод инстанции super :) local B = OOP.subclass(A) { new = function(self, text) print('B says ' .. tostring(text)) self:super('from B') end, } -- ... local function super_func(self, ...) local frame = debug.getinfo(2) local mt = getmetatable(self) assert(mt and mt.__base, 'There are no super method') local func = mt.__base[frame.name] return func and func(self, ...) or nil end -- ... local function _create_instance() -- ... -- вместо явного объявления inst.super выносим метод в метатаблицу, чтобы он не выглядел как часть структуры. -- но это позволяет объявить одноименный метод/поле. -- можно добавить проверку имени при обходе pairs(struct), если необходимо. но от a.super = x это не спасет. local inst = setmetatable({}, { __base = base, __index = { super = super_func, }, }) -- ... super вызывается без указания имени вызываемого метода. Для его получения используется модуль debug. Если не хочется его использовать (или lua запущена без него), то можно явно передавать имя метода. debug.getinfo() используется для получения краткой информации о запрошенном уровне стека: 0 — сама debug.getinfo, 1 — текущий (super_func), 2 — уровень, где вызвали super_func,… Нам нужно имя функции, из которой была вызвана super, т.е. поле name второго уровня стека. Теперь можно вызывать любые родительские методы, не только конструктор :) Для реализации private полей и методов можно использовать подход на основе соглашения об именовании как в python, или воспользоваться истинным сокрытием через область видимости модуля, или вообще через upvalues: local A = OOP.class((function() -- нет прямого доступа из потомка local function private(self, txt) print('Hello from ' .. txt) end return { val = 0, public = function(self) private(self, 'public') end, } end)()) Ну тут вариантов много. Меня вполне устраивает вариант с соглашением по именованию. Вот такие возможности предоставляют метатаблицы в Lua. Если вы смогли это все прочитать, то, видимо, написано было не зря. Полный и чуть более навороченный вариант реализации можно увидеть тут.", "image": [], "tag": ["lua", "metatable", "метатаблицы", "oop"], "rating": ["+22"], "bookmarks": ["77"], "views": ["16,9k"], "comments_count": ["6"]},
{"author": ["soulburner"], "date": [" 6 февраля 2014 в 12:17"], "hubs": ["Unity3D", "Lua", "Разработка игр"], "type_label": [], "text": "Как и обещал — продолжаю делиться с вами теми техническими деталями, которые встречаются нам в процессе создания нашей игры. На этот раз поговорим о языке для написания внутриигровых скриптов. В этой статье я расскажу, почему именно Lua, а не самописный велосипед. Зачем вообще игре может понадобится скриптовый язык. Какие тонкости есть при прикручивании этого дела к Unity и покажу как это делается на примере интеграции UniLua. Сразу скажу, что к последнему информации в интернете почти что ноль, и половина этого нуля — на китайском. Так что, можно сказать, — держите эксклюзив. Зачем нам скрипты? В нашей игре у нас есть необходимость показывать разнообразные скриптованные сценки. Приведу типичный пример квеста. Персонаж заходит в магазин и видит, что там идет ограбление. Показывается картинка, изображающая бандитов, держащих биту у виска испуганного продавца. Затем показывается какой-то диалог. Потом мы видим, как наш персонаж подходит к заварушке и появляется окно выбора действия — помочь продавцу и раздать рэкетирам или вписаться за них. Очевидно, что здесь нужно двигать спрайты, менять им анимации, показывать игроку разные диалоги и картинки… Вариантов тут не много — либо хардкодить каждый квест, либо попытаться это дело заскриптовать. Очевидно, что хардкодить такие штуки — вообще не тру. Почему Lua? Собственно, изначально был выбор между собственным велосипедом и Lua. Казалось бы, с первого приближения язык многого не требует и можно написать собственный. Вызывай себе команды по порядку и все. Но если подумать поглубже… Будут ли события скрипта связанны с параметрами игры? Например, убитый раньше NPC не должен появляться в сценках. Или еще что-то такое. А это уже означает какие-то условия, триггеры и т.п. В результате парсер «простенького языка» может вылиться в весьма сложную штуковину, которой надо будет парсить кучи логических выражений и т.п. и т.д. Недолго думая, было решено использовать чужое и проверенное. Lua. Возможно, есть еще и другие языки… но именно Lua я вижу постоянно в других играх. В том же World of Warcraft моды писались именно на этом странном языке, где индексация начинается с единицы. Так что, опять-таки, — было принято решение использовать проверенное другими решение. Интеграция в Unity Здесь начинается первое веселье. Первая же библиотека, реализовывающаяя Lua в Unity, которую вы найдете — будет выглядеть хорошо. Но если копнуть глубже, то окажется, что она юзает какие-то специфичные методы .Net, которые, например, недоступны на мобилах (а, возможно, и каких-то других платформах). А нам бы хотелось библиотеку, которая бы поддерживалась везде (на всякий случай) и желательно еще полностью с исходниками, а не в закрытой DLL'ке. Покопавшись в инете, мы нашли бесплатное творение китайских программистов — UniLua. Полные сорцы и работает везде. Оно всем хорошо кроме того, что доки невероятно скудны и частично написаны на китайском. Ну да ладно, у нас же есть исходники! И мозг… =) Качаем, закидываем папку UniLua в плагины (чтобы не перекомпилировалось каждый раз) и вперед. Вызываем Lua-скрипт из C# Тут все сравнительно просто: using UniLua; private ILuaState _lua; // через этот объект будет производится работа с Lua private ThreadStatus _status; // объект для работы с конкретным скриптом ... _lua = LuaAPI.NewState(); // создаем string lua_script = \"\"; // сюда можно писать код на Lua _status = _lua.L_LoadString(lua_script); // загружаем скрипт if (_status != ThreadStatus.LUA_OK) { Debug.LogError(\"Error parsing lua code\"); } _status.Call(0, 0); // запускаем Lua-скрипт Можно попробовать запустить. Если никто не ругнулся — значит все хорошо. Пустой скрипт успешно выполнился. Вызов функций C# из Lua Теперь надо научиться рулить хоть чем-то из этого скрипта. Очевидно, нам нужно научиться вызывать код на C# из Lua. Напишем метод, который просто пишет параметр в лог: private int L_Trace(ILuaState s) { Debug.Log(\"Lua trace: \" + s.L_CheckString(1)); // читаем первый параметр return 1; // так надо } Как видите, мы использовали класс ILuaState. Именно там хранятся все входные параметры (которые мы захотим передать из Lua и именно туда нужно возвращать результат. Обратите внимание! Результат в Lua возвращается не через return, а через s.PushInteger(), s.PushString() и т.п. Функция написана. Теперь ее надо подключить к Lua. private int OpenLib(ILuaState lua) { var define = new NameFuncPair[] // структура, описывающая все доступные методы (интерфейс Lua -> C#) { new NameFuncPair(\"trace\", L_Trace), }; lua.L_NewLib(define); return 1; } Далее, после создания объекта _lua, нам нужно добавить подключение этого описания библиотеки: _lua.L_OpenLibs(); _lua.L_RequireF(\"mylib\", OpenLib, true); Готово! Теперь можно сделать так: string lua_script = @\" local lib = require \"\"mylib\"\" lib.trace(\"\"Test output\"\") \"; Казалось бы, все? Но нет. Теперь самое сложное. Yield Немного подумав, можно понять, что наш скрипт на Lua не должен выполняться непрерывно. В нем явно будут паузы, ожидание окончания какой-то анимации, нажатия клавиши и т.п. То есть скрипт должен возвращать управление обратно шарпам, а потом, в какой-то момент — продолжаться. Именно здесь я сломал множество копий. Толковое описание, как это сделать было очень трудно найти (и то было для другой библиотеки). Первое, что нам нужно будет — это запускать скрипт не Call'ом, а через отдельный поток: //_status.Call(0, 0); это нам больше не нужно. вместо этого пишем: _thread = _lua.NewThread(); _status = _thread.L_LoadString(lua_script); _thread.Resume(null, 0); Теперь представим себе, что мы на C# написали функцию «подождать окончания анимации» (L_WaitForAnimationStop), которую вызываем из Lua. Реализация тут может быть разная, то я опишу общий принцип. В этой функции нам нужно повесить на окончание этой анимации какой-то callback, и самое главное — ввместо return 1 мы должны сделать так: private int L_WaitForAnimationStop(ILuaState s) { // здесь добавляем нужные callback'и и т.п. _temp_state = s; // сохраняем ILuaState в приватный член класса return s.YieldK(s.GetTop(), 0, null); // указываем Lua, что оно должно отдать управление шарпам } А непосредственно в callback'е — нам нужно будет продолжить выполнение скрипта с места, где он остановился if (_temp_state.GetTop() > 0) _thread.Resume(null, 0); Вот и все. Теперь скрипт типа: lib.trace(\"starting\") lib.wait_for_animation_stop() lib.trace(\"stopped\") после lib.wait_for_animation_stop() приостановится и продолжится только когда вы этого захотите (т.е. в вышеописанном случае — вызовите callback, который и сделает Resume()). Чего удалось добиться С помощью вышеописанного метода, а также шаманства для имитации ООП, удалось добиться такого синтаксиса: local ch1 = CharacterGfx() ch1.create(\"char_0\") local ch2 = CharacterGfx() ch2.create(\"char_1\") ch1.moveto(\"workout\") ch2.moveto(\"fridge\") ch2.wait_move_finish() ch1.wait_move_finish() vh.trace(\"finished ok\") Скрипт создает два спрайта персонажей, двигает первого к точке «workout», второго — к точке «fridge», потом ждет, когда оба закончат свое движение, и только потом пишет «finished ok». Из документации могу посоветовать только Lua 5.2 Reference Manual, где все эти шаманства описаны, хоть и немного для другой реализации. Все статьи серии: Идея, вижен, выбор сеттинга, платформы, модели распространения и т.п Шейдеры для стилизации картинки под ЭЛТ/LCD Прикручиваем скриптовый язык к Unity (UniLua) Шейдер для fade in по палитре (а-ля NES) Промежуточный итог (прототип) Поговорим о пиаре инди игр 2D-анимации в Unity («как во флэше») Визуальное скриптование кат-сцен в Unity (uScript)", "image": ["https://habrastorage.org/getpro/habr/post_images/118/7a6/2f5/1187a62f58d421298c017ba67ad5fe83.png"], "tag": ["lua", "скрипты", "игровые скрипты", "unity3d", "unity", "vhstory"], "rating": ["+17"], "bookmarks": ["266"], "views": ["38k"], "comments_count": ["35"]},
{"author": ["Izaron"], "date": ["28 января 2014 в 20:34"], "hubs": ["Lua", "C#", "Разработка игр"], "type_label": [], "text": "Привет, Хабрахабр! Этот небольшой пост родился после того, как я решил узнать, как можно запускать скрипты Lua совместно с игрой на C# (либо на другом .NET-языке). с использованием библиотеки LuaInterface. Я был впечатлен легкостью этого интерфейса по сравнению с lua.h на C++ Что нужно знать C# на приличном уровне, иметь понятие об основах программирования, а также о подключении ссылок в проекте на Visual Studio Начало Исходники (со всеми dll, конечно) выложены в конце поста Первое, что нужно сделать — подключить к нашему проекту LuaInterface.dll. Просто добавляем ссылку на файл .dll. Если вы еще не в курсе, как это делается, то можете найти мануалы в интернете. Также для подключения требуется luanet.dll Небольшой ликбез LuaInterface — библиотека для удобной интеграции между Lua и CLR Lua — очень легкий скриптовый язык программирования. Вот его разбор Для чего нужны скрипты — выдержка из другого моего поста Скрытый текстЕсли вы разрабатывали большие проекты (к примеру, масштабные игры), замечали, что с каждой новой сотней строк кода компиляция идет медленней? В игре создается больше оружия, больше диалогов, больше меню, больше etc. Одна из самых главных проблем, возникающих в связи с нововведениями — поддерживать бессчетное множество оружия и бейджиков довольно сложное занятие. В ситуации, когда просьба друга/босса/напарника изменить диалог или добавить новый вид оружия занимает слишком много времени, приходится прибегать к каким-то мерам — например, записи всей этой фигни в отдельные текстовые файлы. Почти каждый геймдевелопер когда-нибудь делал карту уровней или диалоги в отдельном текстовом файле и потом их считывал. Взять хотя бы простейший вариант — олимпиадные задачи по информатике с файлом ввода Но есть способ, на голову выше — использование скриптов. Решение проблемы «Окей, для таких дел хватает обычного файла с описанием характеристиков игрока. Но что делать, если в бурно развивающемся проекте почти каждый день приходится немножко изменять логику главного игрока, и, следовательно, много раз компилировать проект?» Хороший вопрос. В этом случае нам на помощь приходят скрипты, держащие именно логику игрока со всеми характеристиками либо какой-либо другой части игры. Естественно, удобнее всего держать, логику игрока в виде кода какого-нибудь языка программирования. Первая мысль — написать свой интерпретатор своего скриптового языка, выкидывается из мозга через несколько секунд. Логика игрока определенно не стоит таких жутких затрат. К счастью, есть специальные библиотеки скриптовых языков для С++, которые принимают на вход текстовый файл и выполняют его. Об одном таком скриптовом языке Lua пойдет речь. Теперь, когда у нас есть проект с подключенным LuaInterface, переходим к коду! LuaInterface — основы В основном .cs файле пишем using LuaInterface; Основной класс этой библиотеки — Lua Lua lua = new Lua(); Объявление констант Очень просто можно объявить константы. Делается это так lua[ключ] = значение; lua[\"version\"] = 0.1; lua[\"name\"] = \"YourName\"; lua[\"test\"] = 200; lua[\"color\"] = new Color(); lua[\"my\"] = this; В качестве значения может выступать что угодно — число, строка, даже классы и структуры (о том, как с ними работать, будет дальше) Регистрация функций В Lua можно зарегистрировать функцию из C# lua.RegisterFunction(название функции в Lua, this, функция); lua.RegisterFunction(\"puts\", this, typeof(Program).GetMethod(\"Test\")); Регистрация классов и структур Одна из самых приятных сторон LuaInterface, которая может удивить тех, кто использует Lua совместно с C++, это то, что можно регистрировать объект класса и после этого вызывать в скрипте разные функции «напрямую» То есть можно сделать так: C# class LuaDebug { // Запись любого текста с указанным цветом private void Print(string message, ConsoleColor color) { Console.ForegroundColor = color; Console.WriteLine(message); } public void Log(string message) { Print(\"Log: \" + message, ConsoleColor.White); } public void Warning(string message) { Print(\"Warning: \" + message, ConsoleColor.Yellow); } public void Error(string message) { Print(\"Error: \" + message, ConsoleColor.Red); } public string ConsoleRead() { return Console.ReadLine(); } } // ... lua[\"Debug\"] = new LuaDebug(); И после этого сделать Lua скрипт с таким содержанием: str = Debug:ConsoleRead() -- считывание строки Debug:Log(\"Приложение запущено\") Debug:Warning(\"Введенная строка: \" .. str) Debug:Log(\"Удачного дня!\") Debug:ConsoleRead() -- пауза Выполнение Lua кода Выполнить Lua код (со всеми зарегистрированными функциями и константами) можно двумя способами Первый — прямиком из C# lua.DoString(код) lua.DoString(\"Debug:Log('Hello, Habr!')\" + \"\\n\" + \"Debug:ConsoleRead()\"); Второй — из файла lua.DoFile(file) lua.DoFile(\"script.lua\") (Оба метода возвращают значение object[] — это то, что возвращает Lua скрипт после выполнения) Обработка исключений Для обработки исключений — ошибок, которые могут выскочить во время выполнения скрипта, следует использовать LuaException err try { // Lua, lua, lua } catch (LuaException err) { // Обработка ошибки } Вызов методов из Lua Для вызова метода из Lua надо выполнить скрипт, выудить метод, и выполнять его когда потребуется. Пример lua.DoFile(\"file.lua\") LuaFunction func = lua[\"func\"] as LuaFunction; // function func() {...} end func.Call(); Также в Call(params object[] args) можно передавать входные параметры для функции Тот же финт срабатывает и со значениями, только вместо LuaFunction используем string, int, double и так далее Дополнительные материалы Для таблиц в LuaInterface предусмотрен класс LuaTable, регистрируется в объекте класса Lua он как обычная переменная, а запись переменных в саму таблицу мало чем отличается от записи переменных в самом Lua объекте Также есть класс LuaDLL, используемый для «низкоуровневой» работы с Lua (из lua.h). Толку от него немного, и вряд ли кто-то использует его по-серьезному Пример LuaDLL.lua_open(); LuaDLL.lua_createtable(luaState, 1, 1); Символика Lua Love2D — один из самых популярных движков на Lua Мод для Minecraft на Lua https://bitbucket.org/Izaron/luaforhabr/src Исходный код", "image": ["https://habrastorage.org/getpro/habr/post_images/f86/12e/069/f8612e0691da4500e2a8733425c372e3.gif", "https://habrastorage.org/getpro/habr/post_images/01a/f2c/a34/01af2ca347dec0f26d06f8a7f8c3aad9.jpg", "https://habrastorage.org/getpro/habr/post_images/8d1/904/e1c/8d1904e1cb0c8f0b21c35ef58eb8caa3.png", "https://habrastorage.org/getpro/habr/post_images/e9e/370/afe/e9e370afed065de14e27b82e8a9b297c.png", "https://habrastorage.org/getpro/habr/post_images/2aa/3b1/d8f/2aa3b1d8f894e9f70588b55e126a3752.png"], "tag": ["csharp", "lua", "luainterface", "clr"], "rating": ["+16"], "bookmarks": ["130"], "views": ["20,9k"], "comments_count": ["15"]},
{"author": ["dilix"], "date": ["23 января 2014 в 17:59"], "hubs": ["Lua", "Разработка игр", "Разработка мобильных приложений"], "type_label": [], "text": "Вот и пришло время продолжить рассказ об увлекательном хобби — геймдеве — разработке казуальных игр. Ранее в статье я рассказал о первой своей игре под Андроид, которая подтолкнула меня пересмотреть подход в этапах создания и продвижения мобильного приложения. Сегодня я хочу поделится тем, к чему же я все-таки пришел после своего первого опыта и рассказать о создании новой, кросспалтформенной игры под Android и iOs, так же по дороге была сделана html5 и Tizen версия, но обо всем по порядку… С самого начала хотел бы внести небольшой комментарий — игра только вышла, и говорить о том, на сколько в правильном направлении я двигался после анализа своего первого более менее значительного проекта еще рано, но по первым отзывам от бета тестеров можно предположить, что в целом за конечный продукт сейчас по крайне мере может быть не стыдно. Также, все что идет далее, сугубо моё виденье и может коренным образом отличаться от чего угодно. Вместо сухого описания процесса разработки, я предпочел выстроить рассказ как сравнение подходов в разработке двух игр — старой игры и новой о путешествии лягушенка, ведь по сути не так важно что именно я сделал, как то, на сколько статья поможет Вам сделать собственные выводы, принять собственные решения и натолкнуть на гениальные идеи, которые, я надеюсь, выльются в первоклассные приложения! Дальше найдете описание всех этапов разработки — от идеи до релиза, в свете чего получилось «много букв», разделенных по этапам, поехали! С чего все начиналось Идея первой игры была от части навеяна ранее популярными флеш и не только играми на PC, и, в общем, я никогда не скрывал, что в поисках идей ходил по разным игровым сайтам, искал то, что бы меня зацепило. Такими темпами поиски довели до игры, которая и послужила прототипом для мобильного развлекательного приложения. Данный подход хорош в том плане, что «все новое — хорошо забытое старое» (с), но, к сожалению, он не учитывает маленькой, но очень важной детали — управление на PC мышкой и клавиатурой довольно сильно разнятся с тем, что мы видим сегодня на планшетах и телефонах, когда взаимодействие с устройством происходит на «кончиках пальцев». В новой игре надо было сначала продумать максимально простой вариант геймплея и взаимодействия пользователя с виртуальным миром. Было решено выделить «скелет» наиболее удобной и привлекательной игры, основываясь на предыдущем опыте, и, главное, успешных проектах других классных разработчиков. В ходе небольшого анализа и изучения рынка мобильных казуальных игр появился список этаких ключевых аспектов «удачной мобильной казуальной игры»: Мой рецепт \"удачной казуальной игры\"Максимально легкое управление, идеально — один жест Если посмотреть то, во что играют люди, можно заметить стремление к связке — минимальное взаимодействие с экраном телефона + максимальная интерактивность. Как примеры хорошо подходят «Angry birds» — единственное движение — свайп приводит к динамическому развитию сюжета и цепной реакции, в ходе которой весь игровой мир приходит в движение; «Cut the rope» — опять же изначально только лишь свайп, далее вводятся более сложные взаимодействия, но только после освоением пользователем базовых навыков. Теперь можно на минутку отвлечься на первую игру — с самого первого уровня требуется относительно серьезный скилл точного позиционирования пальца на экране, одновременного переключения режимов игры и аналогового управление джойстиком… рядовой пользователь вполне обоснованно снесет приложение после первых же неудачных попыток. Пробуя различные варианты геймплея можно прибегнуть к простому, но очень эффективному способу проверки «играбельности» — дать приложение ребенку, сесть рядом и наблюдать. Моя 5-ти летняя племянница спокойно играет и любит Cut the rope, с новой игрой она справилась относительно быстро. Касательно старой игры — тут можно привести слова моих партнеров — корейцев: «Игра вполне может пойти в Корее, они любят хардкорное управление». Геймплей превыше всего Возьмем, к примеру, любимые издателями f2p игры, такие как «Clash of clans», если посмотреть — такого рода игры были еще и в браузерах до массового появления смартфонов и планшетов, главное время от времени заходить в игру, поставить строится\\исследовать\\воевать виртуальных человечков и можно дальше пойти посмотреть любимый сериал. На мой взгляд, при хорошей реализации, социальные мультиплеерные игры не нуждаются в инновационном, интересном геймплее, люди часто приходят не только за игрой, но за общением и попутно показать «кто тут главный». Теперь давайте вернемся к казуальным не социальным играм. Для чего человек скачивает и что заставляет его возвращаться к игре? Только сам игровой процесс, больше особо нечему. И что тогда будет если он (геймплей) будет скучен? Человек вряд ли запустит приложение более одного раза. Сейчас, смотря как пользователь на первую игру, становится очевидно, что на первом же уровне, пользователь впадает в ступор — не понятно ни что нужно делать, ни зачем это нужно делать, даже не очевидно как… В новой же игре с самого первого уровня учит и объясняет как и для чего нужно двигаться вперед и проходить все новые уровни, пытаясь с самого начала не отпускать пользователя. Пользователя нужно учить При разговоре о геймплее стоит упоминуть тот факт, что при длительной разработке игры он успевает приесться и кажется, что управление очевиднее некуда, а уровни пройдет даже младенец, но попробуйте дать другу игру и попросить пройти первый уровень… В моем случае в первой игре не справился практически никто, в новой — до появления обучающего экрана справилось чуть-чуть больше народа. После заботливого объяснения через интерфейс игры ситуация кардинально меняется — пользователя не вводит в ступор первый же уровень, что несомненно повышает его лояльность. Сложность от уровня к уровню опять же стоит тщательно выверять, ведь когда строишь очередной уровень, зачастую ответ известен заранее, а если посмотреть со стороны, то что поставлено вторым по сложности вполне может сойти и на сто второй. К примеру в том же в моей игре были несколько уровней, которые мне казались не очень то и сложными, а примерно через месяц, после того как я к ним вернулся и попробовал пройти, получилось это сделать раза с 6-7. Мотивация для возвращения Что только люди не придумают, чтобы заставить своих пользователей день ото дня возвращаться в приложение: и бонусы за дневное посещение, и отдельные ивенты, и назойливые напоминания с пуш уведомлениями. С своей игре я решил попробовать не вводить на первом этапе поощрения за отдельно взятое дневное посещение (банально не смог придумать, чем можно на столько завлечь пользователя), но постарался дать мотивацию для прохождения всех уровней, а именно — раз игра про лягушку-птуешественницу, то путь будут после каждого вновь пройденного уровня интересный факт с стране «пребывания». В дальнейшем есть идеи — выводить «Факт дня» в отдельном окне, но не понятно, на сколько это может быть важно для пользователей. Сюжет вокруг главного(ых) героя(ев) Вспомните такие хиты, как «Cut the rope», «Angry birds», «Where's my water» и другие — везде игровая механика завязана на помощи милым созданиям, котроым необходима именно Ваша помощь. При таком подходе кроме всего прочего на мой взгляд происходит более тесное сопоставление одной конкретный игры с ее названием и персонажами, ведь игр, где можно чем-нибудь куда-нибудь запустить можно найти не мало, а «Злобные птицы» — одни. Нельзя утверждать, что без ярко выделенных героев игра бы не слилась даже со своими же клонами. Главный герой — олицетворение игры — милый (на сколько конечно получилось сделать его таковым) лягушенок с портфелем и в кепке, без него это была бы очередная логическая игра, где нужно пропрыгать по стрелочкам. Мягкая монетизация В мыслях о том, как же издаваться я обращался к разным издателям — от небольших компаний, у которых есть просто свои изданные приложения, до таких гигантов как chillingo, rovio, glu и другие, сейчас большинство твердят о том, что хотят выпускать f2p игры, в целом я их конечно понимаю, в теории с пользователя f2p можно получить заведомо больше, нежели с paid/freemium игры, но больше всего мне не понравилась позиция менеджера проектов одной довольно крупной компании — суть заключалась примерно в том, что игры должны зарабатывать, а все остальное (геймплей и тд) потом (а в целом, если они зарабатывают, то и вовсе ничего больше не надо). Я целиком верю в то, что первично крутое приложение, которое нравится пользователям и которые в него играют и делятся своими эмоциями, а классный продукт уже потом можно монетизировать. Именно по этому и в новой игре придерживался позиции максимально мягкой монетизации — можно отключить рекламу (которая появляется только тогда, когда не мешает пользователю — между уровнями — и не блокирует дальнейшее взаимодействие), можно приобрести небольшие упрощения игрового процесса, такие как подсказки. Но целиком игру от начала и до конца можно пройти без единого цента. PS. Да, я понимаю, что таким образом можно ничего и не заработать, но на сегодня по мере сил пытаюсь оставить игры в первую очередь для развлечения пользователей, а не делать очередную машину по выкачиванию денег. Проектирование Должен сказать, о том, чтобы подумать как вообще должно строиться приложение, при создании старой игры я даже не задумывался — делал по мере прихода новых мыслей и идей, тут можно сказать одно — я не очень советую так делать. Игра изначально создавалась на бумажке, в голове прогонялись разные возможные сценарии, разные расположения экранов и элементов и только после того, как рабочий стол был уклеен разными набросками и схемами встала задача о выборе того, где же буду делать в итоге игру. Могу предположить, что мой подход в зарисовке прототипов на бумажке подходит только лишь при очень не большой команде разработки, которая сидит в одном месте, тут например я столкнулся с проблемой, как объяснить дизайнеру, который со мной работал что же я вообще хочу получить на выходе. Тут помог лишь сканер и, нарисованные листочки улетели по почте. В целом, оглядываясь назад, можно сказать, что прототипы, экраны и идеи стоило бы изначально заводить в цифровом виде, но с поры той игры, я считаю новый шаг сделан и можно с уверенностью сказать, что разрабатывать по готовым макетам и прототипам куда удобнее, чем по идее в голове. Дизайн Первая игра была нарисована от руки и на тот момент это было еще не до конца избито, но сегодня я прихожу к выводу, что дешевле отдать некоторые вещи на откуп профессионалам, что в общем я и сделал. Фриланс богат на хороших специалистов, надеюсь Лягушенок придется вам по душе! Как, где и на чем делаем? Первая игра была по сути одним из первых опытов разработки под андроид, тогда даже и в голову не приходило что можно или нужно писать на несколько платформ, новую игру же изначально было решено делать «серьезно», как минимум под iOS + Android. В ходе изучения разных возможных вариантов разработки приложения — от нативных двух разных приложений до всяких разных фреймворков (описание и сравнения которых есть в избытке, в том числе и на хабре), выбор пал на corona, потому что что больше всего понравилось: Относительно не высокая цена (сейчас поднялась, была в районе 350 дол), Хорошая документированность, Активное сообщество, которое пользуются, общается и помогает, Относительно не сложные примеры. Не обходится тут и без минусов: 3rd party libs можно добавлять только в enterprise версии (~1000уе), Закрытие исходники, т.е. допилить внутри недостающий функционал можно только через п.1, Делать большие проекты на скриптовом языке требует отдельного навыка, мне, к пример, отсутствие ООП сильно мешало. Сейчас кажется, что, чтобы разрабатывать в команде сколько-нибудь большие проекты, надо обладать очень крутым скилом пониманием чужого кода, умением вразумительно закомментировать происходящее и знать хорошие практики разработки на скриптовых языках. Лично я далеко не мастер скриптов и lua не мой родной язык, в итоге в ходе работы над проектом возникали вполне стандартные проблемы, которые порой решались нестандартным на мой взгляд способом. Интересные сложности с lua и coronaОткровенно говоря это мой первый опыт с lua, по этому ну судите строго, описываю моменты, которые показались мне с первого взгляда не самыми тривиальными. Lua и ооп «Из коробки» lua не поддерживает ООП подход, но в нем реализованы метатаблицы, на которых можно построить некое подобие ООП самому, также на днях мне посоветовали посмотреть в сторону готового решения проблемы, но честно говоря его еще не пробовал. Как сделать свой класс на метатаблицах описано в сообществе coronasdk вот тут: www.coronalabs.com/blog/2011/09/29/tutorial-modular-classes-in-corona Поддержка разных разрешений Как организовать поддержку максимально возможного зоопарка устройств описано хорошо вот тут: developer.coronalabs.com/forum/2012/03/12/understanding-letterbox-scalling В двух словах идея сводится к тому, что выделили рабочую область, которая пересекается у большинства девайсов и именно в ней располагают элементы, а остальное неиспользуемое место отводится под фон. Получается, что то, что обрезается на некоторых устройствах содержит только лишь фон. Локализация Самый удобный вариант, что я нашел, это сделать отдельный lua файл, примерно с таким содержимым: local translations = { [\"test\"] = { [\"en\"] = \"Test\", [\"ru\"] = \"Test\", }, [\"play\"] = { [\"en\"] = \"Play\", [\"ru\"] = \"Играть\", } } function setLanguage() -- выставляем язык приложения (по идее для частичной локализации можно выполнять проверку каждый раз) language = system.getPreference(\"ui\", \"language\") if (string.lower(language) == \"english\") then language = \"en\" elseif (string.lower(language) == \"русский\") then language = \"ru\" end if (string.lower(language) == \"1049\") then -- 1049 - эксперементально выяснено то, что возвращается симулятором language = \"ru\" elseif (translations[\"test\"][language]) == nil then -- если нет перевода для языка, то используем английский (именно для этого переменная test). language = \"en\" end end return translations А в тех местах, где нужно использование локализованной строки остается лишь использовать: translations = require(\"translations\") -- локализация, для удобство можо объявить в одном месте, в самом начале translations[\"play\"][language] Замыкания На экране с выбором уровня, где располагается сетка n*m элементов необходимо передать выбранный элемент в универсальный обработчик событий, в связи с тем, что хендлер задается для определенного события таким образом: level:addEventListener( \"tap\", onImageTap); просто передать данные через аргумент не получится. Тут на помощь может прийти замыкания, в сам созданный экземпляр можно добавить необходимые поля, которые будут содержаться в контексте при вызове обработчика: level.idLevel = value и тогда сам обработчик будет выглядеть примерно так: function onImageTap(event) level = \"levels/\"..packNum..\"/\"..event.target.idLevel Анимации На главном экране игры можно увидеть два вида анимации — циклическая по кругу (облака уплывают за экран) и циклическая с обратным ходом. Первый вариант делается довольно легко, путем вызова внутри обработчика конца анимации самого себя: cloudListener = function( obj ) if (obj ~= nil and obj.width ~= nil) then -- если не ушли со сцены и объект еще живой local aTime = nAnimationTime * (30 + math.random(30)) -- рандомная скорость анимации obj.x = - obj.width -- перед анимацией вернуть объект на исходное состояние transition.to( obj, { time=nAnimationTime, x = display.actualContentWidth + obj.width / 2, time = aTime, onComplete = cloudListener} ) end end Вторая ситуация обрабатывается также, только на этот раз будут 2 обработчика, которые по очереди вызывают друг друга. Если объект остается жить после ухода со сцена необходимо не забыть очистить анимацию — transition.to возвращается object, который можно потом осободить от анимации: transition.cancel(animtaionObject); Поиск утечек Для Conorы есть удобный сторонний дешевый профилировщик, который представляет из себя lua файл, который вставляется в проект и в потенциально проблемных местах вызывается метод сбора задействованных объектов, после Nого повторения, например открытия сцены, накапливается пул объкетов и анализ выводится в html страничку, по которой сразу видно где и какие объекты не умирают. Таким образом получилось отловить проблему, из-за которой моя игра начинала жутко тормозить после определенного количества сыгранных уровней. In-app покупки при сборке под ios В официальной документации подробно расписаны шаги, которые нужно проделать для тестирования in-app покупок, но почему-то нигде не смог найти один маленький, но очень критичный нюанс (особенно, если раньше непытались разрабатывать под iOS): необходимо в build.settings в секцию, описывающую ios приложение добавить 'CFBundleIdentifier = «yourbundleid» ', после этого, все сразу взлетело. Система контроля версий? Непосредственно перед разработкой встал вопрос — нужна ли вообще какая-либо система контроля версий, или, когда разрабатываешь один, то можно обойтись обычным бэкапом пару раз в неделю? Для меня есть только один правильный ответ — при разработке всегда использовать такого рода хранилища. Можно привезти несколько вариантов, когда наличие истории изменений оказывается очень полезным: Исходники дизайна разбросаны на несколько файлов, некоторые из них схожи по содержимому, необходимо найти из какого конкретно файла был вырезан тот или иной спрайт, чтобы вырезать увеличенную\\уменьшенную копию изображения — для этого достаточно узнать ревизию и просмотреть ее на наличие измененных исходных файлов, т.к. чаще всего они менялись одновременно, К любому коммиту можно добавить заметку, по которым в дальнейшем можно проследить историю изменений и найти момент, когда прокрался очередной незаметный баг. Можно не боясь смело экспериментировать, имея возможность быстро и безболезненно откатить изменения. Дизайн уровней — отдельная проблема Вот без чего, а без уровней, казуальная игра не может существовать как таковая, в первой игре изначально уровни составлял руками в xml и могу сказать, что работка не из приятных, а редактор появился сильно позже. В игре изначально был избран путь через редактор уровней. Были идеи написать его под мобильное устройство, чтобы можно было составлять и в дороге — с телефона или планшета, но более разумным показался вариант небольшого javascripta, который можно редактировать практически на любом девайсе из любого браузера, а результат сразу сохранялся на сервере. В итоге такой подход принес только пользу: Доступность с любого девайса из любого места Хранение результатов в одном месте — на сервере Доступ к исходникам с любого компьютера Простое редактирование скрипта в любом блокноте Получился редактор, который сэкономил кучу времени и нервов. Сортировка уровней по сложности Каждый уровень игры был пройден после создания, но объективно оценить сложность, не видя картину целиком — не тривиальная задача, тут было найдено опять же универсальное решение: Сриншотилка + онлайн галерея = сетка из всех уровней, которые позволяют визуально сравнить уровни между собой — должен сказать, получилось очень даже удобно. *Но любые галереи, прогоны и тд не заменяют тестирование на живых пользователях — дайте друзьям поиграться, то что Вам может показаться элементарным, на деле может быть почти не проходимым для не посвященного пользователя. Не упускаем шансы засветиться На этапе разработки, когда был уже готовый дизайн, была готова альфа версия приложения, вдруг неожиданно попался на глаза конкурс. Вообще различные мероприятия в виде конкурсов, конференций и тд отлично подходят для обеспечения некого пиара — ведь плохим он не бывает по определению. Итак, игра была портирована усилиями найденного фрилансера на html5 и оттуда на tizen (в дальнейшем ведь можно будет найти применения и веб версии игры). К слову — первая игра между делом тоже появилась на конкурсе. Итого — потрачено менее 1000 дол на одну игру за возможность небольшого пиара и шанса выиграть деньжат на дальнейшее развитие проектов, пусть процент успеха не так велик как хотелось бы, но «игра стоит свечь» и, если бы я не решился, вероятно, в дальнейшем бы очень жалел. Результаты конкурса будут в начале 2014 года, так что будем ждать… Следим за нашим пользователем При создании первой игры я как-то не задумывался о том, чтобы логировать и отслеживать действия пользователя — а зачем, пусть себе играет спокойно… Сегодня я понимаю на сколько был не прав — подробная статистика позволяет не шпионить за игроком, а дает понять что ему нравится, что нет, какие важные элементы игры он не замечает и многие другие интересные факты. На многих конференциях, посвященных мобильным разработкам сегодня говорят о том, как сбор статистики позволяет улучшить мобильное приложение, в игре, используя flurry, corona позволяет легко логировать любые события, строя по ним эффективные графики и схемы, по которым можно проанализировать шаги пользователя в приложении, например понять, что ключевую фишку игры человек просто не заметил… Маркетинг и издание В прошлой статье можно очевидно наблюдать тот факт, что издатели не зря занимаются своим делом и 100% от 1уе гораздо меньше, чем 10% от 100уе, было решено пойти к издателям. Но не тут то было — на сегодняшний день все как один твердят о желании издавать f2p машины по выкачиванию денег. Вполне понятное желание и такая бизнес модель заведомо генерирует большую прибыль, но я все еще верю в казуальные игры, хотя бы потому, что слово 'casual' близко пользователям — ежедневно люди проводят некоторое время в ожидании, которое идеально можно скрасить парой минут в приложении, которое не требует вовлеченности и может быть тут же выключено без потери прогресса и без одинокого собеседника в онлайновой социальной игре. Ведь именно описанное выше характирезует слово 'casual'. Издатели ретировались, но отступать уже некуда, я прекрасно осознаю, что в мире геймдева сейчас работает правило, что зарабатывают на вложенных средствах, маркетинговых бюджетах и покупки новых пользователей. Тем не менее отступать некуда, пресс релизы готовы, видео снято, пора запускать… Для начала решил попробовать менее затратный метод — по возможности отправить пресс релизы и заказать обзоры на разных сайтах, таких как: appadvice.com androidtapp.com iphones.ru 4pda.ru 148apps.com и другие, в том числе найденные тут. О пользе прессрелизов и пресскитов, тут например, говорит Jeff Scott, основатель 148apps. На сколько я понимаю, обзорные сайт сильно заинтересованы в поступлении новых обзоров интересных для них игр, так что они предлагают услуги по составлении обзора до конечного релиза, чтобы запустить pr машину одновременно с появлением игры в маркетах. (Сегодня ни для кого не секрет, что количество скачиваний в первые дни жизни приложений — очень важный параметр). Отдельно для прессы, на промо сайте выложен пресскит — архив с баннерами, иконками, скриншотами и тд, и, должен сказать, это довольно облегчает жизнь при размещение заявок на обзоры, и, стоит полагать, самим редакторам и журналистам такой раздел на сайте крайне удобен — для первичного ознакомления и, возможно, дальнейшего использования, необходимо лишь скачать один архив. Финансы и показатели Вероятно, некоторые читатели найдут данный пункт одним из самых интересных, но… на данный момент о каких-либо результатах говорить рано, если будет интерес, добавлю через некоторое время сюда статистику — интересно посмотреть — на сколько мой подход оказался правильным на сегодняшний день. Получит ли игра отдачу, или, как сказал однажды мой знакомый: «Пробовали, делали, старались… а что получили? Опять опыт.» PS. Надеюсь я не окончательно утомил своим рассказом? Если хотя бы один любитель геймдева нашел хотя бы один абзац данного сочинения позновательным, я считаю что я не зря провел время… А если нет… я хотя бы попытался, спасибо!", "image": ["https://habrastorage.org/getpro/habr/post_images/894/3b5/c82/8943b5c82b9a6484851a0954cb289829.png", "https://habrastorage.org/getpro/habr/post_images/439/ce3/49e/439ce349e3c410dc4b9c0473eb58fa33.png", "https://habrastorage.org/getpro/habr/post_images/225/eb6/82e/225eb682eb38a7e3da216c58f4705550.png", "https://habrastorage.org/getpro/habr/post_images/2f9/b33/81c/2f9b3381c36f0405389d48e1ec48d374.png", "https://habrastorage.org/getpro/habr/post_images/60a/fba/99e/60afba99e0454b52a7657fe6aaf5bead.png"], "tag": ["lua", "cross-platform development", "game development", "mobile development and marketing"], "rating": ["+17"], "bookmarks": ["116"], "views": ["9k"], "comments_count": ["3"]},
{"author": ["fuCtor"], "date": ["11 марта 2014 в 08:19"], "hubs": ["Lua"], "type_label": ["Tutorial"], "text": "Продолжая тему использования связки Nginx + Lua решил поделиться небольшой инструкцией подсчета загрузки статических данных и учетом всего этого в Google Analytics. Будем считать что связка nginx-lua уже настроена и у нас имеется имя счетчика. Если нет, то в сети есть множество инструкций, также есть готовые сборки ( openresty.org ). Для учета нам понадобиться скрипт, который будет отправлять данные в GA. Писать свой не хотелось и на просторах Github-a был найден пример: github.com/wstucco/ssga.lua Данный скрипт имеет один метод track, который принимает обязательным параметром имя счетчика, так же могут быть переданы имя хоста и путь, которые нужно передать. После его срабатывания, на панели статистики в реальном времени увидим наш переданный путь. Учитывать загрузки можно двумя способами: учитывать по пути загружаемого файла; учитывать через события. Первый вариант удобен когда нет смысла разделения файлов по категориям/группам, либо когда это сделать возможности нет, но вести статистику хочется. Второй вариант подходит для случая, когда есть строгая структура файлов, к примеру: раздел-категория-тип. Рассмотри оба. Простой учет пути Самый простой путь, не требующий никаких особых манипуляций и подготовки. Поэтому приведу лишь конечную часть конфига nginx. resolver 8.8.8.8; access_by_lua ' local ssga = require( \"ssga\" ) ssga.track({ua = \"UA-25XXXXXX-1\") '; Перезагружаем и любуемся побежавшими записями в GA. Учет через события Данный способ требует определиться с тем, как будем квалифицировать скачиваемые файлы. В терминах GA нам нужно выделить 3 сущности: категория, действие, метка. В своем случае для этого использовал имена папок, тогда конечный URL загружаемого файла имел вид: dl.domain.name/category/action/label/filename.ext Так же необходимо было научить имеющийся скрипт передавать данную информацию в GA. После небольших модификаций была получена расширенная версия скрипта ( github.com/fuCtor/ssga.lua ). В итоге имеем следующую конфигурацию: server { listen 80; server_name dl.domain.name; root /var/www/public; error_page 502 /502.html; location / { add_header Cache-Control public; expires max; resolver 8.8.8.8; access_by_lua ' opt = {} index = 0 for value in string.gmatch(ngx.var.uri ,\"%w+\") do opt [index] = value index = index + 1 end local ssga = require( \"ssga\" ) ssga.event({ua = \"UA-25XXXXXX-1\", domain = \"dl.domain.name\", category = opt[0], action = opt[1], label = opt[2], value = 1}) '; } } Сохраняем перезагружаем. Теперь можем вести статистику по загрузкам в удобной форме, делать различные срезы. Производительность Проверять будем как быстро отработает именно наш счетчик, поэтому выполним HEAD запросы, тело нас не интересует. Concurrency Level: 30 Time taken for tests: 3.223 seconds Complete requests: 1000 Failed requests: 0 Write errors: 0 Total transferred: 348000 bytes HTML transferred: 0 bytes Requests per second: 310.26 [#/sec] (mean) Time per request: 96.694 [ms] (mean) Time per request: 3.223 [ms] (mean, across all concurrent requests) Transfer rate: 105.44 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 1 Processing: 94 95 0.6 95 99 Waiting: 94 95 0.6 95 99 Total: 94 95 0.6 95 99 Concurrency Level: 30 Time taken for tests: 0.048 seconds Complete requests: 200 Failed requests: 0 Write errors: 0 Total transferred: 69600 bytes HTML transferred: 0 bytes Requests per second: 4166.58 [#/sec] (mean) Time per request: 7.200 [ms] (mean) Time per request: 0.240 [ms] (mean, across all concurrent requests) Transfer rate: 1415.99 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.3 0 1 Processing: 6 6 0.8 6 9 Waiting: 6 6 0.8 6 9 Total: 6 7 0.9 6 10 Изображение в шапке взято отсюда.", "image": ["https://habrastorage.org/getpro/habr/post_images/980/255/3ae/9802553ae812eb81e8e4b80c560c8fa8.png"], "tag": ["lua", "nginx", "google analytics"], "rating": ["+29"], "bookmarks": ["125"], "views": ["8,3k"], "comments_count": ["11"]},
{"author": ["AterCattus"], "date": ["10 марта 2014 в 15:34"], "hubs": ["Lua"], "type_label": [], "text": "Решил пополнить копилку статей на Хабре про такой замечательный ЯП, как lua, парой примеров его использования под капотом nginx. Разбил на два независимых поста, второй тут. В этом посте nginx используется как «горячий кеш» неких постоянно пополняемых данных, запрашиваемых клиентами по интервалу с опциональным группированием (некий аналог BETWEEN и GROUP BY/AGGREGATE из SQL). Подгрузка данных в кеш осуществляется самим же lua+nginx из Redis. Исходные данные в Redis складываются ежесекундно, а клиенты хотят их от сих до сих (интервал в секундах, минутах, часах...) с агрегацией по N (1<=N<=3600) секунд, отсортированные по дате и в json формате. С хорошим hitrate на имеющейся машине получается обеспечить 110-130к «хотелок» в секунду, правда с плохим — только 20-30к. Что, в общем-то, тоже приемлемо для нас на одной инстанции nginx. Из некоего источника ежесекундно приходят данные, которые складываются в Redis ZSET. Важным моментом является привязка данных именно ко времени — выборка будет идти по временным интервалам. Пришел один клиент — «дай мне от сих до сих посекундно», пришел другой — «а мне вот этот интервальчик, но давай с часовой агрегацией», третьему понадобилась одна последняя секунда, четвертому за сутки с аггрегацией по 27 секунд, ну и т.д… Стучаться за данными непосредственно в Redis нереально. Заранее кешировать подготовленные данные весьма проблематично, т.к. требуемые интервалы и шаг агрегации в общем случае у каждого клиента/запроса свой и могут произвольно варьироваться. Сервер должен быть готов быстро ответить на любой разумный запрос. Первоначально была идея выполнять агрегацию на стороне Redis, вызывая через EVAL redis-lua код из nginx-lua кода. Данная «технология We need to go deeper» не подошла из-за однопоточной природы самого Redis: по быстрому отдать «сырые данные» выходит значительно быстрее, чем сгруппировать и выпихнуть готовый результат. Данные в Redis хранятся поэлементно уже в json формате вида: ZADD ns:zs:key 1386701764 \"{\\\"data100500\\\":\\\"hello habr\\\",\\\"dt\\\":\\\"10.12.2013 10:05:00\\\",\\\"smth\\\":\\\"else\\\"}\" Ключом является timestamp, в dt строковый эквивалент по версии «наполняльщика». Соответственно, выборка диапазона: ZREVRANGEBYSCORE ns:zs:data:sec 1386701764 1386700653 WITHSCORES И на lua через resty Redis: local redis = require 'redis' local R, err = redis:new() R:connect('12.34.56.78', 6379) R:zrevrangebyscore('ns:zs:data:sec', to, from, 'WITHSCORES') -- и т.п. Про пул коннектов в resty RedisВажно, что Resty использует настраиваемый пул коннектов к Redis и R:connect() в общем случае не создает новое соединение. Возврат соединения после использования НЕ выполняется автоматически, его нужно выполнить вызовом R:set_keepalive(), возвращающим соединение обратно в пул (после возврата использовать его без повторного R:connect() уже нельзя). Счетчик доставаний текущего коннекта из пула можно узнать через R:get_reused_times(). Если >0 — значит это уже ранее созданное и настроенное соединение. В таком случае не нужно повторно слать AUTH и т.п. Собираем nginx (lua-nginx-module + lua-resty-redis), бегло настраиваем: http { lua_package_path '/path/to/lua/?.lua;;'; init_by_lua_file '/path/to/lua/init.lua'; lua_shared_dict ourmegacache 1024m; server { location = /data.js { content_by_lua_file '/path/to/lua/get_data.lua'; } } } Про работу с shared dictВ конфиге указывается shared dict «ourmegacache», который будет доступен в lua как таблица (словарь, хеш). Данная таблица одна для всех worker процессов nginx и операции на ней атомарны для нас. Доступ к таблице прост: local cache = ngx.shared.ourmegacache cache:get('foo') cache:set('bar', 'spam', 3600) -- и т.п. см. документацию При исчерпании свободного места в памяти, начинается чистка по методу LRU, что в нашем случае подходит. Кому не подходит — смотрите в сторону методов safe_add, flush_expired, и т.п. Так же стоит учитывать еще, вроде как, не решенный официально баг в nginx, связанный с хранением больших элементов в данном shared dict. Для разнообразия границы запрашиваемого интервала и шаг агрегации будем получать из GET параметров запроса from, to и step. С данным соглашением примерный формат запроса к сервису будет таким: /data.js?step=300&from=1386700653&to=1386701764 local args = ngx.req.get_uri_args() local from = tonumber(args.from) or 0 ... Итак, у нас есть поэлементные json записи, хранящиеся в Redis, которые мы можем оттуда получать. Как их лучше кешировать и отдавать клиентам? Можно хранить посекундные записи в таблице по отдельности. Однако, как показала практика, выполнение уже нескольких десятков запросов к таблице крайне негативно сказывается на производительности. А если придет запрос на сутки, то ответа с небольшим таймаутом можно и не дождаться; Записи можно хранить блоками, объединяя через некий общий разделитель или сериализуя их хоть в тот же json. А при запросе нужно разбербанивать по разделителю или десериализовывать. Так себе вариант; Хранить данные иерархически, с частичными повторами на разных уровнях аггрегации. Используются блоки кеша разного размера: 1 секунда (одиночная запись), 10 секунд, 1 минута, 10 минут, час. В каждом блоке содержатся данные всех его секунд. Самое важное, что содержимое блока никак не меняется и не отдается кусками: или целиком как есть или никак. Выбран последний вариант, потребляющий больше памяти, но значительно уменьшающий число обращений к таблице. Используются блоки кеша разного размера: 1 секунда (одиночная запись), 10 секунд, 1 минута, 10 минут, час. В каждом блоке содержатся данные всех его секунд. Каждый блок выровнен на границу своего интервала, например первый элемент 10 секундного интервала всегда имеет timestamp, имеющий десятичный остаток 9 (сортировка по убыванию, как хотят клиенты), а часовой блок содержит элементы 59:59, 59:58,… 00:00. При объединении элементов, они сразу склеиваются с разделителем — запятой, что позволяет отдавать данные блоки клиенту одним действием: '[', block, ']', а также быстро объединять их в более крупные куски. Для покрытия запрошенного интервала выполняется разбиение на максимально возможные блоки с достройкой по краям более мелкими блоками. Т.к. у нас есть единичные блоки, то всегда возможно полное покрытие требуемого интервала. Для запроса интервала 02:29:58… 03:11:02 получаем раскладку по кешам: 1сек - 03:11:02 1сек - 03:11:01 1сек - 03:11:00 1мин - 03:10:59 .. 03:10:00 10мин - 03:09:59 .. 03:00:00 30мин - 02:59:59 .. 02:30:00 1сек - 02:29:59 1сек - 02:29:58 Это лишь пример. Реальные вычисления выполняют на timestamp'ах. Выходит, что нужны 8 запросов к локальному кешу. Или к Redis, если локально их уже/еще нет. А чтобы не ломиться за одинаковыми данными из разных worker'ов/connect'ов, можно использовать атомарность операций с shared dict для реализации блокировок (где key — строковый ключ кеша, содержащий в себе сведения о интервале и шаге агрегации): local chunk local lock_ttl = 0.5 -- пытаемся получить блокировку не дольше, чем полсекунды local key_lock = key .. ':lock' local try_until = ngx.now() + lock_ttl local locked while true do locked = cache:add(key_lock, 1, lock_ttl) chunk = cache:get(key) if locked or chunk or (try_until < ngx.now()) then break end ngx.sleep(0.01) -- ожидание, не блокирующее nginx evloop end if locked then -- удалось получить блокировку. делаем, что собирались elseif chunk then -- лок получить не удалось, но в кеш положили нужные нам данные end if locked then cache:delete(key_lock) end Имея нужную раскладку по кешам, возможность выбора нужного диапазона из Redis, и логику агрегации (тут очень специфично, не привожу примера), получаем отличный кеширующий сервер, который, после прогрева, стучится в Redis только раз в секунду за новым элементом + за старыми, если они еще не выбирались или были выброшены по LRU. И не забываем про ограниченный пул коннектов в Redis. В нашем случае прогрев выглядит как кратковременный скачок входящего трафика порядка 100-110Мб/сек на несколько секунд. По cpu на машине с nginx прогрева вообще почти не заметно. Изображение в шапке взято отсюда.", "image": ["https://habrastorage.org/getpro/habr/post_images/f86/53e/912/f8653e912efdd13702989a0e36ef59e0.png"], "tag": ["lua", "nginx", "redis", "cache"], "rating": ["+58"], "bookmarks": ["196"], "views": ["23,3k"], "comments_count": ["3"]},
{"author": ["AterCattus"], "date": ["10 марта 2014 в 15:34"], "hubs": ["Lua"], "type_label": [], "text": "Данный пост является продолжением применения lua в nginx. Там обсуждалось кеширование в памяти, а тут lua будет использоваться для фильтрации входящих запросов в качестве этакого фаервола на nginx-балансере. Нечто подобное было у 2GIS. У нас свой велосипед :) В котором разделяем динамику и статику, стараемся учесть NAT и белый список. И, конечно же, всегда можно навернуть еще специфичной логики, что не выйдет при использовании готовых модулей. Данная схема сейчас спокойно и ненапряжно (практически не сказывается на использовании cpu) обрабатывает порядка 1200 запросов/сек. На предельные величины не тестировалось. Пожалуй, к счастью :) Хочется обрабатывать все входящие запросы сразу по поступлению, а не по факту строчки в access_log (который еще небось и выключен для той же статики). Не вопрос, вешаем обработчик глобально на весь http: http { include lua/req.conf; } # содержимое lua/req.conf # память под хранение счетчиков запросов (надо много, хотя вытеснение старых записей по LRU допустимо) lua_shared_dict req_limit 1024m; # память под хранение списка забаненных (список должен быть небольшой, но вытеснение крайне нежелательно) lua_shared_dict ban_list 128m; # белый список. проверки не выполняются, защитная кука не ставится geo $lua_req_whitelist { default 0; 12.34.56.78/24 1; } # настройка init_by_lua ' -- секретная соль для защитной куки lua_req_priv_key = \"secretpassphrase\" -- имя защитной куки lua_req_cookie_name = \"reqcookiename\" -- путь до файла лога забаненных lua_req_ban_log = \"/path/to/log/file\" -- допустимые лимиты на запросы (в мин) -- числа исключительно для примера lua_req_d_one = 42 -- динамика на один URI lua_req_d_mul = 84 -- динамика на разные URI lua_req_s_one = 100 -- статика на один URI lua_req_s_mul = 200 -- статика на разные URI lua_req_d_ip = 200 -- динамика с одного IP lua_req_s_ip = 400 -- статика с одного IP -- бан на 10 минут lua_req_ban_ttl = 600 -- служебное math.randomseed(math.floor(ngx.now()*1000)) '; # подключение основного скрипта, встраивающегося в access стадию обработки запросов access_by_lua_file /path/to/nginx/lua/req.lua; Теперь все запросы, приходящие в nginx, пройдут через наш скрипт req.lua. При этом у нас есть две таблицы req_limit и ban_list для хранения истории запросов и списка уже забаненных соотвественно (подробнее ниже). А для реализации whitelist по IP вместо велосипедов использован модуль geo nginx, проставляющий значение переменной lua_req_whitelist, которая используется примерно так: if ngx.var.lua_req_whitelist ~= '1' then -- IP не из белого списка, выполняем проверки end Для проверки статика/динамика (запрос за файлом на диске/backend серверу) делаем простую проверку по имени запрашиваемого файла (тут можно усложнять реализацию, подстраиваясь под свою бизнес логику): function string.endswith(haystack, needle) return (needle == '') or (needle == string.sub(haystack, -string.len(needle))) end local function path_is_static(path) local exts = {'js', 'css', 'png', 'jpg', 'jpeg', 'gif', 'xml', 'ico', 'swf'} path = path:lower() for _,ext in ipairs(exts) do if path:endswith(ext) then return true end end return false end local uri_path = ngx.var.request_uri if ngx.var.is_args == '?' then uri_path = uri_path:gsub('^([^?]+)\\\\?.*$', '%1') end local is_static = path_is_static(uri_path) Для хоть какой-то обработки NAT, кроме IP клиентов так же учитывается их UserAgent и проставляется спец кука. Все три элемента в целом и составляют идентификатор пользователя. Если некий злодей долбит сервер, игнорируя передаваемую куку, то в худшем случае просто будет забанен его IP/подсеть. При этом те пользователи с этой подсети, кто уже получил ранее куку, будут спокойно работать дальше (кроме случая бана по IP). Решение не идеальное, но все же лучше, чем считать полстраны/мобильного оператора за одного пользователя. Генерация и проверки куки: local function gen_cookie_rand() return tostring(math.random(2147483647)) end local function gen_cookie(prefix, rnd) return ngx.encode_base64( -- для разделения двух клиентов с одного IP и с одинаковыми UserAgent, вмешиваем каждому случайное число ngx.sha1_bin(ngx.today() .. prefix .. lua_req_priv_key .. rnd) ) end local uri = ngx.var.request_uri -- запрашиваемый URI local host = ngx.var.http_host -- к какому домену пришел запрос (если у вас nginx обрабатывает несколько доменов) local ip = ngx.var.remote_addr local user_agent = ngx.var.http_user_agent or '' if user_agent:len() > 0 then user_agent = ngx.encode_base64(ngx.sha1_bin(user_agent)) end local key_prefix = ip .. ':' .. user_agent -- проверка контрольной куки local user_cookie = ngx.unescape_uri(ngx.var['cookie_' .. lua_req_cookie_name]) or '' local rnd = gen_cookie_rand() local p = user_cookie:find('_') if p then rnd = user_cookie:sub(p+1) user_cookie = user_cookie:sub(1, p-1) end local control_cookie = gen_cookie(key_prefix, rnd) if user_cookie ~= control_cookie then user_cookie = '' rnd = gen_cookie_rand() control_cookie = gen_cookie(key_prefix, rnd) end key_prefix = key_prefix .. ':' .. user_cookie ngx.header['Set-Cookie'] = string.format('%s=%s; path=/; expires=%s', lua_req_cookie_name, ngx.escape_uri(control_cookie .. '_' .. rnd), ngx.cookie_time(ngx.time()+24*3600) ) Теперь в key_prefix содержится идентификатор клиента, чей запрос мы обрабатываем. Если данный клиент уже забанен, то дальнейшая обработка не нужна: local ban_key = key_prefix..':ban' if ban_list:get(ban_key) or ban_list:get(ip..':ban') then -- проверка ключа и проверка бана вообще в целом по IP return ngx.exit(ngx.HTTP_FORBIDDEN) end Ключ получили, бан проверили, теперь можно посчитать, не превышает ли данный запрос какой из лимитов: -- проверка обоих вариантов: на один URI и на разные URI local limits = { [false] = { [false] = lua_req_d_mul, -- динамика на разные URI [true] = lua_req_d_one, -- динамика на один URI }, [true] = { [false] = lua_req_s_mul, -- статика на разные URI [true] = lua_req_s_one, -- статика на один URI } } for _,one_path in ipairs({true, false}) do local limit = limits[is_static][one_path] local key = {key_prefix} -- разделение статики и динамики в имени ключа if is_static then table.insert(key, 'S') else table.insert(key, 'D') end -- для проверки запросов к одному и тому же пути (для всяких API может не подойти) if one_path then table.insert(key, host..uri) end -- получаем ключ вида \"12.34.56.78:useragentsha1base64:cookiesha1base64:S:site.com/path/to/file\" key = table.concat(key, ':') local exhaust = check_limit_exhaust(key, limit, ban_ttl) if exhaust then return ngx.exit(ngx.HTTP_FORBIDDEN) end end Проверяем 4 варианта счетчиков: статика/динамика, по одному пути/по разным. Непосредственные проверки выполняются в check_limit_exhaust(): local function check_limit_exhaust(key, limit, cnt_ttl) local key_ts = key..':ts' local cnt, _ = req_limit:incr(key, 1) -- если ключа нет, то это первый запрос -- добавляем счетчик и отметку с текущим временем if cnt == nil then if req_limit:add(key, 1, cnt_ttl) then req_limit:set(key_ts, ngx.now(), cnt_ttl) end return false end -- если не превысили лимит (пока даже без учета интервалов) if cnt <= limit then return false end -- если есть превышение лимита (без учета интервалов), -- то нужно получить последнюю отметку интервала и проверить лимит уже с учетом интервала local key_lock = key..':lock' local key_lock_ttl = 0.5 local ts local try_until = ngx.now() + key_lock_ttl local locked while true do locked = req_limit:add(key_lock, 1, key_lock_ttl) cnt = req_limit:get(key) ts = req_limit:get(key_ts) if locked or (try_until < ngx.now()) then break end ngx.sleep(0.01) end -- если не удалось получить актуальные данные и получить лок на обновление - крики, паника, запрещаем запрос. -- при этом не добавляем данный IP в blacklist -- у вас может быть иная логика if (not locked) and ((not cnt) or (not ts)) then return true, 'lock_failed' end -- за сколько времени (в сек) накоплен счетчик local ts_diff = math.max(0.001, ngx.now() - ts) -- нормализация счетчика на секундный интервал local cnt_norm = math.floor(cnt / ts_diff) -- если нормализованное количество запросов не превысило лимит if cnt_norm <= limit then -- корректировка ts и cnt (если что в этих set'ах поломается - просто потом еще раз попадем в эту ветку) req_limit:set(key, cnt_norm, cnt_ttl) req_limit:set(key_ts, ngx.now() - 1, cnt_ttl) -- лок снимаем; в blacklist не добавляем; запрос не блокируем if locked then req_limit:delete(key_lock) end return false end -- превысили лимит. баним, запрос блокируем, пишем в лог req_limit:delete(key) req_limit:delete(key_ts) if locked then req_limit:delete(key_lock) end return true, cnt_norm end Кроме непосредственного бана на lua_req_ban_ttl секунд, можно реализовать постоянное хранение, а заодно прикрутить логгирование и проброс забаненных по IP в iptables/аналоги. Это уже вне темы поста. Все это, само собой, лишь пример, а не серебряная пуля-копипаста. Тем более приведенные числа лимитов указаны с потолка. Изображение в шапке взято отсюда.", "image": ["https://habrastorage.org/getpro/habr/post_images/dec/a7d/146/deca7d146accb628876bb6d464bf66d1.png"], "tag": ["lua", "nginx", "firewall"], "rating": ["+50"], "bookmarks": ["266"], "views": ["21,9k"], "comments_count": ["16"]},
{"author": ["Wedmer"], "date": ["12 октября 2014 в 01:19"], "hubs": ["Lua"], "type_label": [], "text": "Было время, когда ожидание рассмотрения ваших правок для этого проекта длилось месяцы. Некоторые патчи вообще были обделены вниманием. Trac или игнорировался, или за ним некому было следить. 10 октября эта эра завершилась. Теперь этот замечательный web-интерфейс доступен на GitHub и поддерживется основным сообществом OpenWrt. Pull-запросы рассматриваться довольно быстро. Поздравляю всех пользователей и разработчиков интерфейса с этим событием. Теперь почти все основные элементы OpenWrt доступны на GitHub, что не может не радовать. Спасибо за внимание. OpenWrt — Популярная операционная система для маршрутизаторов и встраиваемых систем. LuCI — Один из самых популярных web-интерфейсов для систем на базе OpenWrt.", "image": [], "tag": ["luci", "openwrt", "opensource"], "rating": ["+9"], "bookmarks": ["21"], "views": ["8,6k"], "comments_count": ["7"]},
{"author": ["Vavius"], "date": ["31 марта 2014 в 11:54"], "hubs": ["Lua", "Разработка игр", "Разработка мобильных приложений"], "type_label": [], "text": "Сегодня я хочу рассказать об одном малоизвестном игровом движке, который мы используем уже год для кроссплатформенной разработки мобильных игр. Для 2д он нас полностью устраивает, а единственным конкурентом может быть только Unity3d из-за своего редактора. Отсутствие должного внимания к MOAI SDK, очевидно, связано с высоким порогом входа — сами разработчики (Zipline Games) позиционируют свой продукт как «The mobile platform for pro game developers», хотя разобравшись с установкой и настройкой окружения можно очень быстро и просто клепать игры на Lua. Чем же мне так понравился MOAI: Движок написан на C++, игровая логика пишется на Lua. Есть поддержка luajit (на iOS только в режиме интерпретатора) Открытый исходный код. Лицензия CPAL — необходимо указывать логотип, название, авторов и ссылку на MOAI на загрузочном экране или в титрах Кроссплатформенный: Windows, Mac OS X, Linux, iOS, Android, OUYA, а также есть эксперименты с html5 через emscripten. Разработка поддерживается на Windows, Mac OS X и Linux. Для сборки под iOS нужен Mac. Теоретически, добавить новую платформу не сложно — надо написать «хост», который создаст OpenGL контекст и будет вызывать методы обработки ввода Lua API очень низкоуровневый. Это и плюс, и минус. Для эффективной разработки просто необходим Lua фреймворк более высокого уровня Внутри используются крутые алгоритмы и технологии. Рендерер с автоматическим батчингом (cocos2d вроде тоже этому научился). Action tree — все что периодически обновляется (анимации, физика) представлено в виде дерева, родительские узлы передают прошедшее время (дельту) своим детям; это позволяет выстраивать иерархию анимаций, останавливать и продолжать их разом, менять скорость воспроизведения Нет привычного графа сцены как в других 2д движках. Для обработки зависимостей используется dependency graph. У объектов есть множество атрибутов (координата, цвет, шейдер, ...) — можно задавать зависимости между ними, например, привязать поворот одного спрайта к координате Х другого. Движок производит рассчет только изменившихся атрибутов, что по идее уменьшает затраты на обновление. По факту это похоже на нодовую архитектуру Maya, Nuke, материалов из UE — привязывай что хочешь к чему хочешь, лишь бы тип совпадал. Есть специальный ScriptNode которому можно добавлять свои атрибуты и задавать коллбек на их обработку Несколько классов для работы с тайлмапами. Hex, diamond, rectangular сетки, поиск пути Есть поддержка 3д — то есть все трансформы и объекты по сути своей 3д Минусы и недоработки: Пробелы в документации, примеры часто нерабочие. Немногочисленное сообщество Для сборки используется Cmake. Здесь нет одной кнопки «собрать под ...» как в Юнити или Короне, часто приходится бороться с ошибками компилятора и линкера Lua api не полный. Например, часто нет баланса между сеттерами и геттерами (сеттеров больше). Поэтому полезно разбираться в написании биндингов и расширять их при необходимости Нет редактора Встроенный звуковой движок UNTZ очень примитивный. Есть биндинги к fmod, но скорее всего они сильно устарели, т.к. ими вроде как никто не пользуется Видимо, с монетизацией фреймворка у разработчиков не сложилось — делать платным и закрытым его категорически не хочется, а MOAI Cloud не оправдал себя. На всякую ерунду типа приведения в порядок документации и примеров у Zipline Games нет ни времени, ни мотивации, все в основном делается сообществом. Это не значит что MOAI SDK мертв, нет, Zipline Games используют MOAI для внутренних проектов, развитие продолжается (вот совсем недавно появилась поддержка векторных примитивов через libtess, в процессе разработки собственный движок для обработки простых столкновений, чтобы не тащить целиком box2d или chipmunk) Установка (Mac OS X) Опишу установку только на OS X, т.к. не имею под рукой windows системы. Клонируем официальный репозиторий: git clone https://github.com/moai/moai-dev.git Запускаем скрипт, который соберет хост под нашу систему: cd moai-dev bin/build-osx-sdl.sh Надеюсь все пройдет без ошибок, тогда исполняемый файл станет доступен в release/osx/host-sdl/bin/moai, сделаем на него линк (~/bin у меня добавлен в PATH): ln -s /Users/vavius/moai-dev/release/osx/host-sdl/bin/moai ~/bin/moai Запускаем пример, убеждаемся что все работает: cd samples/hello-moai moai Видим крутящуюся фиговину и приветствующий текст: Пишем на Lua Начнем с минимального примера — нарисуем квадратный спрайт по центру экрана: Код: -- 1 MOAISim.openWindow ( \"sample\", 600, 240 ) local viewport = MOAIViewport.new () viewport:setSize ( 600, 240 ) viewport:setScale ( 600, 240 ) -- 2 local layer = MOAILayer.new () layer:setViewport ( viewport ) -- 3 local renderTable = { layer } MOAIGfxDevice.getFrameBuffer ():setRenderTable ( renderTable ) -- 4 local deck = MOAIGfxQuad2D.new () deck:setTexture ( \"moai.png\" ) deck:setRect ( -64, -64, 64, 64 ) -- 5 local prop = MOAIProp.new () prop:setDeck ( deck ) layer:insertProp ( prop ) Описание происходящего по пунктам: Создаем окно и вьюпорт. Вьюпорт позволяет работать в логических координатах, не привязываясь к пикселям Слой — это контейнер для пропов (а пропами называется все что может быть нарисовано). Слою можно задать камеру, при этом будут рендериться только те пропы, которые попадают в текущий вьюпорт. Слой отвественнен за сортировку (порядок рендеринга) — есть множество вариантов, по координате X, Y, Z по отдельности или по вектору, по приоритету (целое число), а также специальный вид ISO_SORT для изометрических тайловых игр. У каждого слоя есть контейнер MOAIPartition для оптимизаций пространственных запросов — хит теста и raycast'ов, внутри используется многоуровневая сетка Задаем рендер таблицу — список renderable объектов, которые будут отрисованы во фреймбуфер по порядку. Слой при рендере рисует все добавленные в него пропы. Таблица может содержать вложенные таблицы, что очень удобно для создания менеджера сцен Deck — объект, определяющий визуальную часть. Он хранит геометрию (в данном случае квад — два треугольника), UV координаты, ссылку на текстуру и шейдер Prop — собирательный образ объекта, который рисуется на экране. Это в принципе не обязательно один отдельный спрайт, а также может быть и 3д меш и тайловая карта в зависимости от установленной деки Сразу бросается в глаза, что уж больно много строк нужно для казалось бы простой задачи нарисовать спрайт. Чаще всего это делается в одну строчку, а тут надо как минимум шесть. Поэтому, API предоставляемый движком не используется «как есть», а многие пишут свои обертки на Lua. В С++ части MOAI SDK отсутствуют многие привычные вещи такие как: кэш текстур, загрузка спрайтов из атласов, менеджер сцен и переходов между ними, всякие кнопки и другие гуи элементы. Все это предлагается реализовать на Lua. На общей производительности это врядли сильно скажется, поскольку большинство операций выполняются только при ининциализации сцены. Конечно, надо подходить с умом к написанию кода, не плодить лишних таблиц, использовать старые объекты, кэшировать что можно. Полная свобода Допустим, не хотим квадратный квад, а хотим трапецию, вместо setRect используем setQuad: local deck = MOAIGfxQuad2D.new () deck:setTexture ( \"moai.png\" ) deck:setQuad ( -64, 64, 64, 64, 100, -64, -100, -64 ) -- координаты вершин с левого верхнего угла по часовой стрелке Вот что выйдет: Замостим фон целиком нашей картинкой. Можно использовать GL_REPEAT на текстуре, но он работает только для размеров кратных степеням двойки, и картинку с атласа не получится использовать. Поэтому воспользуемся классом MOAIGrid: local deck = MOAIGfxQuad2D.new () deck:setTexture ( \"moai.png\" ) deck:setRect ( -0.5, -0.5, 0.5, 0.5 ) local grid = MOAIGrid.new () grid:initRectGrid ( 1, 1, 128, 128 ) grid:fill ( 1 ) grid:setRepeat ( true, true ) local prop = MOAIProp.new () prop:setDeck ( deck ) prop:setGrid ( grid ) layer:insertProp ( prop ) MOAIGrid нужен для работы с тайлами, здесь мы инициализируем карту из одного тайла размером 128x128. Затем ставим ему индекс 1 методом fill. Некоторые типы дек поддерживают индексацию, например MOAIGfxQuadDeck2D позволяет задавать много пар вершинных и UV координат для одной текстуры, что используется для представления спрайтового атласа. В данном случае в нашей деке есть только один единственный индекс 1. Включаем повторение и указываем пропу, что следует использовать сетку для рендеринга. На этом этапе очень просто сделать анимированный прокручивающийся фон. Добавляем одну строчку в конец: prop:moveLoc ( -128, 0, 0, 4, MOAIEaseType.LINEAR ):setMode ( MOAITimer.LOOP ) Просто в цикле двигаем наш проп на ширину одного тайла, а движок сам подставляет недостающие куски чтобы замостить весь экран: Анимация и Action tree Перемещение и вращение объектов, а также установка режимов проигрывания анимаций: local move = prop:moveLoc ( 200, 0, 0, 2 ) -- двигаем local rot = prop:moveRot ( 0, 0, 360, 2, MOAIEaseType.LINEAR ) -- крутим вокруг оси Z move:setMode ( MOAITimer.PING_PONG ) -- вперед-назад rot:setMode ( MOAITimer.LOOP ) -- цикл По умолчанию анимации добавляются к корню action tree. Но можно их группировать: local action = MOAIAction.new () action:addChild ( move ) action:addChild ( rot ) action:start () action:throttle ( 0.5 ) Теперь мы можем останавливать и запускать сразу обе анимации, а с помощью throttle задавать скорость воспроизведения. Последовательность действий реализуется через Lua корутины. MOAI предоставляет класс MOAICoroutine, унаследованный от MOAIAction, что позволяет добавлять корутины в action tree. Функция blockOnAction вызывает yield пока экшн не закончится. Двигаем картинку вправо-влево, а при достижении крайних точек делаем один полный оборот: local function func () local distance = 200 while true do local action1 = prop:moveLoc ( distance, 0, 0, 2 ) MOAICoroutine.blockOnAction ( action1 ) local action2 = prop:moveRot ( 0, 0, 360, 2 ) MOAICoroutine.blockOnAction ( action2 ) distance = -distance end end local thread = MOAICoroutine.new () thread:run ( func ) Заключение В статье рассмотрены совсем примитивные примеры — моей целью было показать некоторые аспекты Lua API, а именно его низкоуровневость и модульность. MOAI SDK старается не принимать за нас никаких решений, не заставляет все делать каким-то одним общепризнанным способом, а оставляет полную свободу. Конечно же сообщество уже реализовало несколько высокоуровневых оберток на чистом Lua, с кэшированием текстур, гуи элементами, менеджером сцен и т.д. Я бы не советовал использовать MOAI SDK в продакшене без знания С++, нюансов сборки под выбранную платформу и готовности что-то менять внутри. Практически каждый, кто использует MOAI SDK имеет свой форк, который немного отличается от главной ветки. Исторически это связано с тем, что у Zipline Games не было времени мержить пулл-реквесты. Однако, сейчас некоторые члены сообщества получили доступ к официальному репозиторию и разработка пошла бодрее. Благодаря открытости мы смогли реализовать live reload кода и ресурсов прямо на девайс. Сейчас я потихоньку пилю редактор, по образу и подобию Unity3d. Хотя дела пошли медленнее после заработавшего live reload'a — его хватает с головой для невероятного ускорения разработки. Интерфейсы собираем в векторном редакторе и экпортим сразу в код (декларативного вида, вот пример: gist.github.com/Vavius/9868572). Конечно, все это можно было приделать к любому движку, к cocos2d-x вообще без проблем, к Короне посложней, но тоже реально. Вобщем, для 2д игр пересели мы с кокоса на MOAI и нисколько не жалеем, здесь как-то все более по-взрослому, гибче и круче + код чистый и красивый. Ссылки getmoai.com — официальный сайт getmoai.com/docs/annotated.html — доки moaiwebsite.github.io — неофициальный сайт, пилится сообществом. Когда-нибудь станет новым лицом github.com/makotok/Hanappe — высокоуровневый Lua-фреймворк в ООП-стиле. Из всех подобных решений только этот сейчас развивается и поддерживается. Update: moaifiddle.com/Q09BJWGMW6/3 — js версия движка. Теперь можно поиграться с движком без установки!", "image": ["https://habrastorage.org/getpro/habr/post_images/617/3f7/d0c/6173f7d0c7b03aed02fcf856f58cb526.png", "https://habrastorage.org/getpro/habr/post_images/825/847/dec/825847decddeeca51c91a6fd43864a1a.gif", "https://habrastorage.org/getpro/habr/post_images/674/3e0/49a/6743e049a09b91b8703620c8079b57fd.png", "https://habrastorage.org/getpro/habr/post_images/ace/f98/0c8/acef980c8f09e365ad334bf86cf74043.png", "https://habrastorage.org/getpro/habr/post_images/36d/e99/81b/36de9981b2f16e5eb31467a466a5c520.png", "https://habrastorage.org/getpro/habr/post_images/295/dd5/1e3/295dd51e35a0afb2bfb4f1a20c65e991.gif", "https://habrastorage.org/getpro/habr/post_images/e10/2a4/a32/e102a4a32793484778aee9ba41d8557c.gif"], "tag": ["moai sdk", "ios", "android", "lua", "game engine"], "rating": ["+21"], "bookmarks": ["100"], "views": ["13,7k"], "comments_count": ["19"]},
{"author": ["AterCattus"], "date": [" 1 апреля 2014 в 02:26"], "hubs": ["Lua", "Ненормальное программирование"], "type_label": [], "text": "Не стоит воспринимать данный пост всерьез. Несмотря на то, что это работает, в текущем виде данное решение является исключительно забавным концептом и не более того. Так же пост ни в коей мере не является усмешкой над php, который является одним из основных моих рабочих инструментов. Думаю, что все разработчики на PHP (включая меня) так или иначе проходили через период, когда код представляет из себя жуткую смесь html и php, напиханных в одном файле. И речь не о шаблонах, а вообще о всей логике в лапше/спагетти-коде. И в качестве концепта я решил к первому апреля набросать реализацию чего-то подобного, но на lua под nginx. Прямо как на картинке. Скрипты можно писать примерно такие (ссылка, по которой отзывается данный код): <?lml tmpl:include('sugar') ?> <!DOCTYPE html> <html> <head> <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"> <title>Сейчас <?lml print(ngx.utctime()) ?></title> </head> <body> <?lml local alc = require('lib.alc') ?> Привет, <?lml print(esc(req:get('name', 'traveler')), '/', ngx.var.remote_addr) ?>. Это уже <?lml print(alc:inc('cnt')) ?> запрос с последнего перезапуска сервера. <?lml local hdrs = {} for k,v in pairs(ngx.req.get_headers()) do table.insert(hdrs, '<tr><td style=\"font-weight:bold;\">'..esc(k)..'</td><td>'..esc(v)..'</td></tr>') end ?> <h3>Заголовки <?lml print(ngx.req.get_method()) ?> запроса к <?lml print(esc(ngx.var.request_uri)) ?></h3> <table><?lml print(hdrs) ?></table> <?lml include('footer') ?> Т.е. полноценный lua в лапшастиле. Для проверки работы были реализованы: непосредственно сам «шаблонизатор»; близкий аналог APC: всякие store/fetch/cas и т.п. + compile_string/compile_file для кеширования байткода скомпилированных шаблонов; ob_* функции без поддержки вложенности (нет необходимости); всякая мелочь для замены htmlspecialchars, $_GET[name] и т.п. Возможно, кому-то будет интересно почитать о реализации. Кому же интересен только код — выложил на github, хоть там кода и кот наплакал. Вся работа основана на следующем: LUA позволяет в runtime скомпилировать исходный код, представленный строкой, в функцию (на вход строка, на выходе function (callable в терминах php/java)). За это отвечает функция loadstring; Для имеющейся function можно в runtime получить ее байткод через вызов string.dump; Получить function обратно из байткода можно через все ту же loadstring; Для кеширования в оперативке используется ngx.shared.DICT, работу с которым я уже описывал ранее; Немного кручу-верчу для соединения этого всего воедино. Для начала конфигурируем сам nginx: http { lua_shared_dict lml_shared 10m; lua_package_path '/path/to/lml/?.lua;;'; } # имя location и пути могут быть, само собой, произвольными location /lml { # грузим шаблонизатор и выводим шаблон index (по умолчанию, это файл /path/to/lml/tmpl/index.lml) content_by_lua ' local tmpl = require \"lib.tmpl\" tmpl:set_root(\"/path/to/lml/tmpl/\") tmpl:include(\"index\") '; } Обработка шаблонов простейшая: весь текст вне тегов <?lml ?> заворачивается в stdout:print(ТЕКСТ), а содержимое тегов оставляется как есть, выкидывая только сами границы тегов. HTML текст в print заворачивается в многострочные литералы, чтобы не пришлось экранировать символы внутри: stdout:print([[Hello world ]]) Но, т.к. возможна ситуация использования границ литерала внутри шаблона(Hello [[<?lml ?>]] World), то шаблонизатор ищет «свободный» вариант границ многострочного литерала, итерационно наращивая его длину: print([[...]]) print([=[...]=]) print([==[...]==]) ... Компиляция в байткод по аналогии с php вынесена из шаблонизатора в опкод кешер, бесхитростно названный ALC (Alternative Lua Cache). В самом минимальном исполнении кеширование байткода выглядит так (это крайне урезанная версия! не стоит рассматривать ее как минимальный, но рабочий пример): function M:compile_string(str, filename) local cache_key = 'tmpl_bytecode:' .. filename local bytecode, created_at = cache:get(cache_key) local lua_func = nil if not bytecode then locked = cache:add(key_lock, 1, key_lock_ttl) bytecode, created_at = cache:get(cache_key) if not bytecode then if type(str) == 'function' then str = str(filename) end lua_func = assert(loadstring(str, filename)) bytecode = assert(string.dump(lua_func)) end if locked then if lua_func and bytecode then cache:set(cache_key, bytecode, 0, ngx.now()) end cache:delete(key_lock) end end if (not lua_func) and bytecode then lua_func = loadstring(bytecode, filename) end return lua_func end Передав строку с lua кодом, на выходе получаем function, готовую для выполнения, а в оперативке у нас теперь лежит байткод. Соотвественно, в шаблонизаторе достаточно вызвать соответствуйщий метод, подсунув ему нужные данные: local function _include_string(str, filename) local lua_func = alc:compile_string(str, filename) if lua_func then lua_func() end end function M:include_string(str, filename) local succ, err = pcall(_include_string, str, filename) if not succ then ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR local errstr = 'Error (' .. filename .. '): ' .. err ngx.log(ngx.ERR, errstr) ngx.say(errstr) return ngx.exit(ngx.HTTP_OK) end return succ end -- Для загрузки из файла на диске (как раз тот случай, который используется в самих шаблонах и location nginx'а): function M:include(name) local path = root_path .. name .. file_ext M:include_string( function(filename) local str = assert(file:read_all(filename)) return assert(parse_tmpl(str, filename)) end, path ) end Передача в alc:compile_string анонимной функции вместо содержимого файла позволяет не обращаться к диску без необходимости в случае, если байткод уже есть в кеше. Получаем ленивую отложенную загрузку содержимого шаблонов только при необходимости. Вся функциональность распределена по небольшим модулям: шаблонизатор в lib.tmpl, кешер в lib.alc, вывод и буферизация вывода в lib.stdout и т.д. В шаблонах для работы с модулями в общем случае требуется явная их загрузка и обращение к функциям по полным именам: -- некий шаблон example.lml <?lml local stdout = require('lib.stdout') local html = require('lib.html') local tmpl = require('lib.tmpl') tmpl:include('header') stdout:print(html:escape(ngx.var.request_uri)) ?> Это явно и понятно, но в качестве «сахара» часть модулей сделаны обязательными и подключаются автоматически через генерацию в коде префикса с подгрузкой этих модулей: local required_libs = {'stdout', 'html', 'req', 'tmpl'} -- tmpl_chunks содержит куски lua кода, полученного из lml шаблона -- добавляем в начало кода подгрузку всех обязательных модулей for _,l in ipairs(required_libs) do table.insert(tmpl_chunks, 1, 'local '..l..' = require(\"lib.'..l..'\");') end Теперь эти модули можно сразу использовать в шаблоне: -- некий шаблон example.lml <?lml tmpl:include('header') stdout:print(html:escape(ngx.var.request_uri)) ?> В дополнение к этому были подслащены еще и наиболее часто используемые функции, такие как stdout:print, tmpl:include, html:escape. Сделано это было для примера уже на уровне lml шаблонов: -- sugar.lml <?lml function include(...) tmpl:include(...) end function print(...) stdout:print(...) end function esc(...) return html:escape(...) end ?> -- некий шаблон example.lml <?lml tmpl:include('sugar') include('header') print(esc(ngx.var.request_uri)) ?> Данное решение является палкой о двух концах и сделано для приведения кода шаблонов ближе к стилистике php. В заключение сферический тест производительности данного велосипеда в сравнении с php-fpm+apc на простейшем «домашнем сервачке» с Athlon II, ссылка на который приведена в начале поста. Сравнение происходило со столь же примитивным php кодом из 3х файлов с максимальной адаптацией. Пока что тестировал через siege по 100Мбит локалке, так что кое где производительность упиралась в сетку. Запуск через siege -cX -t300S -b URL показал следующие trans/sec: -c10 -c100 -c200 -c500 php-fpm 3350 3150 уперся в cpu http 502 * http 502 * lml без опкешера не тестил 6950 не тестил не тестил lml с опкешером 7000 8100 уперся в сеть 8200 уперся в сеть 7500 уперся в сеть * массовые connect() to unix:/var/run/php-fpm-*.sock failed (11: Resource temporarily unavailable) Вроде не так и ужасно. Еще раз ссылка на github, если кто упустил или начал с конца, но хочет грянуть подробности. Всем желаю не поддаваться на провокации :)", "image": ["https://habrastorage.org/getpro/habr/post_images/435/ce8/ddd/435ce8ddd6c18bd0a3174c9a6a9eeaee.png"], "tag": ["lua", "nginx", "spaghetti", "спагетти-код", "спагетти", "лапша", "1е апреля"], "rating": ["+26"], "bookmarks": ["80"], "views": ["12,7k"], "comments_count": ["21"]},
{"author": ["Lerg"], "date": ["26 апреля 2014 в 14:54"], "hubs": ["Go", "Lua", "Разработка мобильных приложений"], "type_label": ["Tutorial"], "text": "1. Введение Данный проект представляет собой простой пример использования Google App Engine в мобильном приложении. Cерверная часть предоставляет список пингвинов в формате JSON. Мобильный клиент запрашивает этот список по HTTP или HTTPS. Также серверная часть ведёт запись определённых событий в базу данных, а именно количество посещений конкретного пингвина и количество нажатий кнопок: скормить рыбку и почесать животик. У каждого пингвина есть поля описания Name, Bio и поля счётчиков. 2. Тонкости перевода Думал как можно перевести Penguin Daycare Simulator на русский язык, но «детский сад» в качестве «daycare» не подходит, «дневной уход» тоже. Поэтому так и осталось без перевода. 3. Подготовка Если у вас не установлен Google App Engine Go SDK, то переходите по ссылке Google App Engine, нажимайте «Try it now» и следуйте всем пунктам. Дайте имя своему проекту, выберите Go, скачайте и установите SDK. Убедитесь, что у вас корректно установлены переменные окружения (PATH, GOROOT, GOPATH, APPENGINE_DEV_APPSERVER), для этого в терминале у вас должна быть видна команда goapp. Забегая вперёд, скажу, что для загрузки простого проекта на сервер GAE и его запуска нужно выполнить команду goapp deploy в директории проекта. Она спросит у вас email гугло-аккаунта, на котором должен быть расположен проект. Важно чтобы имя проекта совпадало в app.yaml и на сайте. Но в данном проекте используются модули и процесс загрузки несколько отличается. В качестве IDE для Go я рекомендую LiteIDE, а для Lua и Corona SDK — ZeroBrane Studio. Скачать Corona SDK можно на их сайте. 4. Клинт-сервер На картинке ниже представлена очень сложная схема общения между клиентом (слева) и сервером (справа). Как видно клиент запрашивает только список пингвинов и отсылает только три события. Общение ведётся по HTTP, но можно использовать и HTTPS совершенно бесплатно. Это можно отнести к одному из плюсов использования GAE — нет необходимости платить за SSL сертификат и настраивать работу с ним. Так как всё работает по HTTP, то можно непосредственно в браузере выполнять запросы без использования специального клиента. penguin-daycare-simulator.appspot.com Простое приветствие, не используется мобильным клиентом, но позволяет сказать работает ли сервис. Можете заменить http на https и убедиться, что так тоже работает. penguin-daycare-simulator.appspot.com/penguins Это самый важный запрос. С его помощью мобильный клиент получает список всех пингвинов, которые в данный момент находятся под присмотром. Для более удобного просмотра этих данных я рекомендую расширение JSONview для Chrome. penguin-daycare-simulator.appspot.com/stat/visit penguin-daycare-simulator.appspot.com/stat/fish penguin-daycare-simulator.appspot.com/stat/bellyrub Эти три запроса увеличивают соответствующие счётчики для какого-либо пингвина. Id пингвина передаётся в качестве POST параметра. Сервер ничего в ответ не возвращает, но вы можете, если хотите, добавить в ответ строку «OK» или другой сигнал успешного выполнения операции. 5. Ещё скриншоты, больше скриншотов! Уже перед публикацией статьи, вспомнил про этого пингвинчика: Смотреть позитиватор 6. Серверная часть — Google App Engine Теперь можем перейти непосредственно к коду. Рассмотрим файловую структуру проекта на Go. PenguinDaycareSimulatorServer/ ├── default/ │ ├── app.go │ ├── default.yaml │ └── penguins.json ├── static/ │ ├── favicon.ico │ └── static.yaml └── dispatch.yaml default и static — это модули. Проект для GAE может быть разбит на модули, а может работать и без них. В этом случае нужны только три файла: app.yaml, app/app.go и penguins.json. Изначально так и было в моём проекте (можно посмотреть первый коммит на GitHub), но мне захотелось добавить настройку max_concurrent_requests, которая отвечает за то, сколько одновременных запросов может обрабатывать один instance вашего приложения. Значение по умолчанию — всего 10. Go явно способен на большее. Максимальное значение — 500. При росте нагрузки и превышении этого значения, запускаются дополнительные копии вашего приложения и нагрузка распределяется между ними. Если хотите укладываться только в бесплатные квоты для GAE, то использование этой настройки крайне желательно. Если приложение не справляется с такой нагрузкой, то снижайте это значение и переходите на платный биллинг. Так вот эта настройка доступна только для модулей. И в вашем приложении должно быть минимум 2 модуля, чтобы GAE посчитал его модульным. static — очень простой модуль, без которого можно было бы и обойтись (если бы не ограничение GAE выше), его задача только в том, чтобы отдавать статично файл favicon.ico. default — основной модуль, который и выполняет всю работу. Файлы *.yaml — это настройки и описания. По одному на каждый модуль и один файл dispatch.yaml, который описывает какие URL какой модуль обрабатывает. dispatch.yamlapplication: penguin-daycare-simulator dispatch: - url: \"*/favicon.ico\" module: static - url: \"*/\" module: default static.yamlapplication: penguin-daycare-simulator module: static version: 1 runtime: python27 api_version: 1 threadsafe: true handlers: - url: /favicon.ico static_files: favicon.ico upload: favicon.ico default.yamlapplication: penguin-daycare-simulator module: default version: 1 runtime: go api_version: go1 automatic_scaling: max_concurrent_requests: 500 handlers: - url: /.* script: _go_app Обратите внимание, что в static.yaml runtime указан Python, а не Go. Это сделано потому, что GAE ругается, если пытаетесь загрузить модуль на Go без собственно Go файлов. Однако он не ругается на Python и PHP при такой ситуации. off topicВнимательный читатель здесь может возразить мол «чем PHP хуже Python для отдачи статичных файлов» и попытаться развязать holywar, но Python лично мне ближе, поэтому и выбрал его. Любой другой может использовать PHP для этих целей. Конечно, это всё бессмысленно, так как ни Python, ни PHP не участвуют в этом процессе. handlers в default.yaml указывает какие исполняемые файлы обрабатывает определённые URL. В нашем случае app.go обрабатывает все приходящие запросы (с учётом dispatch.yaml). Описание URL очень гибкое, использует регулярные выражения. Однако если для Python и PHP можно использовать разные файлы для обработки разных URL внутри одного модуля, то для Go это должен быть один единственный файл, который обозначается как \"_go_app\". Дальше уже внутри программы на Go можно выделить обработчики для разных URL и разбить всё приложение на несколько файлов, если необходимо. Больше про настройку и yaml файлы можно почитать тут. penguins.json — файл в формате JSON, содержащий в себе имена и описание всех используемых пингвинов. penguins.json[ {\"id\": \"1\", \"name\": \"Tux\", \"bio\": \"Beloved Linux mascot\" }, {\"id\": \"2\", \"name\": \"Skipper\", \"bio\": \"Small combat squad leader\" }, {\"id\": \"3\", \"name\": \"Lolo\", \"bio\": \"Russian adventurer\" }, {\"id\": \"4\", \"name\": \"Gunter\", \"bio\": \"The darkest character in Adventure Time\" }, {\"id\": \"5\", \"name\": \"The Penguin\", \"bio\": \"Na, na, na, na, na, na, na, na, na, na... The Penguin! \" } ] Добавление, редактирование пингвинов происходит через этот файл. Теперь мы подошли к app.go — сердцу всего приложения. Полный листинг удобно смотреть сразу на GitHub — app.go. Упрощённая структура этого файла: package app Перечисление всех используемых библиотек. import (...) Структура каждого пингвина: Id, имя, описание, счётчики. type penguin struct {...} Слайс (массив) всех пингвинов. var penguins []penguin Структура записи в базу данных. type penguinEntity struct {...} Инициализация. func init() {...} Чтение penguins.json в слайс penguins. func loadPenguinsJson() {...} Обработчик / - вывод простого сообщения. func rootHandler(w http.ResponseWriter, r *http.Request) {...} Обработчик /penguins - вывод всех пингвинов со статистикой в формате JSON. func penguinsHandler(w http.ResponseWriter, r *http.Request) {...} Обработчик события /stat/visit - посещение пингвина. func visitHandler(w http.ResponseWriter, r *http.Request) {...} Обработчик события /stat/fish - кормление пингвина рыбкой. func fishHandler(w http.ResponseWriter, r *http.Request) {...} Обработчик события /stat/bellyrub - почёсывание пингвина по животику. func bellyrubHandler(w http.ResponseWriter, r *http.Request) {...} При запуске приложения первым делом запускается функция init(), которая производит чтение из файла penguins.json и устанавливает какая функция в ответе за разные запросы со стороны клиента. Вы уже могли ими воспользоваться по ссылкам в начале статьи. penguinsHandler() сериализует слайс penguins в JSON формат функцией json.Marshal() и отдаёт клиентам через fmt.Fprint(). visitHandler(), fishHandler(), bellyrubHandler() действуют по одной логике — берём пингвина из базы данных, увеличиваем на единицу соответствующий параметр и записываем обратно в базу данных. База данных — Datastore — не является SQL совместимой, то есть она представляет собой NoSQL решение. Описание её работы достойно отдельной статьи. Так как многие операции на GAE тарифицируются отдельно, в том числе и доступ к Datastore, то следует избегать излишнего использования ресурсов. Так, например, при запросе статистики по всем пингвинам совершенно необязательно предоставлять актуальные данные. Можно кэшировать этот запрос с временем жизни кэша скажем 10 минут. Для этого я ввёл дополнительную переменную lastUpdateTime — метку времени последнего обновления слайса penguins. А при каждом запросе /penguins я вызываю функцию updatePenguinsStatistics(), которая проверяет не истекло ли время жизни кэша и в цикле обновляет показания счётчиков для каждого пингвина в слайсе penguins. Чтобы форсировать обновление вручную, я ввёл дополнительный запрос /update и соответствующий обработчик updateHandler(). Каждый запрос обрабатывается в собственной goroutine, поэтому нужно защитить слайс penguins от возможной одновременной записи или чтения во время записи. Для этого используется RWMutex — мьютекс на чтение или запись. Его использование более эффективно, чем простого Mutex. Для избежания платного потребления ресурсов, можно также ввести отложенную запись в базу данных, накапливая значения всех поступивших событий. Для загрузки проекта на сервер GAE нужно выполнить три команды в терминале в директории проекта: goapp deploy default/default.yaml goapp deploy static/static.yaml appcfg.py update_dispatch . В дальнейшем при изменении app.go, необходимо только будет запускать goapp deploy default/default.yaml. В заключении про серверную часть скажу, что для увеличения бесплатных лимитов я рекомендую подключить платный биллинг, но при этом задать максимальную стоимость в день равную $1. При этом некоторые бесплатные квоты увеличиваются, а вы всё ещё ничего не тратите. 7. Клиентская часть — Corona SDK Corona SDK — это кроссплатформенный фреймворк для разработки мобильный приложений под Android, iOS, Windows Phone (скоро) и HTML5 (в разработке). Использую данный продукт уже довольно давно, пишу игры как для клиентов в качестве фрилансера, так и для себя. Отмечу достойную скорость работы и быстроту создания приложений. Начнём тоже с файловой структуры проекта. Файлов здесь больше, в основном за счёт иконок и картинок, поэтому убираю под спойлер. файловая структураPenguinDaycareSimulator/ ├── images/ │ ├── penguins/ │ │ ├── 1.png │ │ ├── 1@2x.png │ │ ├── 2.png │ │ ├── 2@2x.png │ │ ├── 3.png │ │ ├── 3@2x.png │ │ ├── 4.png │ │ ├── 4@2x.png │ │ ├── 5.png │ │ └── 5@2x.png │ ├── background.jpg │ ├── background@2x.jpg │ ├── button-over.png │ ├── button-over@2x.png │ ├── button.png │ ├── button@2x.png │ ├── dot-off.png │ ├── dot-off@2x.png │ ├── dot.png │ ├── dot@2x.png │ ├── fish.png │ ├── fish@2x.png │ ├── hand.png │ ├── hand@2x.png │ ├── popup.png │ └── popup@2x.png ├── lib/ │ ├── api.lua │ ├── app.lua │ └── utils.lua ├── scenes/ │ ├── choose.lua │ ├── menu.lua │ └── penguin.lua ├── Default-568h@2x.png ├── Icon-60.png ├── Icon-60@2x.png ├── Icon-72.png ├── Icon-72@2x.png ├── Icon-76.png ├── Icon-76@2x.png ├── Icon-Small-40.png ├── Icon-Small-40@2x.png ├── Icon-Small-50.png ├── Icon-Small-50@2x.png ├── Icon-Small.png ├── Icon-Small@2x.png ├── Icon-hdpi.png ├── Icon-ldpi.png ├── Icon-mdpi.png ├── Icon-ouya.png ├── Icon-xhdpi.png ├── Icon-xxhdpi.png ├── Icon.png ├── Icon@2x.png ├── build.settings ├── config.lua └── main.lua Можете пока обратить внимание только на Lua файлы. config.lua, build.settings — файлы настройки проекта для Corona SDK. Указывают портретный или ландшафтный вид имеет приложение, опорное разрешение экрана, способ масштабирования и другие разные настройки. Если Corona SDK для вас в новинку, то можете не обращать пока внимание на эти файлы. Также в корне вы найдёте кучу иконок под iOS и Android, плюс Default-568h@2x.png для корректной работы на iPhone 5. Внутри директории images/ есть обычные файлы и их удвоенные HD версии @2x. Сейчас в принципе уже можно не поддерживать устройства с экранами вроде iPhone 3GS, их процент очень мал, но тем не менее отличен от нуля. Для полноценной поддержки iPad Retina вам уже нужны будут @4x файлы и строчка в config.lua, но большинство игр и так нормально работают. Corona SDK запускает приложение начиная с файла main.lua, в нём подключаются нужные библиотеки, объявляются некоторые переменные и происходит переход на сцену с кнопкой «Enter the Daycare». Все сцены (экраны) приложения хранятся в разных файлах и собраны в директории scenes/, а все пользовательские библиотеки я разместил в lib/. Разработчик волен располагать эти файлы как ему захочется, я предпочитаю так. В lib/ находятся app.lua и utils.lua — вместе это мой сборник полезных функций для работы с Corona SDK. В app.lua реализованы удобные обёртки над стандартными функциями Corona SDK для отображения картинок, текста, кнопок и др. Переход из main.lua в scenes/menu.lua осуществляется через строчку storyboard.gotoScene('scenes.menu') Где, в свою очередь, уже выполняется запрос пингвинов на сервере. Вот основной кусок кода из menu.lua. function scene:createScene (event) local group = self.view app.newText{g = group, text = 'Penguin Daycare', size = 32, x = _CX, y = _CY - 150} app.newText{g = group, text = 'Simulator', size = 32, x = _CX, y = _CY - 110} local pleaseWait = app.newText{g = group, text = 'Please Wait', size = 16, x = _CX, y = _CY} local button = app.newButton{g = group, x = _CX, y = _CY, text = 'Enter the Daycare', onRelease = function() storyboard.gotoScene('scenes.choose', {effect = 'slideLeft', time = app.duration}) end} button.isVisible = false app.api:getPenguins(function() pleaseWait.isVisible = false button.isVisible = true end) end Создаются три строчки текста и одна кнопка. Кнопка спрятана до тех пор, пока мы не получим ответ от сервера. Сам запрос выполняется функцией app.api:getPenguins(), в качестве аргумента у неё callback-функция. После нажатия на кнопку мы попадаем на сцену выбора пингвина, тоже приведу только основную часть кода из файла choose.lua. function scene:createScene(event) local group = self.view self.backButton = app.newButton{g = group, x = _L + 10, y = _T + 10, w = 48, h = 32, rp = 'TopLeft', text = 'Back', fontSize = 14, onRelease = function() storyboard.gotoScene('scenes.menu', {effect = 'slideRight', time = app.duration}) end} local function gotoPenguin(ind) storyboard.gotoScene('scenes.penguin', {effect = 'slideLeft', time = app.duration, params = ind}) end local slideView = newSlideView{g = group, x = 0, y = _CY, dots_y = 180, onRelease = gotoPenguin} for i = 1, #app.api.penguins do local p = app.api.penguins[i] local slide = display.newGroup() app.newImage('images/popup.png', {g = slide, w = 300, h = 335}) app.newImage('images/penguins/' .. p.id .. '.png', {g = slide, w = 200, h = 256}) app.newText{g = slide, x = 0, y = -140, text = p.name, size = 18, color = 'white'} app.newText{g = slide, x = 0, y = 140, text = p.bio, size = 14, color = 'white', w = 220, align = 'center'} slideView:addSlide(slide) end slideView:makeDots() slideView:gotoSlide(1) end Здесь newSlideView() это функция, создающая простой виджет, с помощью которого можно пролистывать слайды с пингвинами. Код этого виджета располагается тут же в choose.lua в начале файла. Для каждого пингвина создаётся слайд. Изображения пингвинов хранятся внутри приложения и соответствуют Id пингвинов. Это дело можно исправить путём хранения изображений на сервере GAE или любом другом. Для загрузки картинок из сети в Corona SDK есть функция display.loadRemoteImage() или более низкоуровневая network.download(). По нажатию на слайд вызывается функция gotoPenguin(), которая получает номер (не Id) пингвина в массиве (table) всех полученных пингвинов. Эта функция производит переход на заключительную сцену penguin.lua, передавая этой сцене тот же самый аргумент. penguin.luafunction scene:createScene(event) local group = self.view local background = app.newImage('images/background.jpg', {g = group, w = 384, h = 640, x = _CX, y = _CY}) self.backButton = app.newButton{g = group, x = _L + 10, y = _T + 10, w = 48, h = 32, rp = 'TopLeft', text = 'Back', fontSize = 14, onRelease = function() storyboard.gotoScene('scenes.choose', {effect = 'slideRight', time = app.duration}) end} local ind = event.params local p = app.api.penguins[ind] local visitsLabel = app.newText{g = group, x = _CX, y = _T + 20, text = 'Visits: ' .. p.visit_count, size = 18, color = 'white'} local fishLabel = app.newText{g = group, x = _CX, y = _T + 40, text = 'Fish: ' .. p.fish_count, size = 18, color = 'white'} local bellyrubsLabel = app.newText{g = group, x = _CX, y = _T + 60, text = 'Belly rubs: ' .. p.bellyrub_count, size = 18, color = 'white'} local penguin = app.newImage('images/penguins/' .. p.id .. '.png', {g = group, w = 200, h = 256, x = _CX, y = _CY - 25}) app.newButton{g = group, x = _CX - 80, y = _B - 50, w = 128, h = 48, text = 'Fish', fontSize = 14, onRelease = function() local fish = app.newImage('images/fish.png', {g = group, x = penguin.x, y = penguin.y + 200, w = 512, h = 188}) fish.alpha = 0.8 transition.to(fish, {time = 400, alpha = 1, y = penguin.y, xScale = 0.1, yScale = 0.1, transition = easing.outExpo, onComplete = function(obj) transition.to(fish, {time = 400, alpha = 0, onComplete = function(obj) display.remove(obj) end}) end}) app.api:sendFish(p.id) p.fish_count = p.fish_count + 1 fishLabel:setText('Fish: ' .. p.fish_count) end} app.newButton{g = group, x = _CX + 80, y = _B - 50, w = 128, h = 48, text = 'Belly rub', fontSize = 14, onRelease = function() local hand = app.newImage('images/hand.png', {g = group, x = penguin.x - 40, y = penguin.y + 30, w = 80, h = 80, rp = 'TopLeft'}) transition.to(hand, {time = 1200, x = penguin.x + 40, transition = easing.swing3(easing.outQuad), onComplete = function(obj) display.remove(obj) end}) app.api:sendBellyrub(p.id) p.bellyrub_count = p.bellyrub_count + 1 bellyrubsLabel:setText('Belly rubs: ' .. p.bellyrub_count) end} app.api:sendVisit(p.id) p.visit_count = p.visit_count + 1 visitsLabel:setText('Visits: ' .. p.visit_count) end В penguin.lua происходит загрузка фонового изображения, изображения выбранного пингвина, отображение нескольких текстовых меток и двух кнопок-действий. При нажатии на них происходит анимация действия и отправка запроса на сервер через функции app.api:sendFish() и app.api:sendBellyrub(). А app.api:sendVisit() вызывается сразу после создания сцены. После вызова каждой из этих функций обновляются соответствующие текстовые метки, даже если нет интернета. Это можно исправить, введя проверку на получение ответа от сервера по каждому запросу и предоставляя callback-функции. Наконец, вся работа с сервером осуществляется в файле lib/api.lua. api.lualocal _M = {} local app = require('lib.app') _M.hostname = 'http://penguin-daycare-simulator.appspot.com' function _M:getPenguins(callback) local url = '/penguins#' .. math.random(1000, 9999) network.request(self.hostname .. url , 'GET', function (event) if not event.isError then local response = json.decode(event.response) if response then self.penguins = response callback() end end end) end function _M:sendVisit(id) local url = '/stat/visit' local request = {body = 'id=' .. id} network.request(self.hostname .. url , 'POST', function (event) if event.isError then app.alert('Network error') end end, request) end function _M:sendFish(id) local url = '/stat/fish' local request = {body = 'id=' .. id} network.request(self.hostname .. url , 'POST', function (event) if event.isError then app.alert('Network error') end end, request) end function _M:sendBellyrub(id) local url = '/stat/bellyrub' local request = {body = 'id=' .. id} network.request(self.hostname .. url , 'POST', function (event) if event.isError then app.alert('Network error') end end, request) end return _M Как можно было догадаться, работа с сервером производится простыми POST запросами. В случае getPenguins(), ответ от сервера конвертируется из JSON формата в массив (table) функцией json.decode() и помещается в поле (property) модуля. Как видите, посылать POST запросы и реагировать на их ответы в Corona SDK очень просто. Соответственно очень простая вышла и сама интеграция с Google App Engine. Я не расписываю что делает каждая строчка, надеюсь синтаксис интуитивно понятен. 8. Ссылки Исходники лежат у меня на GitHub: Google App Engine — github.com/Lerg/PenguinDaycareSimulatorServer Corona SDK — github.com/Lerg/PenguinDaycareSimulator Можно установить клиентскую часть на Android 2.3.3+, вот APK (mirror). Либо скачивайте Corona SDK, скачивайте исходники с GitHub и запускайте в Corona Simulator. Спасибо M0sTH8 за помощь в написании статьи. Подписывайтесь на мой твиттер @SergeyLerg На этом всё. Спасибо за внимание!", "image": ["https://habrastorage.org/getpro/habr/post_images/01f/d8f/666/01fd8f6669207a22ce0a776cf8ac7b6b.jpg", "https://habrastorage.org/getpro/habr/post_images/651/409/1fc/6514091fcdecb8b9d7517b9856a420da.jpg", "https://habrastorage.org/getpro/habr/post_images/87d/c76/d41/87dc76d41075ec775ddd22dd8ac37126.jpg", "https://habrastorage.org/getpro/habr/post_images/f4f/bd6/465/f4fbd6465a0d11fb23417805e9936a3e.jpg"], "tag": ["go", "lua", "game development", "google app engine", "corona sdk", "погладь пингвина!"], "rating": ["+15"], "bookmarks": ["53"], "views": ["7,4k"], "comments_count": []},
{"author": ["HotWaterMusic"], "date": ["25 июня 2013 в 09:37"], "hubs": ["Lua"], "type_label": [], "text": "Для всех, кто хотел разобраться с Lua (скриптовый язык для разработки игр и не только, список), но никак не находил времени, Tyler Neylon приготовил небольшой подарок: http://tylerneylon.com/a/learn-lua/ Посвящается всем, кто предпочитает один большой список из говорящих самих за себя сниппетов кода (с небольшими комментариями к 95% case'ов) длинным мануалам с огромной иерархией. Очень удобно для тех, кто уже умеет программировать и просто хотел бы разобраться с новым для себя языком. Весь «мега-сниппет» на английском, но примеры несложно читаются. P.S. А для всего остального есть Hyperpolyglot.", "image": ["https://habrastorage.org/getpro/habr/post_images/583/997/437/58399743777ce920d03affdb72f9c25b.png"], "tag": ["топик-ссылка", "lua", "обучение"], "rating": ["+67"], "bookmarks": ["564"], "views": ["140k"], "comments_count": ["49"]},
{"author": ["Izaron"], "date": ["14 октября 2013 в 20:13"], "hubs": ["Lua", "Разработка игр", "C++"], "type_label": ["Tutorial"], "text": "Добрый день, Хабрахабр! Решил написать этот топик на тему скриптов Что нужно знать? С++ на приличном уровне (в уроке будут шаблоны — template) Lua, очень легкий скриптовый язык. Советую этот урок. Почему писать диалоги игры в .cpp файле было большой ошибкой Если вы разрабатывали большие проекты (к примеру, масштабные игры), замечали, что с каждой новой сотней строк кода компиляция идет медленней? В игре создается больше оружия, больше диалогов, больше меню, больше etc. Одна из самых главных проблем, возникающих в связи с нововведениями — поддерживать бессчетное множество оружия и бейджиков довольно сложное занятие. В ситуации, когда просьба друга/босса/напарника изменить диалог или добавить новый вид оружия занимает слишком много времени, приходится прибегать к каким-то мерам — например, записи всей этой фигни в отдельные текстовые файлы. Почти каждый геймдевелопер когда-нибудь делал карту уровней или диалоги в отдельном текстовом файле и потом их считывал. Взять хотя бы простейший вариант — олимпиадные задачи по информатике с файлом ввода Но есть способ, на голову выше — использование скриптов. Решение проблемы «Окей, для таких дел хватает обычного файла с описанием характеристиков игрока. Но что делать, если в бурно развивающемся проекте почти каждый день приходится немножко изменять логику главного игрока, и, следовательно, много раз компилировать проект?» Хороший вопрос. В этом случае нам на помощь приходят скрипты, держащие именно логику игрока со всеми характеристиками либо какой-либо другой части игры. Естественно, удобнее всего держать, логику игрока в виде кода какого-нибудь языка программирования. Первая мысль — написать свой интерпретатор своего скриптового языка, выкидывается из мозга через несколько секунд. Логика игрока определенно не стоит таких жутких затрат. К счастью, есть специальные библиотеки скриптовых языков для С++, которые принимают на вход текстовый файл и выполняют его. Об одном таком скриптовом языке Lua пойдет речь. Как это работает? Прежде чем начать, важно понимать, как работает скриптовый язык. Дело в том, что в скриптовых языках есть очень мало функций, при наличии конструкций for, while, if, прочих. В основном это функции вывода текста в консоль, математические функции и функции для работы с файлами. Как же тогда можно управлять игроком через скрипты? Мы в С++-программе делаем какие-либо функции, «регистрируем» их под каким-нибудь именем в скрипте и вызываем в скрипте. То есть если мы зарегистрировали функцию SetPos(x,y) для определения позиции игрока в С++-программе, то, встретив эту функцию в скрипте, «интерпретатор» из библиотеки скриптового языка вызывает эту функцию в С++-программе, естественно, с передачей всех методов. Удивительно, да? :) UPD: Внимание! Один юзер обратился мне с мейлом, что, когда я заливал код, я не полностью устранил все ошибки — habrahabr.ru/post/196272/#comment_6850016 В коде с позволения хабра проникли жучки Замените участки кода вроде template<class t> T MethodName(); На template<class T> T MethodName(); И еще вместо lua_CFunction проскакивает lua_cfunction Спасибо! Я готов! Когда вы поняли преимущества скриптовых языков программирования, самое время начать работать! Скачайте из репозитория на гитхабе (низ топика) lib'у и includ'ы Lua, либо возмите их на официальном сайте. Создаем консольный проект либо Win32 (это неважно) в Visual Studio (у меня стоит версия 2012) Заходим в Проект->Свойства->Свойства конфигурации->Каталоги VC++ и в «каталоги включения» и «каталоги библиотек» добавьте папку Include и Lib из репозитория соответственно. Теперь создаем файл main.cpp, пишем в нем: int main() { return 0; } Как вы догадались, у меня консольное приложение. Теперь переходим к кодингу Обещаю, что буду тщательно объяснять каждый момент У нас за скрипты будет отвечать класс Script. Я буду объявлять и одновременно реализовывать функции в Script.h/.cpp Создаем Script.cpp и пишем в нем #include \"Script.h\" Создаем Script.h и пишем в нем #ifndef _SCRIPT_H_ #define _SCRIPT_H_ #endif После 2 строчки и перед #endif мы определяем класс скриптов Этот код пишется для предотвращения взаимного включения файлов. Допустим, что файл Game.h подключает Script.h, а Script.h подключает Game.h — непорядок! А с таким кодом включение выполняется только 1 раз Теперь пишем внутри этого кода вот это #pragma comment(lib,\"lua.lib\") extern \"C\" { #include <lua.h> #include <lualib.h> #include <lauxlib.h> } Первая строчка подключает сам lua.lib из архива. Для чего нужен extern «C»? Дело в том, что lua написан на С и поэтому такой код необходим для подключения библиотек. Дальше идет подключение хорошо известных многим файлов для работы с консолью #include <stdio.h> #include <iostream> #include <sstream> using namespace std; Теперь приступим к определению класса class Script { Самый главный объект библиотеки Lua для C++ — lua_State, он необходим для выполнения скриптов private: lua_State *lua_state; Дальше идут публичные функции public: void Create(); Эта функция инициализирует lua_State Create()Его определение в Script.cpp void Script::Create() { lua_state = luaL_newstate(); static const luaL_Reg lualibs[] = { {\"base\", luaopen_base}, {\"io\", luaopen_io}, {NULL, NULL} }; for(const luaL_Reg *lib = lualibs; lib->func != NULL; lib++) { luaL_requiref(lua_state, lib->name, lib->func, 1); lua_settop(lua_state, 0); } } Первой строчкой мы инициализируем наш lua_State. Потом мы объявляем список «подключенных библиотек». Дело в том, что в «чистом» виде в луа есть только функция print(). Для математических и прочих функций требуется подключать специальные библиотеки и потом вызывать их как math.foo, base.foo, io.foo. Для подключения других библиотек добавьте в lualibs, например, {«math», luaopen_math}. Все названия библиотек начинаются с luaopen_..., в конце lialibs должен стоять {NULL,NULL} void Close(); Эта функция освобождает ресурсы Lua Close()Ее определение void Script::Close() { lua_close(lua_state); } Просто используем lua_close() int DoFile(char* ScriptFileName); А эта функция выполняет файл. На вход она принимает название файла, например, «C:\\\\script.lua». Почему она возвращает int? Просто некоторые скрипты могут содержать return, прерывая работу скрипта и возвращая какое-нибудь значение. DoFile()Ее определение int Script::DoFile(char* ScriptFileName) { luaL_dofile(lua_state,ScriptFileName); return lua_tointeger(lua_state, lua_gettop(lua_state)); } Как вы видите, я выполняю скрипт и возвращаю int. Но возращать функция может не только int, но еще и bool и char*, просто я всегда возвращаю числа (lua_toboolean, lua_tostring) Теперь мы сделаем функцию, регистрирующую константы (числа, строки, функции) template<class t> void RegisterConstant(T value, char* constantname); RegisterConstant()Мы действуем через шаблоны. Пример вызова функции: RegisterConstant<int>(13,\"goodvalue\"); Ее определение template<> void Script::RegisterConstant<int>(int value, char* constantname) { lua_pushinteger(lua_state, value); lua_setglobal(lua_state,constantname); } template<> void Script::RegisterConstant<double>(double value, char* constantname) { lua_pushnumber(lua_state, value); lua_setglobal(lua_state,constantname); } template<> void Script::RegisterConstant<char>(char* value, char* constantname) { lua_pushstring(lua_state, value); lua_setglobal(lua_state,constantname); } template<> void Script::RegisterConstant<bool>(bool value, char* constantname) { lua_pushboolean(lua_state, value); lua_setglobal(lua_state,constantname); } template<> void Script::RegisterConstant<lua_cfunction>(lua_CFunction value, char* constantname) { lua_pushcfunction(lua_state, value); lua_setglobal(lua_state,constantname); } Для каждого возможного значения class T мы определяем свои действия. *Капитан* последнее определение — регистрация функции Функции, годные для регистрации, выглядят так: int Foo(lua_State*) { // ... return n; } Где n — количество возвращаемых значений. Если n = 2, то в Луа можно сделать так: a, b = Foo() Читайте мануалы по Луа, если были удивлены тем, что одна функция возвращает несколько значений :) Следующая функция создает таблицу для Луа. Если непонятно, что это значит, то тамошная таблица все равно что массив void Array(); Array()Ее описание void Script::Array() { lua_createtable(lua_state, 2, 0); } Следующая функция регистрирует элемент в таблице. template<class t> void RegisterConstantArray(T value, int index); RegisterConstantArray()Ее описание template void Script::RegisterConstantArray<int>(int value, int index) { lua_pushnumber(lua_state, index); lua_pushinteger(lua_state, value); lua_settable(lua_state, -3); } template void Script::RegisterConstantArray<double>(double value, int index) { lua_pushnumber(lua_state, index); lua_pushnumber(lua_state, value); lua_settable(lua_state, -3); } template void Script::RegisterConstantArray<char>(char* value, int index) { lua_pushnumber(lua_state, index); lua_pushstring(lua_state, value); lua_settable(lua_state, -3); } template void Script::RegisterConstantArray<bool>(bool value, int index) { lua_pushnumber(lua_state, index); lua_pushboolean(lua_state, value); lua_settable(lua_state, -3); } template void Script::RegisterConstantArray<lua_cfunction>(lua_CFunction value, int index) { lua_pushnumber(lua_state, index); lua_pushcfunction(lua_state, value); lua_settable(lua_state, -3); } Если вы не знаете Lua, вы, наверное, удивлены тем, что в один массив помещается столько типов? :) На самом деле в элементе таблицы может содержаться еще и таблица, я так никогда не делаю. Наконец, заполненную таблицу нужно зарегистрировать void RegisterArray(char* arrayname); RegisterArray()Ее описание void Script::RegisterArray(char* arrayname) { lua_setglobal(lua_state, arrayname); } Ничего особенного нет Следующие функции предназначены в основном только для функций типа int foo(lua_State*), которые нужны для регистрации в Луа. Первая из них — получает количество аргументов int GetArgumentCount(); Create()Ее описание int Script::GetArgumentCount() { return lua_gettop(lua_state); } Эта функция нужна, например, для функции Write(), куда можно запихать сколь угодно аргументов, а можно и ни одного Подобную функцию мы реализуем позже Следующая функция получает аргумент, переданный функции в скрипте template<class t> T GetArgument(int index); GetArgument()Ее описание template int Script::GetArgument<int>(int index) { return lua_tointeger(lua_state,index); } template double Script::GetArgument<double>(int index) { return lua_tonumber(lua_state,index); } template char* Script::GetArgument<char>(int index) { return (char*)lua_tostring(lua_state,index); } template bool Script::GetArgument<bool>(int index) { return lua_toboolean(lua_state,index); } Можно получить все типы, описывавшиеся ранее, кроме таблиц и функций index — это номер аргумента. И первый аргумент начинается с 1. Наконец, последняя функция, которая возвращает значение в скрипт template<class t> void Return(T value); Return()Ее описание template<> void Script::Return<int>(int value) { lua_pushinteger(lua_state,value); } template<> void Script::Return<double>(double value) { lua_pushnumber(lua_state,value); } template<> void Script::Return<char>(char* value) { lua_pushstring(lua_state,value); } template<> void Script::Return<bool>(bool value) { lua_pushboolean(lua_state,value); } Боевой код Пора что-нибудь сделать! Изменяем main.cpp #include \"Script.h\" int main() { return 0; } Компилируем. Теперь можно приступить к тестированию нашего класса Помните, я обещал сделать функцию Write? :) Видоизменяем main.cpp #include \"Script.h\" // Нужен для _getch() #include <conio.h> // Объект скрипта Script script; // Функция Write для текста int Write(lua_State*) { // Тут мы считываем количество аргументов и каждый аргумент выводим for(int i = 1; i < script.GetArgumentCount()+1; i++) cout << script.GetArgument<char*>(i); // После вывода ставим консоль на паузу _getch(); return 0; } int main() { script.Create(); // Имя у луашной функции такое же, как у сишной script.RegisterConstant<lua_cfunction>(Write,\"Write\"); script.DoFile(\"script.lua\"); script.Close(); } А в папке с проектом создаем файл script.lua Write(1,2,3,4) Компилируем и запускаем проект. Теперь изменяем script.lua for i = 1, 4 do Write(i, \"\\n\", \"Hier kommt die Sonne\", \"\\n\") end Теперь программа будет выводить по 2 строки (\"\\n\" — создание новой строки), ждать нажатия Enter и снова выводить строки. Экспериментируйте со скриптами! Вот пример main.cpp с функциями и пример script.lua #include \"Script.h\" #include <conio.h> #include <Windows.h> #include <time.h> Script script; int Write(lua_State*) { // Тут мы считываем количество аргументов и каждый аргумент выводим for(int i = 1; i < script.GetArgumentCount()+1; i++) cout << script.GetArgument<char*>(i); cout << \"\\n\"; return 0; } int GetString(lua_State*) { // Считываем строку с помощью cin и возвращаем ее, используя методы Script char* str = \"\"; cin >> str; script.Return<char*>(str); // Не забудьте! У нас возвращается 1 результат -> return 1 return 1; } int Message(lua_State*) { // Выводим обычное сообщение MessageBox из Windows.h // Кстати, вам домашнее задание - сделайте возможность вывода сообщений с несколькими аргументами :) char* msg = script.GetArgument<char*>(1); MessageBox(0,msg,\"Сообщение\",MB_OK); return 0; } int GetTwoRandomNumbers(lua_State*) { // Возвращаем два рандомных числа до 1000 srand(time(NULL)); for(int i = 0; i < 2; i++) script.Return<int>(rand()%1000); // Вовзращаем 2 значения return 2; } int GetLotOfRandomNumbers(lua_State*) { // Возвращаем много рандомных чисел до 1000 srand(time(NULL)); for(int i = 0; i < script.GetArgument<int>(1); i++) script.Return<int>(rand()%1000); // Вовзращаем столько значений, сколько задано в аргументе return script.GetArgument<int>(1); } int main() { script.Create(); script.RegisterConstant<lua_CFunction>(Write,\"Write\"); script.RegisterConstant<lua_CFunction>(GetString,\"GetString\"); script.RegisterConstant<lua_CFunction>(Message,\"Message\"); script.RegisterConstant<lua_CFunction>(GetTwoRandomNumbers,\"Rand1\"); script.RegisterConstant<lua_CFunction>(GetLotOfRandomNumbers,\"Rand2\"); script.Array(); script.RegisterConstantArray<int>(1,1); script.RegisterConstantArray<int>(2,2); script.RegisterConstantArray<int>(3,3); script.RegisterConstantArray<int>(4,4); script.RegisterArray(\"mass\"); script.DoFile(\"script.lua\"); script.Close(); // Пауза после скрипта _getch(); } for i = 1, 4 do Write(i, \"\\n\", \"Hier kommt die Sonne\", \"\\n\") end Write(2*100-1) Message(\"Привет!\") a, b = Rand1() Write(a, \"\\n\", b, \"\\n\") Write(Rand1(), \"\\n\") a, b, c, d = Rand2(4) Write(a, \"\\n\", b, \"\\n\", c, \"\\n\", d, \"\\n\") return 1 Полезные советы Для класса Script все равно, в каком расширении находится скрипт, хоть в .txt, хоть в .lua, хоть в .bmp, просто .lua открывается множеством редакторов именно ЯП Луа Используйте редакторы Lua кода, очень трудно писать код, можно забыть написать end, do, либо что-нибудь еще. Программа из-за ошибки в луа скрипте не вылетит, но просто не выполнит код Lua может оказаться намного гибче, чем вам могло показаться. К примеру, числа свободно преобразуются в строки, он нетипизирован. Если передать в функцию 100 параметров, а она в С++ считывает только первые 2, то программа не вылетит. Есть еще много подобных допущений. Вопросы и ответы Вопрос: Почему мы не используем луа стейт, который есть в каждой подобной функции — int foo(lua_State* L)? Ответ: За всю программу мы используем только один стейт в Script, где регистрируем функции, инициализируем его и делаем прочие штучки. К тому же просто невыгодно было бы, написав целый класс, опять обращаться начистоту к lua_State через lua_pushboolean и прочие функции. Полный листинг Script.h и Script.cpp Script.h#ifndef _SCRIPT_H_ #define _SCRIPT_H_ #pragma comment(lib,\"lua.lib\") extern \"C\" { #include <lua.h> #include <lualib.h> #include <lauxlib.h> } class Script { private: lua_State *lua_state; public: void Create(); void Close(); int DoFile(char* ScriptFileName); template<class t> void RegisterConstant(T value, char* constantname); void Array(); template<class t> void RegisterConstantArray(T value, int index); void RegisterArray(char* arrayname); int GetArgumentCount(); template<class t> T GetArgument(int index); template<class t> void Return(T value); }; #endif Я удалил инклуды для работы с консолью Script.cpp#include \"Script.h\" void Script::Create() { lua_state = luaL_newstate(); static const luaL_Reg lualibs[] = { {\"base\", luaopen_base}, {\"io\", luaopen_io}, {NULL, NULL} }; for(const luaL_Reg *lib = lualibs; lib->func != NULL; lib++) { luaL_requiref(lua_state, lib->name, lib->func, 1); lua_settop(lua_state, 0); } } void Script::Close() { lua_close(lua_state); } int Script::DoFile(char* ScriptFileName) { luaL_dofile(lua_state,ScriptFileName); return lua_tointeger(lua_state, lua_gettop(lua_state)); } template<> void Script::RegisterConstant<int>(int value, char* constantname) { lua_pushinteger(lua_state, value); lua_setglobal(lua_state,constantname); } template<> void Script::RegisterConstant<double>(double value, char* constantname) { lua_pushnumber(lua_state, value); lua_setglobal(lua_state,constantname); } template<> void Script::RegisterConstant<char>(char* value, char* constantname) { lua_pushstring(lua_state, value); lua_setglobal(lua_state,constantname); } template<> void Script::RegisterConstant<bool>(bool value, char* constantname) { lua_pushboolean(lua_state, value); lua_setglobal(lua_state,constantname); } template<> void Script::RegisterConstant<lua_cfunction>(int(*value)(lua_State*), char* constantname) { lua_pushcfunction(lua_state, value); lua_setglobal(lua_state,constantname); } void Script::Array() { lua_createtable(lua_state, 2, 0); } template<> void Script::RegisterConstantArray<int>(int value, int index) { lua_pushnumber(lua_state, index); lua_pushinteger(lua_state, value); lua_settable(lua_state, -3); } template<> void Script::RegisterConstantArray<double>(double value, int index) { lua_pushnumber(lua_state, index); lua_pushnumber(lua_state, value); lua_settable(lua_state, -3); } template<> void Script::RegisterConstantArray<char>(char* value, int index) { lua_pushnumber(lua_state, index); lua_pushstring(lua_state, value); lua_settable(lua_state, -3); } template<> void Script::RegisterConstantArray<bool>(bool value, int index) { lua_pushnumber(lua_state, index); lua_pushboolean(lua_state, value); lua_settable(lua_state, -3); } template<> void Script::RegisterConstantArray<lua_cfunction>(lua_CFunction value, int index) { lua_pushnumber(lua_state, index); lua_pushcfunction(lua_state, value); lua_settable(lua_state, -3); } void Script::RegisterArray(char* arrayname) { lua_setglobal(lua_state, arrayname); } int Script::GetArgumentCount() { return lua_gettop(lua_state); } template<> int Script::GetArgument<int>(int index) { return lua_tointeger(lua_state,index); } template<> double Script::GetArgument<double>(int index) { return lua_tonumber(lua_state,index); } template<> char* Script::GetArgument<char>(int index) { return (char*)lua_tostring(lua_state,index); } template<> bool Script::GetArgument<bool>(int index) { return lua_toboolean(lua_state,index); } template<> void Script::Return<int>(int value) { lua_pushinteger(lua_state,value); } template<> void Script::Return<double>(double value) { lua_pushnumber(lua_state,value); } template<> void Script::Return<char>(char* value) { lua_pushstring(lua_state,value); } template<> void Script::Return<bool>(bool value) { lua_pushboolean(lua_state,value); } Репозиторий с lib'ой и includ'ами: https://github.com/Izaron/LuaForHabr Все вопросы посылайте мне в ЛС, либо в этот топик, либо, если вам не повезло быть зарегистрированным на хабре — на мейл izarizar@mail.ru", "image": ["https://habrastorage.org/getpro/habr/post_images/f86/12e/069/f8612e0691da4500e2a8733425c372e3.gif", "https://habrastorage.org/getpro/habr/post_images/bbd/a6c/0ff/bbda6c0ff1c09602d81ce5e925e59d48.png", "https://habrastorage.org/getpro/habr/post_images/bcc/411/2f3/bcc4112f388b7f9fc85e1ee5d094afdc.png", "https://habrastorage.org/getpro/habr/post_images/db2/1b2/1c4/db21b21c489bca21f10db8921e7486a7.png"], "tag": ["game development", "c plus plus", "lua"], "rating": ["+42"], "bookmarks": ["391"], "views": ["77,6k"], "comments_count": ["33"]},
{"author": ["barsulka"], "date": ["14 января 2014 в 12:07"], "hubs": ["Разработка веб-сайтов", "Lua", "Блог компании 2ГИС"], "type_label": [], "text": "«Звонок в один клик» или Push2Dial (P2D) — ещё одна функция, которая была анонсирована с новым 2ГИС. Суть проста — выбираете организацию, кликаете на номер телефона — и он готов к набору на вашем смартфоне. Фича избавляет от необходимости самостоятельно набирать номер телефона, а значит шансы ошибиться и попасть не туда стремятся к нулю. Звонить в один клик можно как из бета-версии нового онлайнового 2ГИС, так и из старого доброго офлайнового. Оба они делают это через API, написанный по такому случаю, о котором мы и расскажем. API P2D, как вы можете догадаться из названия, работает с системой push-уведомлений. На мобильных устройствах ее использование оправдано тем, что если позволить приложениям бесконтрольно залезать в интернет, когда им вздумается, анекдоты про Android и розетку станут суровой реальностью. Кстати, в зависимости от платформы, работа с системой уведомлений немного отличается. На iOS push-уведомления — часть API системы. Приложение 2ГИС взаимодействует непосредственно с APNS. На Android же наше приложение сначала связывается с библиотекой Google Play Services, которая, в свою очередь, взаимодействует с Google Cloud Messaging. Итак, что происходит после того, как пользователь нажимает на иконку телефонной трубки в мобильном 2ГИС? Ему предложат связать устройство с 2ГИС для ПК или же с beta.2gis.ru. Мобильный 2ГИС подключается к системе push-нотификаций (или пытается это сделать), посылает серверу API Push2Dial запрос, содержащий в себе token телефона и данные об его платформе (iOS или Android). API Push2Dial генерирует pin-код для этого телефона и создает связку “pin->устройство”, которую кладет в memcache на 10 минут. В ответ API Push2Dial возвращает этот pin телефону. API Push2Dial написан на Lua. Для работы с memcache мы используем библиотеку lua-resty-memcached от разработчика по имени Yichun Zhang. Как ни странно, lua-resty-memcached, написанный на Lua, оказался быстрее и устойчивее, чем нативный модуль для nginx HttpMemcModule, написанный им же. Код, который работает с memcache, простой и короткий. Вот так, например, Lua записывает связку: -- подключаем memcached memcached = require(\"memcached\"); -- коннектимся local memc, err = memcached:new(); local connected, err = memc:connect(хост, порт); -- записываем для пин-кода токен и платформу -- ttl = 10 минут memc:set(PIN, json.encode({['token'] = token, ['platform'] = platform}), 600); Пользователь получил pin-код и вводит его на компьютере. От «большого» 2ГИС в API отправляется запрос на существование связки “pin->устройство”. Если такая связка найдена, то API Push2Dial перекладывает данные о телефоне из мемкэша в базу данных и отдаёт продукту (онлайновому или офлайновому 2ГИС) идентификатор из базы, соответствующий устройству. Возможно, вы обращали внимание, что в новом 2ГИС появилась авторизация. Если в этот момент пользователь оказался авторизован, то API Push2Dial записывает его авторизационный id. Таким образом, в следующий раз, где бы юзер не авторизовался, его привязка вступит в силу и он сможет сразу совершать звонки. Конечно же, в один клик. Собственно, о звонках. Когда пользователь нажимает на номер телефона организации в 2ГИС на компьютере, создается запрос на генерацию push-уведомления, содержащий ID устройства. API P2D находит в базе этот ID и генерирует push-уведомление в формате XML или JSON, в зависимости от платформы. Которое, в свою очередь, уходит на соответствующий сервер Google или Apple, а оттуда — на телефон пользователя. На этом этапе можно отметить еще один нюанс. На iOS набор номера всегда происходит через приложение 2ГИС, после того, как пользователь нажмет на уведомление. На Android в реальном времени запускается наш код (сразу по получению уведомления), который открывает дайлер. Таким образом, если приложение 2ГИС не было запущено, оно и не станет запускаться. Если вы еще не пробовали звонок в один клик, самое время это сделать. К вашим услугам 2ГИС для iOS или Android, новый 2ГИС и старый знакомый, 2ГИС для ПК.", "image": ["https://habrastorage.org/getpro/habr/post_images/667/72b/cf6/66772bcf6bd30647ffba1333f5d31b6b.jpg", "https://habrastorage.org/getpro/habr/post_images/e3a/7e7/f95/e3a7e7f951f82ea947677d18cd09e5da.png", "https://habrastorage.org/getpro/habr/post_images/981/659/c23/981659c23876b27f5e38db5e6093f9e7.png"], "tag": ["push notifications", "push-уведомления", "2ГИС", "звонок в один клик", "LUA", "json", "xml"], "rating": ["+22"], "bookmarks": ["39"], "views": ["16,4k"], "comments_count": ["12"]},
{"author": ["kefiiir"], "date": ["17 сентября 2013 в 07:47"], "hubs": ["Lua", "Обработка изображений"], "type_label": [], "text": "На хабре уже несколько раз поднимался вопрос про хранение метатегов распознаных лиц для фото-архива, к сожалению из приведенных рецептов ни один не оказался достаточно рабочим, да и гугление не помогло, поэтому пришлось писать свой велосипедик. Оригинальные статьи: раз и два. Все там написано хорошо и правильно, но счастья все равно нет. Картинка для привлечения внимания: Задача простая — отметить людей на фотографии и иметь возможность пользоваться этим в максимальном количестве мест любым удобным для меня способом. Лица отмечать буду в пикасе, потому как привязка к гугловским контактам, кроссплатформенность, авто определение, хранение тегов внутри файла (с нюансами). А вот смотреть и использовать эти теги хочу везде в gallery3 потому что она это умеет, в lightroom потому что именно им пользуюсь как каталогизатором, в microsoft explorer потому как он у меня есть и в Microsoft Live Photo Gallery, просто потому что это второй популярный формат и почему бы и его тоже не использовать. Кто тоже хочет заморочиться — добро пожаловать под кат. Проблема номер 1 где пикаса хранит информацию о лицах? Вариантов три: Либо это связка из двух файлов: contacts.xml в профиле пользователя и picasa.ini в папке с фотографиями. Этот вариант верен если вы тегировали лица в пикасе версии меньше чем 3.9 и в последней пикасе, о с выключенной галкой «Store name tags in photo». Второй вариант хранение лиц в XMP-mwg-rs если вы использовали только последнюю пикасу и включили галку «Store name tags in photo» до того как начали отмечать лица, надо помнить, что по умолчанию она включена. И наконец третий вариант, самый распространенный: лица хранятся и там и там и что с этим делать вообще непонятно. По понятным причинам второй вариант самый оптимальный, но как оказалось не все так просто, пикасе нельзя просто сказать: «Запиши все теги в файлы» гугл пожадничал поставить такую кнопку. Вариантов решить эту проблему есть несколько как чисто пикасовых так и используя внешние утилиты. picface почти работает, недавно обновлялась, но у меня многократно вылетала не доделав начатое до конца, а поскольку архив у меня примерно 60К фотографий, все это происходит долго и муторно. самый популярный avpicfacexmptagger Умеет делать почти все, что надо, но достаточно однобоко, давно не обновлялся, придумали свою собственную схему для xmp, можно подумать существующих мало. Но в принципе для приведения архива к состоянию два использовать можно. Я использовал рекомендацию от самого гугла, вам нужна только пикаса версии 3.9 с включенной галкой «Store name tags in photo». Для гарантированной записи всех лиц в xmp надо пройтись по всем людям и переименовать во что-то, а потом переименовать обратно. Быстро, просто, работает. На вкладке people два раза кликаете по первому имени и переименовываете его в 'x' потом два раза кликаете по 'x' и переименовываете его обратно. Все у меня оттегировано полторы сотни людей и это заняло всего пару минут. Пикасу после этого лучше сразу не закрывать, а дать ей какое-то время записать данные на диск, потому как прогресса никакого она не показывает. Следующим шагом мы хотим извлечь имена записаные пикасой в xmp-mwg-rs в теге RegionName и записать его в теги PersonInImage и RegionPersonDisplayName после этого мы сможем использовать эти теги при поиске во всех каталогизаторах и даже microsoft explorer будет нам показывать в информации имена людей на фотографии. Сделать это проще всего при помощи exiftool который можно скачать здесь. exiftool -RegionName>PersonInImage photo.jpg exiftool -RegionName>RegionPersonDisplayName photo.jpg после этого мы видим информацию о людях во множестве сторонних програм Так же можно конвертировать информацию о положении лиц на кадре из стандарта пикасы в стандарт от микрософта, отличаются они не только именами, но даже методом как считаются квадраты, одни задают длинну и высоту от верхнего левого угла квадрата, а другие от центра. Для конвертации нам нужен конфиг для exiftool. ExifTool_config_convert_regions %Image::ExifTool::UserDefined = ( 'Image::ExifTool::Composite' => { MyRegion => { Require => { 0 => 'RegionInfoMP', 1 => 'ImageWidth', 2 => 'ImageHeight', }, ValueConv => q{ my ($rgn, @newRgns); foreach $rgn (@{$val[0]{Regions}}) { my @rect = split /\\s*,\\s*/, $$rgn{Rectangle}; my %newRgn = ( Area => { X => $rect[0] + $rect[2]/2, Y => $rect[1] + $rect[3]/2, W => $rect[2], H => $rect[3], Unit => 'normalized', }, Name => $$rgn{PersonDisplayName}, Type => 'Face', ); push @newRgns, \\%newRgn; } return { AppliedToDimensions => { W => $val[1], H => $val[2], Unit => 'pixel' }, RegionList => \\@newRgns, }; }, }, MyRegionMP => { Require => 'RegionInfo', ValueConv => q{ my ($rgn, @newRgns); foreach $rgn (@{$val[0]{RegionList}}) { my @rect = @{$$rgn{Area}}{'X','Y','W','H'}; $rect[0] -= $rect[2]/2; $rect[1] -= $rect[3]/2; push @newRgns, { PersonDisplayName => $$rgn{Name}, Rectangle => join(', ', @rect), }; } return { Regions => \\@newRgns }; }, }, }, ); 1; #end Конфиг найден на просторах интернета и он позволяет конвертировать регионы в обе стороны, но нам достаточно в одну. Для этого выполняем exiftool со следующими параметрами: exiftool -config ExifTool_config_convert_regions \"-regioninfomp\\<MyRegionMP\"' photo.jpg после этого лицо правильно отображается в Microsoft Live Photo Gallery и другом софте который придерживается той же схемы Уже практически профит, но еще бы автоматизировать это дело для всех необходимых фотографий, а кроме того прописать имена в ключевые слова: теги Subject и HierarchialSuject да, здесь тоже не обошлось без двойных форматов. Для этих целей я написал плагинчик для лайтрума, это дает возможность запустить его только на нужных фотографиях, и добавлять ключевые слова, не опасаясь их задвоить или стереть уже существующие, ну и просто потому что я пользуюсь именно лайтрумом как каталогизатором всего архива. За код просьба не бить, а лучше подсказать как его улучшить, это мой первый плагин для LR и вообще первый раз когда я увидел lua. В плагине всего два файла Info.lua return { LrSdkVersion = 3.0, LrSdkMinimumVersion = 1.3, -- minimum SDK version required by this plug-in LrToolkitIdentifier = 'com.adobe.lightroom.sdk.helloworld', LrPluginName = LOC \"$$$/PicasaFaceToTag/PluginName=Picasa Faces to Tags\", -- Add the menu item to the Library menu. LrLibraryMenuItems = { { title = \"Write Picasa Faces to Tags\", file = \"PersonInImage.lua\"}, }, VERSION = { major=4, minor=1, revision=0, build=831116, }, } PersonInImage.lua --[[---------------------------------------------------------------------------- ------------------------------------------------------------------------------]] -- Access the Lightroom SDK namespaces. local LrTasks = import 'LrTasks' local LrProgressScope = import 'LrProgressScope' local LrApplication = import 'LrApplication' local catalog = LrApplication.activeCatalog() local photos = catalog:getTargetPhotos() local LrPathUtils = import 'LrPathUtils' local logger = import 'LrLogger'(\"lr\") logger:enable('print') local function faceToTag() --[[Convert faces from picasa xmp tag to microsoft xmp ]] exeFile = LrPathUtils.child( _PLUGIN.path, \"exiftool.exe\" ) cfgFile = LrPathUtils.child( _PLUGIN.path, \"ExifTool_config_convert_regions\" ) redirect = LrPathUtils.getStandardFilePath('temp') .. \"exiftool.stdout\" local total = ( # catalog:getTargetPhotos() ) local exifArgs = {\"-b -RegionName \\>\" .. redirect, --'-overwrite_original \"-RegionName\\>PersonInImage\"', '-overwrite_original \"-RegionName\\>RegionPersonDisplayName\"', '-config '..cfgFile..' -overwrite_original \"-regioninfomp\\<MyRegionMP\"'} local progressScope = LrProgressScope{ title = \"Write Picasa Faces to Tags\", caption = \"Updateting \" .. total .. \" photos.\" , } progressScope:setCancelable( true ) local parrent catalog:withWriteAccessDo(\"Create parrent keyword\", function () parrent = catalog:createKeyword(\"names\", {}, false, nil, true) --logger:debug(\"parrent keyword created: \" .. tostring(parrent)) end) for completed, photo in ipairs(photos) do progressScope:setPortionComplete(completed, total) progressScope:setCaption(\"Updated \" .. tostring(completed) .. \" of \" .. tostring(total) .. \" photos\") if progressScope:isCanceled() then progressScope:done() break end local path = photo:getRawMetadata('path') logger:debug(path) -- write filename to debug log for i,exifArg in ipairs(exifArgs) do local exeCmd ='\"' .. exeFile..\" \"..exifArg..\" \"..path .. '\"' local status = LrTasks.execute(exeCmd) if io.open(redirect):read() == nil then break end --check is there any names in the file --logger:debug(exeCmd) if status ~= 0 then logger:debug(\"Error \"..exeCmd) progressScope:done() end end for name in io.lines(redirect) do if name ~= nil then -- check is there any pleople on photo logger:debug(name) catalog:withWriteAccessDo(\"Adding name keywords\", function () local keyword = catalog:createKeyword(name, {}, true, parrent, true) logger:debug(\"keyword created: \" .. tostring(keyword)) photo:addKeyword(keyword) --photo:setRawMetadata('personShown', keyword) --doesn't work logger:debug(\"keyword added: \" .. name) end) end end end progressScope:done() end LrTasks.startAsyncTask(faceToTag) Все именные теги хранятся в иерархической структуре внутри тега «names», программы которые не работают с xmp схемой лайтрума будут видеть их просто плоским списком + тег «names». Для работы плагину в папку надо положить exiftool.exe и его конфиг. Все скопом можно скачать с github Плагин работает, но у него есть недостатки: Не удается записать PersonInImage, если его писать exiftool он перезаписывается лайтрумом, а записать его непосредственно через SDK не получается по непонятным причинам. photo:setRawMetadata('personShown', keyword) вылетает с ошибкой. Можно разнести это в две разных кнопки и перечитывать метаданные вручную, но это тоже некрасиво. работает медленно примерно 1 секунда на фото, при большем архиве это проблема, возможно если переписать через cookbooks.adobe.com/post_ExifTool___making_it_scream_-19501.html будет быстрее. Поскольку плагин пишет одновременно и через exiftool и через lightroom SDK по окончании работы регулярно возникает конфликт метаданных, и их надо сохранять вручную Ctrl+s. Если кто-то знает как заставить лайтрум писать и читать метаданные програмно — отпишитесь. Я пока придумал вариант только с эмуляцией хотеев lrBind но это не красиво. Это уже проблема не плагина, всей системы, если протегировать рав, а после этого его экспортировать, информация о лицах теряется, но теги сохраняются, а это уже профит. ЗЫ. Я смог найти два плагина которые делают _почти_ тоже самое, берут лица из пикасы и пишут их в теги, но все они берут лица только из picasa.ini и не работают с лицами записанными в XMP.", "image": ["https://habrastorage.org/storage2/ff3/02f/f4f/ff302ff4f68933a037b1137bf3a3b664.jpg", "https://habrastorage.org/storage2/e21/16e/f87/e2116ef877b9862dda2f1a101e265e02.jpg", "http://habrastorage.org/storage2/ab6/be8/3da/ab6be83da0d60fafd675dff56308fdd5.jpg"], "tag": ["xmp", "picasa", "lightroom", "фотоархив"], "rating": ["+14"], "bookmarks": ["57"], "views": ["6,7k"], "comments_count": ["6"]},
{"author": ["eliasdaler"], "date": ["12 октября 2013 в 22:46"], "hubs": ["Lua", "Разработка игр", "C++"], "type_label": [], "text": "Код статьи можно посмотреть здесь. Чем так хорош Lua? Когда-то я разрабатывал свою игру и задался вопросом: а какой формат данных лучше использовать для конфигурационных файлов? Ведь удобно, когда создаёшь какой-либо объект, задавать различные начальные параметры не в самом коде, а в отдельных файлах. Это позволяет изменять некоторые параметры объектов без рекомпиляции, да и вообще даёт возможность менять их людям далёким от программирования. Разработчики используют разные форматы: одни используют JSON, другие — XML, либо другие форматы данных. Ну а некоторые вообще хранят данные в .txt файлах или пишут свои парсеры. После рассмотрения различных форматов я остановился на Lua. Lua можно использовать не только для игр, но и вообще для любых программ, которые используют данные, хранящиеся в других файлах. Вот, что выделяет Lua на фоне других форматов: Lua легко использовать без дополнительных зависимостей (кроме одной библиотеки Lua и трёх .h файлов). В Lua файлах данные можно инициализировать с помощью математических выражений или функций, написанных на Lua. Например: some_variable = math.sqrt(2) * 2 some_variable2 = 64 * 16 - 32 Lua — очень быстрый язык, который к тому же не занимает много памяти. У Lua лицензия MIT, которая позволяет использовать этот язык как в бесплатных, так и в коммерческих проектах, причём без всякой возни с бумагами. Как написано на сайте: «просто скачайте и пользуйтесь». Lua комплируется практически везде, т.к. он написан на чистом C без использования дополнительных библиотек. Данные можно хранить и сортировать в приятном глазу виде. Их легко читать и модифицировать в любом текстовом редакторе. Начнём с простого примера, а затем я перейду к реализации класса. Пример Допустим, есть файл Player.lua player = { pos = { X = 20, Y = 30, }, filename = \"res/images/player.png\", HP = 20, -- а ещё можно комментарии добавлять } С простым классом данные можно будет получать так: LuaScript script(\"player.lua\"); std::string filename = script.get<std::string>(\"player.filename\"); int posX = script.get<std::string>(\"player.pos.X\"); Внимание, чтобы код был понятен, рекомендуется прочесть информацию о том, как работает стек Lua и посмотреть на простейшие примеры. Почитать можно здесь. Начнём с создания класса: #ifndef LUASCRIPT_H #define LUASCRIPT_H #include <string> #include <vector> #include <iostream> // Lua написан на C, поэтому нужно сообщить компилятору, чтобы он воспринимал хэдеры как код на C extern \"C\" { # include \"lua.h\" # include \"lauxlib.h\" # include \"lualib.h\" } class LuaScript { public: LuaScript(const std::string& filename); ~LuaScript(); void printError(const std::string& variableName, const std::string& reason); template<typename T> T get(const std::string& variableName) { // реализация функции последует позже в статье } bool lua_gettostack(const std::string& variableName) { // заносим переменную в вершину стека. Если успешно - возвращаем true // реализация позже } // Возращаем 0 по умолчанию template<typename T> T lua_get(const std::string& variableName) { return 0; } // Эта функция используется в случае, если не удалось получить значение переменной и нужно вернуть какое-то // нулевое стандартное значение template<typename T> T lua_getdefault(const std::string& variableName) { return 0; } private: lua_State* L; int level; // см. реализацию lug_gettostack }; #endif Конструктор: LuaScript::LuaScript(const std::string& filename) { L = luaL_newstate(); if (luaL_loadfile(L, filename.c_str()) || lua_pcall(L, 0, 0, 0)) { std::cout<<\"Error: script not loaded (\"<<filename<<\")\"<<std::endl; L = 0; } } . Создаём lua_State, в случае если файл не был найден, либо произошла какая-либо другая ошибка, выводим сообщение об этом. Деструктор: LuaScript::~LuaScript() { if(L) lua_close(L); } Метод printError создан для того, чтобы выводить сообщения об ошибках: void LuaScript::printError(const std::string& variableName, const std::string& reason) { std::cout<<\"Error: can't get [\"<<variableName<<\"]. \"<<reason<<std::endl; } lua_getdefault используется для того, чтобы вернуть какое-либо нулевое значение, если произошла ошибка. И если для чисел можно вернуть ноль, то для строк, например, это не сработает, поэтому делаем специализацию шаблона (этот код будет в хэдере). template<> inline std::string LuaScript::lua_getdefault<std::string>() { return \"null\"; } А теперь напишем шаблонную функцию get. Для начала напишем функцию lua_gettostack, которая заносит переменную на вершину стека Разберём алгоритм на примере. Пусть нужно получить переменную «player.pos.X» из файла Player.lua Проходим циклом до первой точки, при этом добавляя прочитанные символы в переменную «var». «player» — таблица, которая является глобальной, поэтому получаем её с помощью lua_getglobal. «pos» и «X» — это уже данные, которые не являются глобальные, но их можно получить с помощью lua_getfield, т.к. сама таблица player находится в вершине стека. Затем уже в шаблонной функции get выполняется специфичная для типа данных функция, очищается стек и возвращается искомое значение, а в случае ошибки — вызывается функция lua_getdefault. bool lua_gettostack(const std::string& variableName) { level = 0; std::string var = \"\"; for(unsigned int i = 0; i < variableName.size(); i++) { if(variableName.at(i) == '.') { if(level == 0) { lua_getglobal(L, var.c_str()); } else { lua_getfield(L, -1, var.c_str()); } if(lua_isnil(L, -1)) { printError(variableName, var + \" is not defined\"); return false; } else { var = \"\"; level++; } } else { var += variableName.at(i); } } if(level == 0) { lua_getglobal(L, var.c_str()); } else { lua_getfield(L, -1, var.c_str()); } if(lua_isnil(L, -1)) { printError(variableName, var + \" is not defined\"); return false; } // всё ок, возвращаем true return true; } Возвращаемся к методу get: template <typename T> T get(const std::string& variableName) { if(!L) { printError(variableName, \"Script is not loaded\"); return lua_getdefault<T>(); } T result; if(lua_gettostack(variableName)) { // всё ок, переменная на вершине стека result = lua_get<T>(variableName); } else { result = lua_getdefault<T>(); } lua_pop(L, level + 1); // очищаем стек return result; } } Осталось лишь добавить специализиации шаблонов(пример для некоторых типов данных): template <> inline bool LuaScript::lua_get<bool>(const std::string& variableName) { return (bool)lua_toboolean(L, -1); } template <> inline float LuaScript::lua_get<float>(const std::string& variableName) { if(!lua_isnumber(L, -1)) { printError(variableName, \"Not a number\"); } return (float)lua_tonumber(L, -1); } template <> inline int LuaScript::lua_get<int>(const std::string& variableName) { if(!lua_isnumber(L, -1)) { printError(variableName, \"Not a number\"); } return (int)lua_tonumber(L, -1); } template <> inline std::string LuaScript::lua_get<std::string>(const std::string& variableName) { std::string s = \"null\"; if(lua_isstring(L, -1)) { s = std::string(lua_tostring(L, -1)); } else { printError(variableName, \"Not a string\"); } return s; } На этом всё. Напоминаю, весь код в статье есть здесь. Там же можно найти пример использования класса. Что дальше? У Lua ещё много возможностей, которые я опишу во второй части статьи в ближайшем будущем. Например, получение массива данных неопределённой длины, а также получение списка ключей таблицы (например для таблицы Player из примера он был бы таким:[«pos», «filename», «HP»]) А ещё из Lua можно вызывать C++ функции, так же как и из C++ можно вызывать функции Lua, о чём я напишу в третьей части. Удачного скриптинга!", "image": ["http://habrastorage.org/storage3/b84/34c/344/b8434c344d8712c2bcbeb68bbc5a81f1.png"], "tag": ["gamedev", "lua", "c++", "обработка данных", "хранение данных", "разработка игр"], "rating": ["+43"], "bookmarks": ["211"], "views": ["29,8k"], "comments_count": ["28"]},
{"author": ["AlexeyVanilov"], "date": ["12 августа 2013 в 11:56"], "hubs": ["Lua", "Разработка игр"], "type_label": ["Tutorial"], "text": "Введение Прочитал недавно пост, в котором автор рассказал о своём боте для торговли на аукционе в игре World of Warcraft. Его персонаж бегал челноком на небольшие расстояния и выполнял конкретные действия, строго заданные в управляющей программе. Воспользовавшись его идеями, я решил пойти немного дальше: пусть персонаж будет способен бегать по маршруту длительностью хотя бы пять минут, при этом должна быть возможность записывать маршрут и выполняемые действия извне, не прибегая к изменению самой программы управления. Описанное мной является развитием поста-оригинала, тем не менее я постарался, чтобы его чтение не было обязательным. В посте я опишу Процесс создания тривиального аддона для пользовательского интерфейса WoW на языке Lua Сериализация данных для передачи между частями системы Передача с помощью цвета пикселей Процесс управления персонажем на языке AutoIt Программа для записи выполняемых действий Программа для воспроизведения Мат.расчеты направления перемещения Почему не стоит прибегать к чтению/записи памяти процесса Программа управления (ро)ботом с командами, понятными непрограммисту Предупреждение Я отлично понимаю, что использование ботов запрещено лицензионным соглашением Blizzard. Это может привести к перманентному бану аккаунта. Я бы расстроился, узнав, что кто-то, воспользовавшись материалами данного поста, стал наживаться, ухудшая экономику игры и вызывая неодобрение других игроков. И да, я понимаю, то, что делаю я, нечестно. Цель поста — рассказать о моем опыте и описать сложности, с которыми я столкнулся, узнать у вас, что можно было сделать лучше. Предыстория Коллекционирование Люди, далекие от индустрии игр, могут без ущерба пропустить этот раздел. В игре WoW есть такой аспект — коллекционирование. Как и в нумизматике/филателии, чем больше у вас, например, верховых животных, тем вам приятнее. Точно так же важен процесс получения. Какие-то драконы требуют для получения выполнения десятка задач («ачивок»), какие-то — войти в лучшие 2% игроков в мире по навыку управления персонажем (сражения на арене), что-то можно просто купить за игровую валюту, что-то — за реальные деньги в магазине. Подробности можно почитать в другом источнике, речь не об этом. Так вот, некоторые из коллекционируемых предметов падают в подземелье с шансом около 0,5%. Если шанс выпадения дается игроку лишь раз в день (иногда в неделю), вам потребуется время, соизмеримое с годом, для забегов. И все ради того мгновения получения заветного выстраданного предмета. Чем больше вы потратили времени и сил на \"фарм\" предмета, тем приятнее вам его в итоге получить. По моему опыту радость очень мимолетна. Зависимость шанса выпадения от количества попыток Небольшое отступление. Какова вероятность того, что за шесть бросков игральной кости выпадет «6»? Очевидно, что . То есть, наше событие является противоположным событием к невыпадению «6» за все шесть попыток. Используя второй замечательный предел, нетрудно показать, что . А вероятность получения коня с шансом «дропа» в 1% за 100 попыток примерно равна 63%. Некоторые игроки, сделав триста попыток считают, что вот-вот повезет — ведь вероятность облома за такое большое число попыток мала. Их ждет разочарование, ведь за следующие 100 им повезет снова лишь на 63%. А старые труды не дают ничего. Задача Есть подземелье. Нужно пробежать по нему с виражами, выполнить пару несложных задач по пути. Убить финального босса и поднять добычу. Чтобы не бежать к выходу пешком, телепортироваться в ближайшую деревню и долететь ко входу. Повторить 5 раз. Карта подземелья и маршрут: Задача максимум. Запустил и ушел на пол часа. Процесс полностью автоматический. Задача минимум. Запустить и сидеть рядом, читать или играть на гитаре, поглядывая на монитор. При необходимости изредка помогать персонажу выбраться из непредвиденной ситуации. Важно иметь возможность при желании описать маршрут другого подземелья, не залезая в код. Подход Движение и позиционирование Просто записать нажатие и отпускание клавиш, позицию и щелчки мыши не получится. Точнее записать-то получится, только при проигрывании будет происходить совсем не то, что вы ожидали, по следующим причинам: Вам требуется воспроизвести первоначальное положение персонажа и направление его взгляда. Если вы перед автоматическим забегом повернетесь слегка в другую сторону, вы побежите кривовато и рано или поздно упретесь в стенку Если вы записали точные координаты и угол, то поставить персонажа туда же вам также не удастся. Реагирует на кнопки он как бульдозер и поворачивается так же. А даже ошибка в 1 градус через 100 метров выльется в метра (ширина дверного проема) Время нажатия и отпускания кнопок тоже далеко от идеала. Это похоже на передвижение по квартире с закрытыми глазами. Вроде бы шесть шагов вперед и строго направо, но на деле вместо туалета мы оказываемся в ванной. Попробуйте также открыть дверь с закрытыми глазами, не щупая ручку Вот по этим причинам нам необходимо позиционироваться в мире при помощи координат. При этом сверять позицию и вносить коррективы необходимо регулярно, каждые 100 миллисекунд. move 40.644 20.417 1.537 move 40.526 20.411 1.537 move 40.246 20.408 1.592 move 39.974 20.414 1.592 move 39.691 20.411 1.537 move 39.417 20.388 1.510 Это отрывок из списка команд робота по перемещению. Указаны координаты x, y и угол поворота в пространстве в радианах. Клавиши и команды По пути надо нажимать кнопки и кликать мышкой, открывать двери, где-то нужно ждать. Не хотелось бы выписывать это все вручную. Да и искать среди команд с координатами (в примере выше), куда же что вписать, не очень приятно. Поэтому единовременные нажатия на кнопки и клики мы будем писать параллельно с записью координат. pitch -0.89 mouse right 942 498 pause 10000 move 39.417 20.388 1.510 key ` pause 1000 key {SPACE} move 39.142 20.364 1.510 key {TAB} key 3 key 3 mouse right 963 622 move 38.864 20.340 1.510 move 38.653 20.321 1.510 Отдельно упомяну про «pitch» (наклон). Если персонаж смотрит в горизонт, он равен нулю. Если под ноги, наклон отрицателен. А в небо — положителен. Измеряется в радианах. Его пришлось добавить, как только персонажу захотелось летать. Модули Таким образом, у нас вырисовываются части программно-аппаратного комплекса бота: Мы напишем addon для интерфейса WoW, который будет определять позицию персонажа, азимут, наклон. Правилами игры аддоны ничуть не запрещены, указанная информация доступна через игровое API внутри аддона. Он будет рисовать это все на экране. Сам аддон пишется на языке Lua, потому что так решили разработчики игры. В аддоне можно определять кое-что, можно рисовать, но вот заставить персонажа двигаться нельзя. Еще в аддоне нельзя писать в файл, спрашивать у игры, где стены, где враги, да и много чего еще нельзя. Поэтому нам нужно написать внешнее управляющее приложение. Я не стал оригинальничать и использовал AutoIt. Это действительно быстро и удобно, хоть и немного дико для меня, привыкшего программировать на строго типизированных языках. Приложение должно уметь записывать мои действия. Назовем этот функционал Recorder Приложение должно уметь воспроизводить запись. Назовем Player Записанные действия и координаты мы будем хранить в текстовом файле построчно. Их можно и нужно редактировать вручную. Добавлять костыли, удалять мусор. Скажу сразу, это самое сложное. Addon для WoW на Lua Аддон для WoW это скрипт на языке Lua. Язык полноценный, гибкий, эффективный. Делать с системой ничего нельзя. Делать с игрой можно все, но только в рамках того API, которое предоставляет вам игра. Так как Blizzard не хочет, а точнее, запрещает игрокам и предпринимателям писать ботов, то и API кроме упомянутых выше координат почти ничего полезного и не предоставляет. Разумеется, полезного для наших нужд. Неплохой гайд по написанию аддонов сразу с описанием Lua можно найти здесь. Ну а я опишу свой вариант. Манифест и GUI Подробности и источник. В папке World of Warcraft\\Interface\\AddOns\\ создаете папку HelloWorld. В нее кладете HelloWorld.toc с содержимым ## Interface: 50001 ## Title: Hello, World! ## Notes: My first AddOn HelloWorld.lua Если бы я хотел понарисовать формочек и кнопочек (а для этого обычно и нужны аддоны), последней строчкой я бы вписал еще HelloWorld.xml с описанием этих кнопочек. В дизайне и написании такого GUI-аддона хорошо помогает AddOn Studio. Мощный инструмент на базе MS Visual Studio. Но так как я минималист, рисовать мы в этот раз не будем. Кроме того, это даст мне возможность показать, что создавать формы можно динамически из самого скрипта без использования дизайнера. Рассмотрим же HelloWorld.lua. Редактировал я его в Notepad++. Чтобы игра подключила изменения в HelloWorld.toc, надо перезапустить ее целиком. А вот изменения в HelloWorld.lua можно подхватить, написав в консоли команду /reload. Поэтому процесс программирования и отладки не такой болезненный. Слеш-команды Кстати, об отладке. Советую сразу добавить обработчик слеш-команд: SLASH_HELLO_WORLD1 = '/helloworld'; function SlashCmdList.HELLO_WORLD(msg, editbox) local facing = GetPlayerFacing(); local pitch = GetUnitPitch(\"player\"); local x, y = GetPlayerMapPosition(\"player\"); print(format(\"HelloWorld %.2f %.2f %.2f %.2f\", x*100, y*100, facing, pitch)); end Для этого определим переменную вида SLASH_ИМЯn. Где ИМЯ уникально для всех аддонов, а n либо пусто, либо порядковое число с 1. И добавим функцию с именем ИМЯ в некий объект. Может показаться странным для программиста на C++, что мы эту функцию-обработчик нигде явно не регистрируем. Да и со строковой переменной связываем чисто по имени переменной. Но вот такая она, мощь и магия Lua. Теперь команда в WoW-консоли /helloworld выполнит требуемые вам действия: позволит вывести отладочную информацию, а для простейших аддонов, собственно, произведет все то, ради чего вы их писали. Ну и тут же я показал WoW API, которое достает требуемую информацию. Обработчик событий Система работы с GUI в аддоне похожа на работу Windows со своими сообщениями и их обработкой. local EventFrame = CreateFrame(\"Frame\") function EventFrame:OnEvent(event, ...) print(\"HelloWorld:\", event) self[event](self, ...) end EventFrame:SetScript(\"OnEvent\", EventFrame.OnEvent) EventFrame:RegisterEvent(\"PLAYER_LOGIN\") function EventFrame:PLAYER_LOGIN() -- Инициализация тут end function EventFrame:OnUpdate() -- Полезные действия тут end EventFrame:SetScript(\"OnUpdate\", EventFrame.OnUpdate) Мы создаем фрейм типа \"Frame\" и подключаемся на действия \"OnEvent\" и \"OnUpdate\" командами EventFrame:SetScript(\"OnEvent\", EventFrame.OnEvent) EventFrame:SetScript(\"OnUpdate\", EventFrame.OnUpdate) Обработчик OnUpdate будет вызываться после каждого кадра — то, что нам нужно для обновления координат. А OnEvent будет вызываться при других желаемых событиях. Из него будем дергать соответствующие функции: self[event](self, ...) Что еще удобнее в Lua, это то, что вот такой конструкцией можно вызвать уникальные обработчики вида function EventFrame:PLAYER_LOGIN() Здесь PLAYER_LOGIN — это событие, которое рассылается во все фреймы при входе в мир и перезапуске пользовательского интерфейса. Другие события: PLAYER_LEAVE_COMBAT, QUEST_FINISHED, PLAYER_EQUIPMENT_CHANGED, PLAYER_DEAD, — и еще очень много. С полным списком можно ознакомиться тут. Зарегистрируем то событие, которое мы хотим обрабатывать, командой EventFrame:RegisterEvent(\"PLAYER_LOGIN\") Передача информации Так как в аддоне нельзя ничего делать с системой, информацию из WoW другой части бота мы будем передавать при помощи изменения цвета пикселей. Как это делал rednaxi в своем посте. Но только мы будем передавать цветом не один бит информации, а будем сериализовать данные и передавать их больше. Рисование Так как для рисования тоже нужны фреймы, создадим их local HelloWorld1 = CreateFrame(\"Frame\", nil, UIParent) local HelloWorld2 = CreateFrame(\"Frame\", nil, UIParent) function EventFrame:PLAYER_LOGIN() HelloWorld1:SetFrameStrata(\"BACKGROUND\") HelloWorld1:SetWidth(10) HelloWorld1:SetHeight(10) HelloWorld1.texture = HelloWorld1:CreateTexture(nil,\"BACKGROUND\") HelloWorld1.texture:SetAllPoints(HelloWorld1) HelloWorld1:SetPoint(\"TOPLEFT\",0,0) HelloWorld1:Show() HelloWorld2:SetFrameStrata(\"BACKGROUND\") HelloWorld2:SetWidth(10) HelloWorld2:SetHeight(10) HelloWorld2.texture = HelloWorld2:CreateTexture(nil,\"BACKGROUND\") HelloWorld2.texture:SetAllPoints(HelloWorld2) HelloWorld2:SetPoint(\"TOPLEFT\",10,0) HelloWorld2:Show() end Думаю, тут все понятно и без комментариев. Подробности по каждому методу ищите сами. Сериализация У нас есть две координаты и два угла. Все — числа с плавающей запятой. Компоненты цветов пикселей в аддоне тоже числа с плавающей запятой, но от 0.0 до 1.0. Кроме того, известно, что сохранится компонента цвета в одном байте. Поначалу я каждую координату сохранял в одну компоненту цвета. В итоге точность позиционирования в локации составляла 1/255 от размера карты. Получалось как в GPS: вроде координаты есть, но вести машину на автомате (управление компьютером без человека) по дороге по навигатору не выйдет. Так что пришлось давать два байта. Как повыгоднее сохранить одно дробное число в два байта? Я сделал так local x1, x2 = math.modf(x*255) Функция modf возвращает целую и дробную часть числа через запятую. Здесь используется параллельное присваивание — еще одна полезная фишечка Lua. При таком подходе я использую полную мощность каждого из двух байтов, в которые сохраняется координата. Ну а азимут и наклон не так требовательны к точности, лишь бы укладывались в отрезок 0.0-1.0. Получается вот так: local math = getfenv(0).math function EventFrame:OnUpdate() local facing = GetPlayerFacing(); local pitch = GetUnitPitch(\"player\"); local x, y = GetPlayerMapPosition(\"player\"); local x1, x2 = math.modf(x*255) local y1, y2 = math.modf(y*255) HelloWorld1.texture:SetTexture(x1/255, x2, facing/7) HelloWorld2.texture:SetTexture(y1/255, y2, pitch/4+0.5) end Теперь при перемещении по миру в левом верхнем углу два квадратика 10 на 10 будут хаотично менять свой цвет. Полный текст HelloWorld.lualocal math = getfenv(0).math SLASH_HELLO_WORLD1 = '/helloworld'; local EventFrame = CreateFrame(\"Frame\") local HelloWorld1 = CreateFrame(\"Frame\", nil, UIParent) local HelloWorld2 = CreateFrame(\"Frame\", nil, UIParent) function EventFrame:OnEvent(event, ...) print(\"HelloWorld:\", event) self[event](self, ...) end EventFrame:SetScript(\"OnEvent\", EventFrame.OnEvent) EventFrame:RegisterEvent(\"PLAYER_LOGIN\") function EventFrame:PLAYER_LOGIN() HelloWorld1:SetFrameStrata(\"BACKGROUND\") HelloWorld1:SetWidth(10) HelloWorld1:SetHeight(10) HelloWorld1.texture = HelloWorld1:CreateTexture(nil,\"BACKGROUND\") HelloWorld1.texture:SetAllPoints(HelloWorld1) HelloWorld1:SetPoint(\"TOPLEFT\",0,0) HelloWorld1:Show() HelloWorld2:SetFrameStrata(\"BACKGROUND\") HelloWorld2:SetWidth(10) HelloWorld2:SetHeight(10) HelloWorld2.texture = HelloWorld2:CreateTexture(nil,\"BACKGROUND\") HelloWorld2.texture:SetAllPoints(HelloWorld2) HelloWorld2:SetPoint(\"TOPLEFT\",10,0) HelloWorld2:Show() end function EventFrame:OnUpdate() local facing = GetPlayerFacing(); local pitch = GetUnitPitch(\"player\"); local x, y = GetPlayerMapPosition(\"player\"); local x1, x2 = math.modf(x*255) local y1, y2 = math.modf(y*255) HelloWorld1.texture:SetTexture(x1/255, x2, facing/7) HelloWorld2.texture:SetTexture(y1/255, y2, pitch/4+0.5) end EventFrame:SetScript(\"OnUpdate\", EventFrame.OnUpdate) function SlashCmdList.HELLO_WORLD(msg, editbox) local facing = GetPlayerFacing(); local pitch = GetUnitPitch(\"player\"); local x, y = GetPlayerMapPosition(\"player\"); print(format(\"HelloWorld %.2f %.2f %.2f %.2f\", x*100, y*100, facing, pitch)); end Заключение первой части Повторим, о чем шла речь Мы посчитали вероятность получения предмета за большое число попыток Обозначили задачу, выработали подход к решению, разбили на модули Мы рассмотрели код простейшего аддона для WoW на языке Lua научились передавать координаты при помощи цвета научились рисовать, обрабатывать события научились обрабатывать слеш-команды Теперь вы готовы к написанию своего аддона. А если вы разрабатываете нечто и хотите дать возможность себе или пользователям принимать участие, гибко подстраивать ПО под себя с использованием вашего API (например, писать искусственный интеллект противников, дать возможность брокерам размещать позиции, основываясь на котировках, дать возможность администраторам выполнять свои действия по результатам инвентаризации систем пользователей и т.п.), то знайте, Lua очень гибок и очень легко встраивается. Обдумайте такую возможность. Ну, а в следующей части мы поговорим о написании Recorder'а клавиш и координат на языке AutoIt написании Player'a инструкций для бота математике 2D, как ориентироваться в декартовой системе координат без теоремы косинусов управлении роботом при недостаточном количестве датчиков мерах противодействия ботам Изменение от 14.08 Добавил ссылку на вторую часть.", "image": ["https://habrastorage.org/getpro/habr/post_images/92b/bc0/f47/92bbc0f4733832ea8ffd80ba6c6c16e5.gif", "https://habrastorage.org/getpro/habr/post_images/87f/68d/785/87f68d785d1353bf3f5a6fa82b5a4a93.gif", "https://habrastorage.org/storage2/688/ca7/3b9/688ca73b9eb240ae0bec1b894b60dc96.jpg", "https://habrastorage.org/getpro/habr/post_images/4d5/35d/bdd/4d535dbddaa661486fa33e6d7258872d.gif"], "tag": ["Lua", "World of Warcraft", "WoW", "бот", "AutoIt", "Addon", "робототехника", "tutorial"], "rating": ["+54"], "bookmarks": ["296"], "views": ["55,3k"], "comments_count": ["39"]},
{"author": ["DreamerUA"], "date": [" 9 января 2014 в 17:53"], "hubs": ["Lua", "Node.JS", "Разработка игр"], "type_label": [], "text": "Однажды с коллегой столкнулись с проблемой реализации рилтайм мультиплеера на CoronaSDK. Сначала попробовали сервис pubnub.com, но со временем поняли, что не устраивает их latency (у них все через http) и цены. Не найдя ничего получше, решили на скорую руку создать на Node.js свой велосипед (или скорее самокат, потому как весь серверный код умещается в 90 строк с комментариями). Назвали в шутку NoobHub. Распространяется под лицензией WTFPL. Штука получилась весьма быстрой и, судя по отзывам пользователей, способной крутиться месяцами на сервере без перезапусков и утечек памяти. Системные требования: Node.js 0.6.x и выше (входит в стандартный пакет Ubuntu), никаких дополнительных модулей не требуется. Если Вы пишете мобильное мультиплеер приложение на Lua используя CoronaSDK, Moai или Gideros, то есть хорошие новости: клиент под эти SDK отлично работает, бери и пользуйся. Несколько фактов: Выпущено несколько десятков приложений от разных разработчиков, все хвалят (косячить нечему). Вот к примеру частый гость российских топов, Durak HD Написать свой клиент для любого языка, где есть сокеты — проще простого Lua код может служить примером работы с LuaSocket В демо проект захардкоджен мой тестовый сервер, так что даже ничего поднимать ненадо чтобы потестить (количесто тестящих периодически поднимается до 200 CCU. Я надеюсь никто по ошибке не использует его в продакшене, на том сервачке всего 64 Mb RAM...) Использование Запустили сервер: $ node server.js На клиенте создали объект: hub = noobhub.new({ server = \"127.0.0.1\"; port = 1337; }); Подписались на канал, в колбек-функции обрабатываем сообщение других участников: hub:subscribe({ channel = \"hello-world\"; callback = function(message) if(message.action == \"ping\") then print(\"Pong!\") end; end; }); Отправили сообщение: hub:publish({ message = { action = \"ping\", timestamp = system.getTimer() } }); Занудные подробности Ключевым элементом Node.js скрипта является объект server, который слушает порт и реагирует на соединения. Для каждого из них создаётся socket с уникальным хешем для последующего поиска и удаления в случае необходимости. Сокеты в свою очередь слушают события получения данных и закрытия соединения. Они распознают два типа сообщений: __SUBSCRIBE____ENDSUBSCRIBE__ — подписка на канал, __JSON__START_<_MESSAGE>__JSON__END__ — произвольное сообщение. При подписке сокет добавляется в пул CHANNELNAME и все последующие сообщения приходящие по данному каналу будут передаваться и новоприбывшему. Во втором случае тело MESSAGE будет адресовано всем подписчикам канала CHANNELNAME. Для отсоединения достаточно закрыть сокет на стороне клиента, а дальше сервер знает, что делать с дезертиром. Получается, что один EventLoop ноды делает всю работу по получению данных и расфасовке их клиентам в сокеты. Если клиентов будет много, соответственно увеличенный цикл будет вносить задержку в доставку сообщений. Вопрос конечно, сколько надо клиентов чтобы просадка была хоть сколько-то заметной. При 2к CCU просадки latency не наблюдалось (больше у нас просто небыло), но я сомневаюсь что и 20к даст заметную просадку. На клиенте все с точностью до наоборот, клиент подключается к socket серверу, подписывается на канал, и асинхронно слушает сообщения от других участников канала. Есть автоматический reconnect & resubscribe при обрыве (облегчает жизнь юзерам с плохим коннектом на EDGE/3G). Итого: простой Publish-Subscribe для небольших и даже средних проектов. Исходный код сервера и клиентов: https://github.com/Overtorment/NoobHub", "image": [], "tag": ["gamedev", "lua", "publish-subscribe", "node.js", "socket"], "rating": ["+8"], "bookmarks": ["18"], "views": ["3k"], "comments_count": ["4"]},
{"author": ["ciklum_dev"], "date": ["11 декабря 2013 в 15:01"], "hubs": ["Lua", "Блог компании Ciklum"], "type_label": [], "text": "Компания Ciklum с продолжает ряд открытых мероприятий под названием Speakers’ Corner на которых, за короткое время можно узнать массу полезной информации и пообщаться с единомышленниками в неформальной обстановке. На этот раз 16го декабря мы приглашаем всех желающих расширить свои гоизонты и погрузиться в мир Lua, получить краткий обзор и узнать о его возможностях. Проливать луч света на Lua и открывать новые горизонты будет Владимир Безобюк (Senior Linux Developer, IntroPro). Мероприятие будет разделено на 2 части: теоритическую и примеры на практике. 1. Коротко об истории языка 2. Выбор — за и против. а) Преимущества; для каких задач подходит б) Недостатки; для каких задач мало подходит в) сообщество 3. Обзор языка а) императивность б) функциональность в) метапрограммирование г) embedding (Хоббит: путешествие за Сишные Коды, или Туда и Обратно) д) ООП а) красота в простоте б) производительность 4. Практика в) минимализм во всем, или где брать батарейки, ведь с языком идет мало библиотек? г) особенности реализации и альтернартивные реализации (LuaJIT, llvm-lua) б) цейтнот — Lua спешит на помощь в) действительно ли трудно мыслить функциональными парадигмами: I) функции высшего порядка и замыкания на практике II) корутины (сопроцедуры) на практике III) метапрограммирование на практике г) хвостовая рекурсия д) многопоточность для Lua — библиотека LuaLanes е) ООП advanced В общем будет масса полезной информации и дельных советов от человека, который более Lua =) Мероприятие бесплатное по предварительной регистрации goo.gl/sF4w07 Когда: 16 декабря Время: 19.00- 21.00 Место проведения: Киев, ул.Амосова 12, БЦ Горизонт, 2я башня, 20ый этаж, офис компании Ciklum", "image": ["https://habrastorage.org/getpro/habr/post_images/872/a1d/b41/872a1db4104f6966a375205d194eec15.jpg"], "tag": ["ciklum", "lua"], "rating": ["+4"], "bookmarks": ["13"], "views": ["5,5k"], "comments_count": ["10"]},
{"author": ["Evengard"], "date": [" 3 июня 2013 в 23:13"], "hubs": ["Lua", "ООП", "Ненормальное программирование"], "type_label": [], "text": "Как всем известно, в lua нет как таковых классов и объектов. Однако есть метатаблицы и синтаксический сахар. С помощью указанных механизмов достаточно просто реализовать подобие классов. В итоге и получается нечто такое: Самый простой классlocal MyClass = {} -- the table representing the class, which will double as the metatable for the instances MyClass.__index = MyClass -- failed table lookups on the instances should fallback to the class table, to get methods -- syntax equivalent to \"MyClass.new = function...\" function MyClass.new(init) local self = setmetatable({}, MyClass) self.value = init return self end function MyClass.set_value(self, newval) self.value = newval end function MyClass.get_value(self) return self.value end local i = MyClass.new(5) -- tbl:name(arg) is a shortcut for tbl.name(tbl, arg), except tbl is evaluated only once print(i:get_value()) --> 5 i:set_value(6) print(i:get_value()) --> 6 (взято с lua-users.org/wiki/ObjectOrientationTutorial) Всё это конечно хорошо, даже при определённой сноровке можно реализовать наследование… Но где public и private члены класса? Дефакто в этом примере они все public. Да ещё и надо помнить, где использовать двоеточие: MyClass:myFunc() а где просто одну точку: MyClass.myOtherFunc() А статические члены класса? Неужели придётся отказываться? Вот я и не захотел отказываться, и начал колхозить… Итак, представляю вам мой колхоз: Мой колхозcreateClass = function() local creator = {} creator.__private = { object_class = {}, } creator.__oncall = function(class_creator) -- Get the class definition so we can make needed variables private, static, etc. local this = class_creator() -- Initialize class from class definition __init = function() -- Init Public Static local class = {} if (type(this.__public_static) == \"table\") then class = this.__public_static end -- Init Object local thisClass = this local __constructor = function(...) local object = {} local this = class_creator() -- Init Public if (type(this.__public) == \"table\") then object = this.__public end -- Init static values of the class this.__public_static = thisClass.__public_static this.__private_static = thisClass.__private_static -- Call Constructor if (type(this.__construct) == \"function\") then this.__construct(...) end -- Returning constructed object return object end return {class = class, constructor = __constructor} end -- Creating class (returning constructor) local class_data = __init() local class = class_data.class local constructor = class_data.constructor -- Set class metatable (with setting constructor) local class_metatable = { __newindex = function(t, key, value) if type(t[key])==\"nil\" or type(t[key])==\"function\" then error(\"Attempt to redefine class\") end rawset(t, key, value) end, __metatable = false, __call = function(t, ...) if type(t) == nil then error(\"Class object create failed!\") end local obj = constructor(...) creator.__private.object_class[obj] = t local object_metatable = { __newindex = function(t, key, value) class = creator.__private.object_class[t] if type(class[key])~=\"nil\" and type(class[key])~=\"function\" then rawset(class, key, value) return end if type(t[key])~=\"nil\" and type(t[key])~=\"function\" then rawset(t, key, value) return end error(\"Attempt to redefine object\") end, __index = t, __metatable = false, } setmetatable(obj, object_metatable) return obj end, } -- Setting class metatable to the class itself setmetatable(class, class_metatable) -- Returning resulting class return class end return creator.__oncall end createClass = createClass() А пользоваться как? Очень просто, вот вам шаблон: myclass_prototype = function() local this = {} this.__public_static = { -- Public Static Variables statvalue = 5, -- Public Static Funcs statfunc = function() print(this.__public_static.statvalue) end, } this.__private_static = { -- Private Static Variables privstatdat = 2, -- Private Static Funcs privstatfunc = function() print(this.__private_static.privstatdat) end, } this.__public = { -- Public Variables pubdata = 3, -- Public Funcs pubfunc = function(newprivate) print(this.__public.pubdata) this.__private.privdata = newprivate end, } this.__private = { -- Private Variables privdata = 1, -- Private Funcs listallprivate = function() print(this.__private.privdata) end, } this.__construct = function() -- Constructor end return this end myclass=createClass(myclass_prototype) Как видите, при каждом вызове изнутри класса придётся каждый раз указывать путь, а ля «this.__private.privdata», зато вот вам пример использования созданного класса! myobject = myclass() myobject.pubfunc(999) При вызове этого кода будет создан объект myobject из класса myclass, и будет вызвана функция pubfunc, которая высветит содержимое публичной переменной и изменит приватную. И никаких заморочек с двоеточиями! Кстати, статические вызовы тоже работают. Как из класса, так и из объекта. Итак, вкратце расскажу, что за магия здесь происходит. А происходит тут жонглирование так называемыми upvalues. upvalues — это переменные, которые изнутри видны, а снаружи — нет! Очень похоже на private, не так ли? Так вот, создав функцию-«прототип», мы создали новую область видимости, и в неё поместили все внутренности нашего класса, вынеся наружу только public и public static члены класса. А всю остальную магию выполняют метатаблицы, которые позволяют определить, что именно будет происходить при запросе «несуществующего» члена внешней таблицы, которая представляет наш класс/объект. Сумбурно звучит, знаю, но лучше не могу объяснить — не спец :) Долго думал, как можно сделать наследование при такой системе, но так и не придумал — upvalues достаточно серьёзно ограничивает наши действия, а извращенствами вроде debug библиотеки пользоваться не хотелось — она не везде включена. Если кто додумается, буду рад увидеть! PS: если для кого-то мой пост нечто очевидное — чтож, значит я себя переоценил :) Не судите строго, может кому-то зачем-то пригодится это решение!", "image": [], "tag": ["lua", "классы", "ооп", "мсье знает толк в извращениях", "колхоз"], "rating": ["0"], "bookmarks": ["31"], "views": ["15k"], "comments_count": ["13"]},
{"author": ["yegorf1"], "date": ["21 декабря 2013 в 21:58"], "hubs": ["Lua", "Разработка игр", "Программирование"], "type_label": ["Tutorial"], "text": "В предыдущем посте я рассказал как рисовать картинки и, вроде как, объяснил, что к чему в love2d. Сегодня я решил написать змейку, всем, кому интересно, прошу под кат. Запускаем Sublime Text 2, как его настроить для love я говорил в прошлый раз, но сегодня мы будем использовать дебаг, но для этого нужно написать три лишних строки, а именно: Рядом с main.lua, в корне каталога проекта, создаем файл и называем его conf.lua. Этот файл предназначен для настроек игры. В нем пишем такой вот код:function love.conf(t)--Функция которую вызывает love перед стартом приложения io.stdout:setvbuf(\"no\")--Из-за особенностей Sublime Text, точнее его консольки нужно вызывать эту функцию, --иначе все что мы выводим с помощью print(str) будет выведено после закрытия игры. end Подробнее об этой функции можно почитать здесь, и здесь. Ну а теперь код Подготовим переменные: local apple, snake, direction, width, height, delay function love.load() width = love.graphics.getWidth() / 10 --функция возвращает длину окна на данный момент print(\"Width \" .. width) --дебаг вывод height = love.graphics.getHeight() /10 --тоже самое но с высотой print(\"Height \" .. height) apple = { x = math.random() % width; --теперь нам нужно яблоко генерируем X-координату y = math.random() % height; } --и Y.. snake = { } --инициализируем таблицу с координатами змейки for i = 1, 10 do --первые 10 клеток надо с чего-то начинать point = { x = 10; --и снова X.. y = 10 + i; } --и Y.. table.insert(snake, point) --вписываем в таблицу end direction = \"up\" --змейка должна куда-то ползти delay = 0 --змейка не должна быть нервной end Вроде бы все объяснил, для тех кто хоть раз писал змейку должно быть понятно все. Теперь нам нужно рисовать змейку (Пока что без яблока); function love.draw() love.graphics.setBackgroundColor(0, 0, 0) --чистим экран for k, v in pairs(snake) do --отрисовываем каждую клетку love.graphics.rectangle(\"fill\", v.x * 10, v.y * 10, 10, 10) end end А теперь должны возникнуть вопросы, а именно: 1) А какого цвета будет змейка 2) (Менее интересный) Что это за функция love.graphics.rectangle? Ответы: 1) Она будет рисоваться белым, этот цвет ставиться внутри сишного кода перед вызовом love.draw(). Если вам этот цвет можно поставить вот таким вот методом: love.graphics.setColor(0, 0, 255) --змея будет синей У этой функции четыре аргумента, но четвертый не является обязательным — это альфа цвета. Подробное описание вот здесь. 2) Как можно догадаться из названия, эта функция рисует четырехугольник цвета заданным этой функции. Первый аргумент — режим рисования, может быть «fine» или «line». Второй и третий аргумент координаты, Четвертый и пятый — размеры, подробно вот тут. Можем продолжить Ура! У нас есть неподвижная змейка, давайте потыкаем ее исправим это, напишем Update функцию: function love.update(dt) if delay % 2 == 0 then --лечим нервы table.remove(snake, table.getn(snake)) --убираем последний элемент и добавляем его в начало if direction == \"up\" then --ну тут вроде все ясно, обрабатываем направление table.insert(snake, 1, { x = snake[1].x; y = (snake[1].y - 1) % height; }) elseif direction == \"down\" then table.insert(snake, 1, { x = snake[1].x; y = (snake[1].y + 1) % height; }) elseif direction == \"left\" then table.insert(snake, 1, { x = (snake[1].x - 1) % width; y = snake[1].y; }) else table.insert(snake, 1, { x = (snake[1].x + 1) % width; y = snake[1].y; }) end end delay = delay + 1 end Теперь у нас неуправляемая змейка, это тоже не то, чего мы добиваемся, так добавим власти: function love.keypressed(key) --здесь мы будем смотреть какая кнопка была нажата --выглядит стремно, но правильно if key == \"up\" then direction = \"up\" elseif key == \"down\" then direction = \"down\" elseif key == \"left\" then direction = \"left\" elseif key == \"right\" then direction = \"right\" elseif key == \"escape\" then love.event.quit() end end Теперь мы управляем происходящим, но где цель? Добавим-же яблок: Во-первых, яблоко у нас есть, но мы его не рисуем, добавим прорисовку в love.draw(): love.graphics.setColor(255, 255, 0) --мне нравиться голд love.graphics.rectangle(\"fill\", apple.x * 10, apple.y * 10, 10, 10) А теперь нам надо расти: if delay % 2 == 0 then --лечим нервы if apple.x == snake[1].x and apple.y == snake[1].y then apple = { x = math.random(width); --вот и поели, генерируем X-координату y = math.random(height); } --и Y.. else --не сразу ясно, но понятно table.remove(snake, table.getn(snake)) --убираем последний элемент и добавляем его в начало end if direction == \"up\" then --ну тут вроде все ясно, обрабатываем направление table.insert(snake, 1, { x = snake[1].x; y = (snake[1].y - 1) % height; }) elseif direction == \"down\" then table.insert(snake, 1, { x = snake[1].x; y = (snake[1].y + 1) % height; }) elseif direction == \"left\" then table.insert(snake, 1, { x = (snake[1].x - 1) % width; y = snake[1].y; }) else table.insert(snake, 1, { x = (snake[1].x + 1) % width; y = snake[1].y; }) end end delay = delay + 1 Ползаем, контролируем, поедаем, все готово! Спасибо, за прочтение. Исходники, с небольшим аддономом. Буду благодарен за любые отзывы (:", "image": ["https://habrastorage.org/getpro/habr/post_images/1c1/0aa/f56/1c10aaf5655a3c0070f7c21414c242f4.png"], "tag": ["Gamedev", "lua", "love2d", "tutorial"], "rating": ["+18"], "bookmarks": ["97"], "views": ["23,2k"], "comments_count": ["16"]},
{"author": ["yegorf1"], "date": ["18 ноября 2013 в 13:38"], "hubs": ["Lua", "Разработка игр", "Программирование"], "type_label": ["Tutorial"], "text": "Что же такое Love2d и о чем этот пост? Это кроссплатформенный фреймворк для разработки 2d игр. Почему именно love2d? Потому что это бесплатный, легкий, кроссплатформенный, с открытым исходным кодом, а главное сделанный с любовью движок. Подготовка Писать игры на нем можно хоть в блокноте, но я буду использовать Sublime Text 2, так как он прост и гибок. Скачать love можно вот здесь под все популярные десктопные платформы. Запускаем Sublime text и сразу идем в Tools->Build System->New Build System… И пишем туда вот такое: { \"selector\": \"source.lua\", \"cmd\": [\"c:\\\\Program Files\\\\LOVE\\\\love\", \"${project_path:${folder}}\"] } (Если у вас x64 меняем путь к love) Это для удобства запуска, теперь все, что нужно это нажать Ctrl+B. Создаем папку где мы будем хранить нашу игру. В ней создаем main.lua. В этом файле будет хранится основа нашей игры. А в Sublime text добавляем папку в проект. Все готово. Должно получиться что то вроде этого: . Хочу код! Вся логика будет обновляться в функции love.update(dt), а прорисовка у нас в love.draw(), инициализация происходит love.load(). Поэтому давайте сразу напишем их: function love.load() end function love.update(dt) end function love.draw() end Теперь давайте добавим загрузим картинку и сразу ее нарисуем. Картинки загружаются с помощью функции love.graphics.newImage(filename), а рисуются в love.graphics.draw(image, x, y). Добавляем в папку вот эту картинку. И пишем код: local habrImage, width, height function love.load() habrImage = love.graphics.newImage(\"habr.png\") width = love.graphics.getWidth() height = love.graphics.getHeight() end function love.update(dt) end function love.draw() love.graphics.draw(habrImage, width / 2 - habrImage:getWidth() / 2, height / 2 - habrImage:getHeight() / 2) end Ctrl + B и у нас что-то не красивое, давайте подправим и сделаем фон белым. Добавим в начале отрисовки вот такую строчку: love.graphics.setBackgroundColor(255, 255, 255) И вот, приятная глазу, картинка. Это все, конечно круто, но давайте добавим жизни нашей игре и сделаем действия с картинкой, а именно: — По клавише R картинка будет крутится — По клавише S картинка будет увеличиваться\\уменьшаться — По клавише M картинка будет двигаться. Чтобы это реализовать, добавим переменные state (будет отвечать за происходящие), rotation (угол картинки), scale (ее размер), ox, ox (смещение центра картинки) и delta(эта переменная будет отвечать за апдейт переменных). Теперь о инпуте, в love когда клавиша опускается вызывается функция love.keypressed(key, unicode), а при поднятии love.keyreleased(key). Мы будем отслеживать опускание клавиш. Теперь сам код: local habrImage, width, height, state, rotation, scale, ox, oy, delta --инициализируем все function love.load() habrImage = love.graphics.newImage(\"habr.png\") width = love.graphics.getWidth() height = love.graphics.getHeight() state = \"none\" resetVariables() end --никто не любит писать одно и тоже много раз function resetVariables() rotation = 0 scale = 1 ox = 0 oy = 0 delta = 1 end --смотрим что было нажато function love.keypressed(key, unicode) if key == \"r\" then state = \"rotation\" resetVariables() elseif key == \"s\" then state = \"scalling\" resetVariables() elseif key == \"m\" then state = \"moving\" resetVariables() elseif key == \"space\" then -- чтобы не залипать (: state = \"none\" resetVariables() end end --логика игры function love.update(dt) if state == \"rotation\" then --крутим картинку rotation = rotation + delta * dt elseif state == \"scalling\" then --увеличиваем scale = scale + delta * dt elseif state == \"moving\" then --здесь немного посложнее, но все же просто: --каждый раз мы увеличивыем дельту --а потом берем ее за угол для косинису и синуса --и крутим картинку delta = delta + delta * dt local radius = 50 ox = radius * math.sin(delta) oy = radius * math.cos(delta) end end --рисуем function love.draw() --рисуем белым love.graphics.setBackgroundColor(255, 255, 255) --рисуем картинку love.graphics.draw(habrImage, width / 2 - habrImage:getWidth() / 2, height / 2 - habrImage:getHeight() / 2, rotation, scale, scale, ox, oy) end На этом все, господа. Удачи с созданием игр! Для помощи вот вам вики и офф сайт. Продолжение. З.Ы. Это все писалось на 0.8.0. З.З.Ы. Не забудьте выбрать Build System, чтобы запускать.", "image": ["https://habrastorage.org/getpro/habr/post_images/605/746/7b0/6057467b0adbccd39716d5223ffc05e5.png", "https://habrastorage.org/getpro/habr/post_images/592/b0d/fb1/592b0dfb19d41df0bc4256f01114fc9c.png"], "tag": ["Gamedev", "lua", "love2d", "tutorial"], "rating": ["+14"], "bookmarks": ["118"], "views": ["32,1k"], "comments_count": ["25"]},
{"author": ["avalak"], "date": [" 1 февраля 2011 в 15:16"], "hubs": ["Ненормальное программирование", "Lua"], "type_label": [], "text": "Каждый программист за свою жизнь успевает изучить множество языков, в нескольких из них специализируется и продолжает работать продолжительное время, а остальные проходят мимо. По разным причинам. Стоит ли тратить время на изучение новых языков, когда уже определился с областью в которой будешь работать? Лично я уверен что стоит, хотя, быть может, многие скажут что важны фундаментальные знания в computer science, а на каком языке писать код не критично. В сущности так и есть. И тем не менее изучать языки интересно и полезно. Lua. Краткая история языка. Своё начало язык Lua ([луа], порт. «луна») берёт в относительно далёком 1993 году. Его создали Роберто Иерусалимши (Roberto Ierusalimschy), Луис Энрике де Фигуэйредо (Luiz Henrique de Figueiredo) и Вальдемар Селес (Waldemar Celes), в то время члены группы разработки технологии компьютерной графики (Tecgraf) Епископального католического университета Рио-де-Жанейро (Pontifical Catholic University of Rio de Janeiro) в Бразилии. Это скриптовый язык, сочетающий свойства императивных и функциональных языков и обладающий объектно-ориентированными свойствами. Испытал влияние Scheme, SNOBOL, JavaScript, C/C++ и других. В результате получился встраиваемый, легко расширяемый скриптовый язык с простым синтаксисом. За годы существования Lua обрёл популярность именно как встраиваемый язык: множество программ, но ещё больше игр используют его. Например Vim (с версии 7.3), World of Warcraft, Ragnarok Online и многие другие Немного о языке Лучше всего написано тут www.lua.ru/doc (rus) и тут www.lua.org/manual/5.1 (eng) Устанавливаем Lua Скачать Lua можно тут luabinaries.sourceforge.net/download.html Под Linux (правда в репозитории Ubuntu 10.04 есть аж три версии) sudo apt-get install lua5.1 sudo apt-get install lua50 sudo apt-get install lua40 Либо собрать из исходников (название пакета lua5.1 было совсем не очевидно, поэтому пришлось собрать) cd /tmp wget http://www.lua.org/ftp/lua-5.1.4.tar.gz tar -xf lua-5.1.4.tar.gz cd lua-5.1.4 sudo apt-get install build-essential libreadline5-dev make linux test sudo checkinstall --fstrans=no --install=no --pkgname=lua --pkgversion \"5.1.4\" --default sudo dpkg -i lua_5.1.4-1_i386.deb lua -v >>> Lua 5.1.4 Copyright (C) 1994-2008 Lua.org, PUC-Rio Замечательно, теперь можно начинать развлекаться. Hello World! С чего начать изучение языка? С Hello world! не интересно. Давайте напишем интерпретатор. Есть такой замечательный язык Brainfuck, очень простой и очень интересный. Помогает размять мозг. Ставим задачу: Чтение brainfuck кода из файла Базовая валидация кода Исполнение Brainfuck кода Описание Brainfuck В «классическом» Brainfuck, описанном Урбаном Мюллером, размер ячейки — один байт, количество ячеек 30 000, ввод/вывод происходит побайтово, количество инструкций 8 шт. ниже краткое описание: \">\" перейти к следующей ячейке \"<\" перейти к предыдущей ячейке \"+\" увеличить значение в текущей ячейке на 1 \"-\" уменьшить значение в текущей ячейке на 1 \".\" напечатать значение из текущей ячейки \",\" ввести извне значение и сохранить в текущей ячейке \"[\" если значение текущей ячейки нуль, перейти вперёд по тексту программы на ячейку, следующую за соответствующей \"]\" (с учётом вложенности) \"]\" если значение текущей ячейки не нуль, перейти назад по тексту программы на символ \"[\" (с учётом вложенности) Пишем Начнём с малого: создадим каталог для работы, файл brainfuck.lua в нём, сделаем его исполняемым #!/usr/bin/env lua -- Lua Brainfuck Interpreter Brainfuck = { -- validate source -- Return 1 if closing bracket(s) missing. -- Return 2 if opening bracket(s) missing. -- Return 0 otherwise. validate = function (self, source) return 0 end, -- debug function showError = function (self, errorCode) end, -- brainfuck function brainfuck = function (self, source) end, } Также создадим файл hello.b (код на brainfuck. выводит Hello World! на экран. нужен для тестов) ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>. Ну, теперь всё готово. 1. Чтение brainfuck кода из файла. Пусть наш интерпретатор выполняет код из файла имя которого передано в командной строке ./brainfuck.lua hello.b Документация скажет нам что Lua помещает параметры в массив arg -- start here if arg[1] then -- read source from file in arg[1] source = io.input(arg[1]):read(\"*a\") -- get error code (0 == no error) errorCode = Brainfuck:validate(source) -- if no error run source else show error if errorCode == 0 then Brainfuck:brainfuck(source) else Brainfuck:showError(errorCode) end else print(\"Usage: ./brainfuck.lua script\") Brainfuck:showError(3) end 2. Базовая валидация кода -- validate source -- Return 1 if closing bracket(s) missing. -- Return 2 if opening bracket(s) missing. -- Return 0 otherwise. validate = function (self, source) local i, errorCode, l = 0, 0, 0 for i = 1, string.len(source), 1 do -- [ 91 if string.byte(source, i) == 91 then l = l + 1 -- ] 93 elseif string.byte(source, i) == 93 then l = l - 1 if l < 0 then return 2 end end end if l > 0 then return 1 elseif l < 0 then return 2 else return 0 end end, -- debug function showError = function (self, errorCode) if errorCode == 1 then print(\"Error: Closing bracket(s) missing.\") elseif errorCode == 2 then print(\"Error: Opening bracket(s) missing.\") elseif errorCode == 3 then print(\"Error: No source file.\") else print(\"Error: Unknown error code.\") end end, 3. Исполнение Brainfuck кода -- brainfuck function brainfuck = function (self, source) -- memSize: Brainfuck memory size (30k) -- maxVal: Max memory value (255) byte -- mem: Memory table (array) -- pointer: default 0 -- l: default 0. braket level counter local memSize, maxVal, mem, pointer, l = 30000, 255, {}, 0, 0 -- clear memory for i = 0, memSize, 1 do mem[i] = 0 end -- execute program i = 0 while i <= string.len(source) do i = i + 1 -- + 43 C eqv ++(*p); if string.byte(source, i) == 43 then if mem[pointer] < maxVal then mem[pointer] = mem[pointer] + 1 end -- - 45 C eqv --(*p); elseif string.byte(source, i) == 45 then if mem[pointer] > 0 then mem[pointer] = mem[pointer] - 1 end -- , 44 C eqv *p = getchar(); elseif string.byte(source, i) == 44 then mem[pointer] = string.byte(io.stdin:read('*l'), 1) -- . 46 C eqv putchar(*p); elseif string.byte(source, i) == 46 then io.write(string.char(mem[pointer])) -- < 60 C eqv --p; elseif string.byte(source, i) == 60 then pointer = pointer - 1 if pointer < 0 then pointer = 0 end -- > 62 C eqv ++p; elseif string.byte(source, i) == 62 then pointer = pointer + 1 if pointer > memSize then pointer = memSize end -- [ 91 C eqv while (*p) { elseif string.byte(source, i) == 91 then if mem[pointer] == 0 then while (string.byte(source, i) ~= 93) or (l > 0) do i = i + 1 if string.byte(source, i) == 91 then l = l + 1 end if string.byte(source, i) == 93 then l = l - 1 end end end -- ] 93 C eqv } elseif string.byte(source, i) == 93 then if mem[pointer] ~= 0 then while (string.byte(source, i) ~= 91) or (l > 0) do i = i - 1 if string.byte(source, i) == 91 then l = l - 1 end if string.byte(source, i) == 93 then l = l + 1 end end end else -- print(\"Unknown symbol\") -- return end -- print(\"Debug: l=\"..l..\" cmd=\"..string.char(string.byte(source, i))) end end, Готовая версия Готово. Теперь можно запустить пример и убедиться что всё работает. Как видите Lua вполне пригоден для standalone использования) Прошу прощения за отсутствие отступов. Утеряны при подстветке. Блога о Lua не нашел, поэтому размещу в Ненормальное программирование. Если статьи о Lua интересны сообществу могу написать ещё Полезная литература About Lua ru.wikipedia.org/wiki/Lua About Brainfuck ru.wikipedia.org/wiki/Brainfuck Документация на русском www.lua.ru/doc Документация на английском www.lua.org/manual/5.1 The Programming Language Lua www.lua.org Downloads luabinaries.sourceforge.net/download.html", "image": ["https://habrastorage.org/storage2/1ba/886/29d/1ba88629d01727b7fce7ca5e363c2707.gif"], "tag": ["lua", "brainfuck", "interpreter", "just for fun"], "rating": ["+29"], "bookmarks": ["29"], "views": ["5,5k"], "comments_count": ["15"]},
{"author": ["Xitsa"], "date": ["17 июля 2010 в 21:01"], "hubs": ["Алгоритмы", "Lua"], "type_label": ["Перевод"], "text": "Роберто Иерусалимши рассказывает, как эффективно соединять немодифицируемые строки. Несмотря на то, что код написан на Lua, алгоритм подойдёт и для других языков, в которых строки нельзя изменять. Пролог В Lua, «накопление» результатирующей строки (т.е. цикл с телом вида s = s..x) может быть крайне затратным по ресурсам. Данная записка описывает эффективный способ создания строки по частям в Lua. Проблема Допустим, что вы составляете строку по частям, например, считывая из файла строку за строкой. Типичный код может выглядеть так: -- WARNING: bad code ahead!! local buff = \"\" while 1 do local line = read() if line == nil then break end buff = buff..line..\"\\n\" end Несмотря на невинный вид, такой код на Lua может вызвать существенную потерю производительности для больших файлов: например, для чтения 350Кб файла требуется почти минута. Часто это не проблема. Для маленьких строк подобный цикл это нормально. Чтобы прочитать файл целиком, можно использовать опцию «*all», которая позволит считать файл целиком. Но иногда такого простого решения нет. В таком случае, единственным решением является более эффективный алгоритм для этой проблемы. Здесь мы покажем его (алгоритм, не проблему). Решение Сердцем алгоритма является стек, который хранит большие строки внизу, а маленькие строки приходят сверху. Главный инвариант такого стека похож на популярную (среди программистов) «Ханойскую Башню»: строка в стеке не может находиться поверх более короткой. Когда новая строка помещается поверх более короткой, тогда (и только тогда) алгоритм объединяет их вместе. Объединение строк создаёт большую строку, которая может быть больше, чем её соседка с нижнего этажа. Если такое произошло, то полученная строка и соседка снизу также объединяются. Эти объединения идут вниз по стеку, пока цикл не достигнет большей строки или дна стека. function newBuffer () return {n=0} -- 'n' counts number of elements in the stack end function addString (stack, s) tinsert(stack, s) -- push 's' into the top of the stack for i=stack.n-1, 1, -1 do if strlen(stack[i]) > strlen(stack[i+1]) then break end stack[i] = stack[i]..tremove(stack) end end Чтобы получить окончательный результат, нам надо просто объединить все строки сверху до низу: function toString (stack) for i=stack.n-1, 1, -1 do stack[i] = stack[i]..tremove(stack) end return stack[1] end Используя нашу новую структуру данных, мы можем переписать программу следующим образом: local s = newBuffer() while 1 do local line = read() if line == nil then break end addString(s, line..\"\\n\") end s = toString(s) Эта программа уменьшила время чтения 350Кб файла с 40 секунд до 0.5 секунды. Вызов read \"*all\" всё ещё быстрей, выполняя то же самое за 0.02 секунды). Объяснение Чтобы понять, что происходит, когда мы применяем наивный подход, предположим, что мы в середине процесса чтения; buff уже содержит строку размером 50Кб и каждая строка размером в 20 байт. После операции конкатенации buff = buff..line..\"\\n\" переменная buff содержит уже 50020 байт, а старая строка стала мусором. После двух итераций цикла, buff уже содержит 50040 байт, и уже две строки образуют больше чем 100Кб мусора. Таким образом, Lua решает, совершенно правильно, что пора запустить сборщик мусора, и освобождает эти 100Кб. Проблема в том, что это происходит каждые две итерации, и Lua запустит сборщик мусора две тысячи раз до того, как закончится цикл. И даже со всеми этими действиями, потребление памяти будет в три раза больше, чем размер файла. И что ещё хуже, каждая конкатенация должна скопировать содержимое всей строки (50Кб и больше) в новую строку. Эта проблема не только Lua: другие языки с настоящим сборщиком мусора, и где строки немодифицируемые объекты, ведут себя также (самый известный из которых Java). Наш первоначальный цикл использовал «линейный» подход к проблеме, объединяя маленькие строки одну за другой в переменную–аккумулятор. Новый алгоритм избегает этого, используя бинарный подход. Он объединяет множество маленьких строк друг с другом, и иногда объединяет получившуюся большую строку с другими большими строками. P.S. Примеры даны на достаточно старой версии Lua, и я (Xitsa) их не стал менять, так как смысл алгоритма достаточно ясен.", "image": [], "tag": ["lua", "immutable strings"], "rating": ["+18"], "bookmarks": ["32"], "views": ["4k"], "comments_count": ["32"]},
{"author": ["itruf"], "date": ["12 мая 2012 в 20:55"], "hubs": ["Разработка под iOS", "Lua", "Разработка игр"], "type_label": [], "text": "Недавно в App Store появились первые игры написанные прямо на iPad, что лично меня очень радует. Можно сказать, что планшет становится не только средством потребления контента, но и его производства. Под катом я расскажу, как и где это сделано, покажу простенький Hello World. За все, описанное выше, отвечает компания Two Lives Left, создавшая мобильную среду разработки Codea. Codea является приложением под айпад, которое содержит в себе удобный редактор кода и симулятор. Всю эту радость можно получить за 10$ в app store. Не мало, но это приложение стоит своих денег. Итак, начнем по порядку разбираться, что это и с чем его едят. Lua Codea использует язык программирования Lua. Lua (Wikipedia): По возможностям, идеологии и реализации язык ближе всего к JavaScript, однако Lua отличается более мощными и гораздо более гибкими конструкциями. Хотя Lua не содержит понятия класса и объекта в явном виде, механизмы объектно-ориентированного программирования с поддержкой прототипов (включая множественное наследование) легко реализуются с использованием метатаблиц, которые также делают возможной перегрузку операций и т. п. Реализуемая модель ООП (как и в JavaScript) — прототипная. Среда разработки Codea содержит в себе симпатичный редактор кода (возможно купить дополнительные оформления). Есть удобная надстройка над клавиатурой, которая позволит открыть базу знаний и расставить необходимые знаки. Доступен довольно большой набор спрайтов, которые уже успели адаптировать под ретина экран нового iPad. Симулятор Имеется довольно удобный встроенный симулятор, который может дать фору многим симуляторам других ОС на ПК. Есть место под указание параметров, что крайне удобно при оптимизации геймплея, возможность записать видео, либо сделать скриншот. Hello world Итак, после моего довольно долгого вступления, перейдем к делу. Я попробую показать насколько просто сделать маленький Hello World прямо на вашем iPad. Задача: сделать отображение разноцветных кругов под пальцами пользователя (своеобразный мультитач тест) Пожалуй, начнем. Первым делом направляемся в функцию, которая вызывается при запуске приложения и добавляем туда создание массива touches. function setup() touches = {} end Далее перемещаемся в функцию, которая отвечает за касания экрана (вызывается при появлении нового касания, который в Codea именуется просто touch). Во время прикосновения к экрану мы добавляем касание в массив, а во время его прекращения — убираем. Все крайне просто. function touched(touch) if touch.state == ENDED then touches[touch.id] = nil else touches[touch.id] = touch end end Итак, мы имеем массив активных касаний. Что нужно сделать следующим этапом? Правильно, изобразить круги с центром в точке касания. Для этого нам нужно перейти в функцию draw, которая вызывается во время отрисовки фрейма. function draw() -- цвет фона background(0, 0, 0, 255) -- изображаем для каждого касания из массива for k,touch in pairs(touches) do -- Указываем id касания (число) для инициализации генератора случайных чисел math.randomseed(touch.id) -- Это позволит нам иметь разный цвет для каждого касания fill(math.random(255),math.random(255),math.random(255)) -- Изображаем элипс (в нашем случае круг) в с центром в точке касания ellipse(touch.x, touch.y, 100, 100) end end Все, дело сделано. Результат: Эпилог Codea — это не инструмент для разработки чего-то ультрасложного и большого, но это идеальное подспорье для инди разработчиков, которые начинают открывать для себя рынок яблочной техники. Благо, что с недавнего времени появилась возможность публиковать свои Codea-приложения в магазине App Store, но, правда, не без помощи мака. И еще, хотелось бы сказать, что меня очень радует тенденция, которая появилась в последнее время. Появление новых языков на которых можно писать под iOS не может не радовать. Спасибо за внимание. Частично использован исходный код примера под названием «Multi Touch».", "image": ["https://habrastorage.org/getpro/habr/post_images/61d/385/c25/61d385c25f050c5b64ce4a6af0541053.png", "https://habrastorage.org/storage2/bfa/e98/53f/bfae9853f2aa5c732be6e9a68593f9de.png", "https://habrastorage.org/storage2/771/1fc/60e/7711fc60ebd58e0b1a46179ae9cb9d73.png", "https://habrastorage.org/storage2/0b0/620/425/0b0620425f3aee48130fa1e5216e4ecc.png", "https://habrastorage.org/storage2/b51/3f2/690/b513f2690e732f152133a89d5523650f.png"], "tag": ["iOS", "lua", "ipad", "мобильные приложения", "софт", "планшеты", "разработка", "game dev", "game development", "игры для ipad"], "rating": ["+53"], "bookmarks": ["175"], "views": ["12,8k"], "comments_count": ["39"]},
{"author": ["dtm"], "date": ["18 ноября 2012 в 20:54"], "hubs": ["Lua"], "type_label": [], "text": "По работе мне приходится ежедневно работать с большим количеством писем, и чтобы не упускать из виду важную информацию, их нужно сортировать. Первое время с этой задачей вполне себе справлялся настроенный Thunderbird на рабочей машине, но хотелось проверять почту не только на работе, но и дома, и еще где-нибудь — словом, в любом удобном месте при наличии желания и возможности. Стали появляться мысли о некоем серверном решении. Казалось бы — «все уже украдено до нас» (с) — связка fetchmail+procmail+(exim/postfix/sendmail и пр.)+mutt вполне себе рабочая и неплохо себя зарекомендовала, но мне не нужны были все возможности столь мощных почтовых программ, хотелось минимализма, простоты и функциональности. Как, наверное, многие из вас знают, mutt изначально умеет работать с почтовым сервером по протоколу imap, и замечательно проверяет почту своими силами (т.е. fetchmail нам уже не нужен), так же замечательно он умеет и отправлять почту через сторонний smtp-сервер (т.е. MTA тоже не нужен), остается только решить проблему фильтрации почты. И тут на помощь приходит он — imapfilter. Imapfilter, как очевидно из названия, фильтрует почту, соединяясь с почтовым сервером по протоколу IMAP. Возможности у этой программы воистину безграничные, с ее помощью можно делать практически все (создание/удаление/изменение папок, фильтрация/копирование/перемещение/удаление писем, установка различных флагов, сортировка и поиск писем и т.д.). Конфигурационный файл программы представляет собой набор правил, записанных на языке lua (после просмотра типовых примеров конфига и изучения мануала сложностей с написанием собственных правил быть не должно). Итак, небольшая инструкция по базовой настройке. Предположим, что у нас debian-подобная система. Ставим пакет imapfilter: $ sudo apt-get install imapfilter И после установки создаем в своей домашней директории папку .imapfilter, а в ней — конфигурационный файл с названием «config.lua»: $ mkdir ~/.imapfilter $ touch ~/.imapfilter/config.lua Теперь приступим к редактированию конфига. В качестве редактора пусть выступает стандартный Nano: $ nano ~/.imapfilter/config.lua Все, что начинается с \"--\" в конфигурационном файле считается комментариями и, соответственно, не обрабатывается. -- Таймаут (в секундах), в течение которого нужно ждать ответ от сервера -- timeout = 120 -- Сообщаем, что мы хотим вручную указать имена почтовых ящиков (читай, imap-каталогов) -- options.namespace = false -- Настройка учетной записи -- account_name = IMAP { server = 'mailserver.ru', username = 'your_login', password = 'your_pass', } Сюда же, если нужно, можно добавить поля 'ssl' и 'port', заполнив их необходимыми значениями. Далее определяем список папок, и проверяем текущий статус каталога с входящей почтой: mailboxes, folders = account_name:list_all() account_name:check_status() Опция «list_all()» вернет список всех доступных каталогов и подкаталогов в Вашем почтовом ящике, а опция «check_status()», соответственно, предоставит информацию о том, сколько в Вашем ящике всего писем, сколько отправленных, сколько непрочитанных (перед началом фильтрации необходимо убедиться, что у Вас уже созданы все необходимые каталоги, по которым Вы будете раскладывать почту, либо можно воспользоваться функцией «create_mailbox» для создания нового каталога). Затем мы определим переменную «results», которую будем использовать в дальнейшем для фильтрации почты: results = account_name.INBOX:select_all() Теперь можно переходить непосредственно к правилам. Грубо говоря, обычное правило будет выглядеть примерно так: res = results:contain_subject('hello') res:move_messages(account_name.folder) где: res — произвольное имя переменной, которая будет отвечать за письма, подходящие по условию; results:contain_subject('hello') — здесь осуществляется собственно процесс фильтрации; res:move_messages(account_name.folder) — действие, которое будет выполнено над письмами. Можно фильтровать письма по отправителю (contain_from), по получателю (contain_to), по теме (contain_subject), по полю «Копия» (contain_cc), по размеру (is_larger и is_smaller), по дате (is_older, например, если письмо старше какого-то определенного количества дней) и по куче других параметров (см. ссылку внизу страницы). После фильтрации письма можно копировать (copy_messages), перемещать (move_messages), помечать как прочитанное/непрочитанное/на удаление и пр., и удалять (delete_messages) Ну и в качестве примера, рассмотрим случай, когда письма от пользователя user@domain.ru будут копироваться в папку «user» в каталоге «Inbox», письма с темой «Hello, world» будут перемещаться в папку «spam», а все письма в папке work, которые старше 10 дней, будут удалены. res = results:contain_from('user@domain.ru') res:copy_messages(account_name.user) -- res = results:contain_subject('Hello, world') res:move_messages(account_name.spam) -- old = account_name.work:is_older(10) account_name.work:delete_messages(old) В процессе фильтрации можно использовать несколько условий одновременно, это реализуется с помощью логических операторов: \"+\" (логическое «ИЛИ»), \"*\" (логическое «И») и \"-\" (логическое «НЕ»): res = results:contain_subject('Hello, world')+ results:contain_from('user@domain.ru') res:move_messages(account_name.spam) Думаю, дальнейшая аналогия понятна. Еще Imapfilter может работать с подкаталогами в Вашем почтовом ящике (например, Inbox/work/1 или Inbox/work/2). В этом случае при выполнении действия над письмом запись пути к этому подкаталогу будет немного другой: res:move_messages(account_name['work/1'], results) В принципе, этих знаний уже достаточно, чтобы сортировать почту для большинства задач. После завершения настроек нужно соответствующим образом установить права доступа: 700 на каталог .imapfilter и 600 на файл конфига: $ chmod 700 ~/.imapfilter $ chmod 600 ~/.imapfilter/config.lua После завершения всех настроек запускаем imapfilter в режиме отладки и записью лога со следующими ключами: imapfilter -l logfile.log -d В домашней папке программы появится лог-файл с соответствующим названием, и файл с именем «Debug.*****», в котором будет вся информация по действиям программы — там можно посмотреть, какое правило и как сработало. И, напоследок, добавим в crontab строку * * * * * imapfilter чтобы наш фильтр запускался каждую минуту и красиво раскладывал почту по нужным папкам. Здесь можно ознакомиться со всеми опциями и параметрами, которые доступны в конфигурационном файле. На этом все, спасибо за внимание.", "image": [], "tag": ["linux", "imapfilter", "фильтрация почты"], "rating": ["+4"], "bookmarks": ["28"], "views": ["6,1k"], "comments_count": ["1"]},
{"author": ["alexac"], "date": ["14 января 2013 в 14:44"], "hubs": ["ООП", "Lua", "C++"], "type_label": [], "text": "Понадобилось мне прикрутить Lua к проекту на C++. Писать обертки в ручную — лень (слишком много писать), готовые не подходили по тем или иным причинам. Решил написать свою. А потому задался вопросом, как максимально упростить интерфейс? От одной только мысли об этом в голову лезли жутчайшие конструкции из шаблонов. Так оно в последствии и оказалось, но гораздо проще, чем представлялось. В C++11 появились шаблоны с переменным числом аргументов, это позволяет писать шаблонные функции/классы так, как в C++03 было невозможно вовсе. Такие шаблоны сильно упрощают задачу. Первым делом понадобилось написать обертку над простейшими действиями с интерпретатором (можно было бы обойтись простыми вызовами к C API Lua, но держать в памяти кучу индексов различных значений в стеке мне не хочется. Поэтому я обернул их в несколько функций, которые помимо того, что избавляют от необходимости передавать в каждую функцию указатель на состояние интерпретатора, практически не требуют индексов, так как они имеют значения по умолчанию. В итоге хотелось увидеть интерфейс близкий к следующему: lua.export_function(some_function); Можно попробовать. Однако интерфейс будет все-таки чуточку сложнее. Нужно указать интерпретатору имя для экспортируемой функции. И передавать будем адрес на функцию. lua.export_function(\"some_function\", &some_function); Воспользуемся выводом параметров шаблона. Параметры могут быть выведены автоматически, если они будут: Возвращаемым значением колбэка: template <typename T> void some_function(T (*callback)()) {} Параметром колбэка: template <typename T> void some_function(void (*callback)(T)) {} Классом, которому принадлежит метод. template <typename T> void some_function(void (T::*method)()) {} Все эти случаи (и еще несколько других), могут комбинироваться. Можно этим воспользоваться. template <typename R, typename... Args> void export_function(const std::string& name, T (*function)(Args...)) { } Теперь, можно взяться за собственно экспорт функции. Для каждой функции создадим лямбду, которая будет принимать аргументы от интерпретатора, передавать их в функцию, а потом, возвращать интерпретатору результат. Лямбда должна храниться всё время, что работает экземпляр интерпретатора, поэтому указатель на каждую лямбду я сохраняю внутри класса и удаляю в деструкторе. template <typename R, typename... Args> void export_function(const std::string& name, T (*function)(Args...)) { auto function = new std::function<int(Lua&)>([function](Lua& vm) -> int { auto tuple = args<Args...>(); return apply_function<std::tuple_size<decltype(tuple)>::value> ::apply(function, tuple); }); lambda(function); } Выглядит странно. Попробуем разобраться. Для начала надо получить все аргументы от интерпретатора. template <typename T, typename T1, typename... Args> std::tuple<T, T1, Args...> args(const int i = 1) { T t = arg<T>(i); return std::tuple_cat(t, args<T1, Args...>(i+1)); } Получаем i-ый аргумент и возвращаем его, а с помощью рекурсии получаем остальные аргументы. Но этого мало. Эту функцию нужно перегрузить, чтобы на последней итерации исполнялся другой код. template <typename T> std::tuple<T> args(const int i = 1) { return std::tuple<T>(arg<T>(i)); } Функция arg — очевидна, не буду её приводить, всё что требуется — написать несколько специализаций. Теперь, когда у нас есть все аргументы в одном кортеже, надо передать их все в функцию. template <int N> struct apply_function { template <typename R, typename... FunctionArgs, typename... TupleArgs, typename... Args> static R apply(R (*function)(Args...), std::tuple<TupleArgs...>, Args... args) { return apply_function<N-1>::apply(function, tuple, std::get<N-1>::value, args); } }; И нужно специализировать этот шаблон для последней итерации. template <> struct apply_function<0> { template <typename R, typename... FunctionArgs, typename... TupleArgs, typename... Args> static R apply(R (*function)(Args...), std::tuple<TupleArgs...>, Args... args) { return (*function)(args...); } }; Помимо всего этого потребуется еще несколько специализаций (проблемы в типе void). Результаты Получилась вполне рабочая обертка для экспорта C++ функций и классов в lua. Из очевидных минусов вижу всего несколько: Лямбды все-таки медленнее колбэков, при желании можно переписать код без них, но получится больше шаблонных функций. При каждом вызове функции/метода мы получаем две рекурсии, глубина которых равна количеству аргументов функций. Возможно компилятор сделает всю эту орду шаблонных функций инлайновыми, я не проверял (и не уверен в этом). Шаблоны сильно сказываются на времени компиляции. Но даже на моем довольно слабом ноутбуке сборка этой обертки и кода, который её использует, занимает гораздо меньше времени, чем сборка кода, который использует boost, так что это не критично. Нет поддержки множественного наследования — слишком муторно его делать. Нет доступа к метатаблицам, а значит нет переопределения операторов. Нет поддержки перегрузки функций, но можно просто дать перегружаемым функциям разные имена. Последние три пункта, возможно, сделаю чуть позже. А теперь плюсы: Простой интерфейс. Решение на чистом C++11, не требует генерации дополнительного кода дополнительными инструментами. Как использовать Прежде всего нужно создать объект класса util::Lua, при этом проинициализируется интерпретатор. util::Lua vm; После этого можно экспортировать функции/классы. Функции Всё просто. Мы используем только указатель на функцию и имя, под которым она будет доступна в lua. some_function(); vm.export_function(\"some_function\", &some_function); Типы всех параметров и возвращаемого значения будут определены и обработаны корректно. Классы Экспортируемый класс надо подготовить. Для начала нужно унаследовать его от util::LuaClass, чтобы при возвращении объекта интерпретатору был возвращен именно объект, а не userdata. После нужно определить три статических метода. Метод export_class должен экспортировать все методы/функции класса. Метод export_me должен вызывать функцию Lua::export_class<A, B>() Метод class_name должен возвращать имя класса. class A : public util::LuaClass { public: static void export_class(Lua& vm); static void export_me(Lua& vm); static const std::string class_name(); }; void A::export_me(Lua& vm) { vm.export_class<A>(); } class B: public A { public: static void export_class(Lua& vm); static void export_me(Lua& vm); static const std::string class_name(); }; void B::export_me(Lua& vm) { vm.export_class<B, A>(); } Функции util::Lua::export_class передаются в качестве параметров шаблона — класс, который мы хотим экспортировать и его родитель, чтобы экспортировать и его (если это еще не сделано). Самое интересное творится в методе export_class. К примеру: vm.export_constructor<A, int>(); vm.export_function(\"static_method\", &A::static_method); vm.export_method(\"method\", &A::method); Всё просто. Статические методы экспортируем как функции, методы — похожим образом, но через отдельную функцию. Конструктор экспортируется как функция с именем new, типы его аргументов необходимо указать явно в качестве аргументов шаблона, связано это с тем, что на конструктор нельзя взять указатель. Приятная вещь в том, что объекты созданные посредством вызова такого конструктора из lua будет обрабатывать Garbage Collector. Когда все ссылки на объект будут удалены будет вызван delete для объекта C++. Код Весь код выложен на гитхабе github.com/alex-ac/LuaCxx под MIT лицензией. Буду рад увидеть комментарии, советы, фичреквесты и багрепорты. UPD Чуть не забыл. Весь код собирается с помощью g++ 4.7.2, также должны работать g++ >= 4.6.4 и clang >= 3.0.", "image": [], "tag": ["C++", "C++11", "Lua", "templates", "tuple"], "rating": ["+19"], "bookmarks": ["95"], "views": ["13,5k"], "comments_count": ["4"]},
{"author": ["PerlPower"], "date": ["20 августа 2012 в 03:57"], "hubs": ["Lua"], "type_label": [], "text": "Lua: как перестать встраивать и начать жить За Lua прочно закрепилась слава полуязыка — инструмента, который при случае можно встроить, чтобы заскриптовать приложение, написанное на компилируемом языке вроде С++. Тем не менее Lua является вполне самостоятельным языком, имеющим свой интерпретатор, возможность создания модулей, большое число библиотек, и при этом данный ЯП обладает минимальным размером среди аналогов. Проще говоря у нас есть все, чтобы создавать такие же приложения как на perl, python, и вообще любом другом распространенном языке программирования. Я могу предложить вам следующие доводы в пользу Lua: — приложения будут легко переносимы между Windows и Linux (не факт что код будет работать без изменений, но портирование правда пройдет безболезненно, если не были использованы платформоспецифичные библиотеки) — малый оверхед создаваемых программ — высокая скорость работы и загрузки приложений — возможность оперативно «приклеить» к вашему приложению любую С-библиотеку — лучшего «клея» для библиотек вы не найдете — приятный минималистичный синтаксис языка, с возможностью реализации на нем современных парадигм программирования — программы на Lua очень легко развертывать — малое потребление памяти Чтобы продемонстрировать возможности Lua, я покажу как с его использованием создать небольшую программу для построения графиков по точкам с возможностью сохранения графика в виде файла изображения. В качестве графического тулкита будем использовать iup — кроссплатформенную библиотеку, изначально созданную с расчетом использования из Lua. Установка Lua SDK В рамках идеи использования Lua как самостоятельного ЯП, была создана сборка Lua for Windows, которая содержит себе библиотеки, необходимые в повседневных задачах, возникающих при программировании под указанную ОС: работы с БД, GUI, парсинг XML и т.д. Пусть вас не смущает, что версия Lua в сборке 5.1, а не 5.2 — особой разницы в нашем случае между ними нет. Скачайте и установите сборку. Краткое описание концепции iup Я долго думал, как же расписать процесс создания программы, не вдаваясь подробно в устройство iup. И решил коротко описать его основные принципы: — iup.dialog является корневым элементом интерфейса программы — в этом контейнере размещаются все элементы — позиционирование элементов в контейнере производится при помощи layout-ов: задания правил размещения элемента в контейнере. Iup сам расположит и отрисует элемент согласно правилам. Основные контейнеры — фрейм, вертикальный сайзер, горизонтальный сайзер. — обработчики событий задаются в виде функций, прикрепленных к виджету — после создания диалога запускается цикл обработки событий Если вы ранее писали для GUI при помощи Tk, WxWidgets или WinAPI, то все это покажется знакомым. Если нет, то программа довольно подробно покрыта комментариями. Код программы -- подключение библиотек iup require(\"iuplua\" ) require(\"iupluacontrols\") require(\"iuplua_pplot\") -- библиотека для работы с Canvas, чтобы сохранять график в файл require(\"cdlua\") require(\"iupluacd\") require(\"string\") -- глобальные переменные для виджетов и настроек программы -- максимальное число графиков plots_number = 5 -- виджеты вкладок, где будут размещаться виджеы ввода данных для каждого графика tabs = {} -- контейнеры для виджетов vboxes = {} -- чекбоксы для выбора того, какие графики строить checkboxes = {} -- здесь храним виджеты с текстом данных о точках coords = {} -- виджеты подписи для каждого графика legends = {} -- виджеты обозначения осей координат global_legend = {} -- к величайшему стыду, в Lua нет стандартной функции split function string:split(sep) local sep, fields = sep or \":\", {} local pattern = string.format(\"([^%s]+)\", sep) self:gsub(pattern, function(c) fields[#fields+1] = c end) return fields end -- функция рисует на плоттере график по указаным точкам function draw_plot(pwidget, pnum, data) x = data[1].value:split(\",\") y = data[2].value:split(\",\") if checkboxes[pnum].value == \"OFF\" then return end if not (#x == #y) or #x == 0 then iup.Message(\"Ошибка\", \"Задано неверное число точек для графика \" .. pnum) return end iup.PPlotBegin(pwidget, 0) iup.PPlotAdd(pwidget, 0, 0) for i = 1,#x do iup.PPlotAdd(pwidget, x[i], y[i]) end iup.PPlotEnd(pwidget) end -- виджет отвечающий за кнопку построения графика plot_btn = iup.button{ title = \"Построить\"} -- колбэк для кнопки \"построить график\" function plot_btn:action() -- создать виджет графопостроителя plot = iup.pplot { expand=\"YES\", TITLE = \"Simple Line\", MARGINBOTTOM=\"65\", MARGINLEFT=\"65\", AXS_XLABEL = global_legend[1].value, AXS_YLABEL = global_legend[2].value, LEGENDSHOW=\"YES\", LEGENDPOS=\"TOPLEFT\", size = \"400x300\" } -- этот блок для обхода бага - без него подпись к первому графику отображаться не будет iup.PPlotBegin(plot, 0) iup.PPlotAdd(plot,0,0) plot.DS_LEGEND = \"\" iup.PPlotEnd(plot) -- обходим виджеты с данными for i = 1, plots_number do -- чтобы свеженарисованный графи отобразился с правильной подписью print(legends[i].value) plot.DS_LEGEND = legends[i].value -- рисуем график draw_plot(plot, i, coords[i]) end -- кнопка сохранения графика в картинку на диске save_btn = iup.button{ title = \"Сохранить\" } -- теперь создаем само окно, где будет отображаться график plot_dg = iup.dialog { iup.vbox -- это вертикальный сайзер, помести в него графопостроитель и кнопку { plot, save_btn }, } -- обработчик кнопки сохранения графика function save_btn:action() -- создаем диалог выбора имени файла ля сохранения -- в связи с ограничениями библиотеки сохранять можно только в EMF fs_dlg = iup.filedlg{DIALOGTYPE = \"SAVE\", FILTER = \"*.emf\" } iup.Popup(fs_dlg) -- если файл выбран if tonumber(fs_dlg.STATUS) >= 0 then -- дописать при необходимости нужное расширение pic = fs_dlg.value if not (string.sub(pic, string.len(pic)-3) == \".emf\") then pic = pic .. \".emf\" end -- создаем псевдо-холст, ассоциированный с файлом tmp_cv = cd.CreateCanvas(cd.EMF, pic .. \" 400x300\") -- выводим график на холст iup.PPlotPaintTo(plot, tmp_cv) -- сохраняем данные в файл cd.KillCanvas(tmp_cv) end end -- отображаем диалог с графиком plot_dg:showxy(iup.CENTER, iup.CENTER) -- запускаем петлю обработки событий для диалога if (iup.MainLoopLevel()==0) then iup.MainLoop() end end -- в цикле создаем вкладки, в которых мы будем размещать виджеты -- для сбора данных for i=1,plots_number do -- создание текстовых виджетов, куда будут вводиться координаты точек coords[i] = {} for j = 1,2 do coords[i][j] = iup.text { expand=\"HORIZONTAL\", multiline = \"YES\", VISIBLELINES = 5 } end -- виджет для редактирования подписи к графику legends[i] = iup.text{ expand = \"HORIZONTAL\" } -- создаем контейнер вкладки и заполняем его элементами vboxes[i] = iup.vbox { iup.hbox { iup.label { title = \"Подпись графика:\" }, legends[i] }, iup.hbox { iup.label { title=\"X : \", }, coords[i][1] }, iup.hbox { iup.label { title=\"Y : \", }, coords[i][2] }; expand=\"YES\", } -- меняем заголовк вкладки vboxes[i].tabtitle = \"График \" .. i -- создаем чекбокс, который будет указывать на то, нужно ли строить -- график по данным из указанной вкладки checkboxes[i] = iup.toggle{ title= \"График\" .. i, value = \"ON\" } end -- теперь из заполненных нами контейнеров создаем вкладки tabs = iup.tabs{unpack(vboxes)} -- создаем текстовые виджеты для редактирования подписей осей global_legend[1] = iup.text{} global_legend[2] = iup.text{} -- создаем фрейм для общих настроек графика frame = iup.frame { iup.vbox { iup.label{ title=\"Использовать данные:\", expand=\"HORIZONTAL\" }, iup.vbox { unpack(checkboxes) }, iup.label{}, -- пустую подпись можно использовать как распорку iup.label{title = \"Подписи\"}, iup.hbox { iup.label{ title = \"Ось X \"}, global_legend[1] }, iup.hbox { iup.label{ title = \"Ось Y \"}, global_legend[2] }, iup.label{}, plot_btn }; expand = \"VERTICAL\", } -- создаем главное окно программы и наносим на него настройки и табы dg = iup.dialog { iup.hbox { frame, tabs }, title=\"Строим график\", size = \"HALF\" } -- показываем главное окно и запускаем обработку событий dg:showxy(iup.CENTER, iup.CENTER) if (iup.MainLoopLevel()==0) then iup.MainLoop() end Пара слов о развертывании Скрипт можно запустить при помощи команды: lua plotter.exe В данном случае библиотеки будут подключаться из поддиректории clibs/, которая находится в директории, куда был установлен Lua for Windows. Чтобы максимально компактно упаковать скрипт и библиотеки для переноса на другую машину, достаточно скопировать в одну папку следущие файлы(указаны с относительными путями от директории установки Lua): lua.exe lib/lua5.1.dll clibs/cd.dll clibs/cdlua51.dll clibs/iup.dll clibs/iup_pplot.dll clibs/iupcd.dll clibs/iupcontrols.dll clibs/iupgl.dll clibs/iuplua51.dll clibs/iuplua_pplot51.dll clibs/iupluacd51.dll clibs/iupluacontrols51.dll clibs/freetype6.dll Не забудьте поместить в эту папку и сам скрипт с программой. Теперь вы можете перенести эту папку на другую машину и запустить вашу программы командой, указанной выше. При этом никакие другие действия по установке библиотек и рантайма не нужны. К сожалению файлы cd.dll, cdluad51.dll и iupcd.dll в данной версии Lua for Windows могут работать некорректно, поэтому рекомендую взять их из архива по ссылке ниже. Итоги Архив с рабочей версией тут, для удобства добавлена пускалка app.bat. Скриншоты: В результате получили, пусть и неказистую, утилиту, имеющую такой же функционал, как и если бы она была написана на «серьезном» языке программирования. При этом простую в развертывании и суммарным весом менее 2 мб. Потребление памяти — около 7 мб. Исходный код доступен для редактирования, сам Lua интерактивно понятен, что упрощает доработку подобного софта на местах. На мой взгляд, это отличный выбор для написания учебного софта для школ и институтов, а также для внутреннего использования на предприятиях. Так как слабые машины до сих пор в изобилии присутствуют в подобных местах по всему СНГ, то использование Luа подобным образом целесообразно, особенно в свете постепнного прихода Linux на десктопы. К тому же тенденцию потери исходников самописного софта при жуткой его же забагованности можно приравнять к национальному бедствию.", "image": ["http://perlpower.16mb.com/habr/lua1.JPG", "http://perlpower.16mb.com/habr/lua2.JPG"], "tag": ["lua", "iup", "shareware", "freeware"], "rating": ["+33"], "bookmarks": ["105"], "views": ["42,4k"], "comments_count": ["42"]},
{"author": ["Nepherhotep"], "date": ["16 апреля 2013 в 10:41"], "hubs": ["Разработка под iOS", "Разработка мобильных приложений", "Lua"], "type_label": [], "text": "Дорогие друзья, сегодня я расскажу вам о фреймворке высокого уровня на Lua для мобильных платформ собственной разработки. Как вы уже, наверное, догадались из названия, этот фреймворк использует другой низкоуровней фреймворк для отрисовки графики и для взаимодействия с системой. В качество него выступает MOAI. Для минимального ознакомления с ним, я рекомендую прочитать мою предыдущую статью habrahabr.ru/post/176765 Прежде всего, какие задачи должен был решить новый фремворк? Во-первых, проблемы с фрагментацией экранов. А во-вторых (та-дам), хотелось иметь какой-то, пусть и простейший, графический редактор интерфейсов. В третьих, фреймворк должен был определить архитектуру и файловую структуру приложения в целом. Хочу сказать, что кода получилось немного (менее 600 строк), поэтому, даже если фреймворк вам не подойдет, как есть, будет несложно разобраться с его работай и заточить его под свои нужды. Warning: фреймворк заточен под landscape приложения, поэтому если вам нужен портретный режим, то скорее всего придется потратить некоторое время на доработку. Вернемся к фрагментации экранов. Чтобы решить проблему фрагментации, нужно, чтобы приложение учитывало: Разные размеры экранов Разные разрешения Разные пропорции Для того, чтобы решить все эти три задачи одним махом, Corona SDK или Gideros предлагают выбрать policy масштабирования всего приложения. Наиболее адекватный из этих режимов — так называемый letterbox. Это когда приложение равномерно масштабируется до размеров экрана, но при этом остаются черные полосы по краям в случае несовпадения пропорций. В MOAI как такового режима нет, но есть снипетс, как реализовать это в несколько строк, манипулируя параметрами viewport. Понятно, что такая полумера не может удовлетворить по-настоящему хорошее приложение. Экраны мобильных устройств и без того малы, чтобы еще их площадь съедалась черными полосами. Очевидно, что не обойтись без эластичной верстки (решаем проблему размеров/пропорций). Что касается разных разрешений экрана, то это легко решается набором разной графики или же ее масштабированием. Однако, в Android/iOS эти механизмы работают по-разному, поэтому придется реализовывать его самим. Спрайтовый графический редактор Графический редактор был написан при помощи PyQt. Он довольно прост и умеет манипулировать только спрайтами, то бишь картинками. MOAI поддерживает отображение текста, но ни графический редактор, ни Terevaka не могут его показывать. На практике это означает, что если поверх кнопки нужно нанести текст, то это нужно сделать программно после загрузки спрайта кнопки (либо нанести текст прямо на спрайт кнопки, лол). Тем не менее, графический редактор — это мощный инструмент, т. к. позволяет не только разместить элементы графически, но и отделить вид от логики программы. Графический редактор хранит файл проекта в JSON файле и экспортирует слой во внутреннее представление Terevaka (Lua файл) по принципу один файл — один слой. Слои бывают двух типов- elastic и scalable. Elastic слой при отображении размещает элементы в зависимости от сторон привязки. Т.е. если вы хотите, чтобы элемент при масштабировании следовал правому верхнему углу, то нужно указывать координаты относительно этого угла. Пример, слой в редакторе: Iphone 3.5 Inch: Iphone 4 inch: Ipad: Scalable слой — это другой тип слоя, который масштабируется пропорционально, наподобие letterbox. К примеру, главное меню имеет смысл делать именно при помощи scalable слоя, но фон, однако, лучше сделать на весь экран. Пример, слой в редакторе: Iphone 3.5 Inch: Iphone 4 Inch: Ipad: В редакторе, пропорции scalable слоя указаны фиксировано 427x320. Это пропорции айпада, уменьшенные до размера iphone. Вы можете выбрать более удобные для себя параметры, однако нужно помнить о разрешении графики, которая будет использоваться в дизайнере и непосредственно в приложении. Для себя я использую 853х640 (изменять параметр нужно прямо в исходниках графического редактора) и заливаю в редакторе retina графику. В самом приложении, как правило, использую текстуры еще более высокого разрешения, чтобы графика соотвествовала большим ретина экранам, а во время загрузки слоя указываю параметр dpiMultiplier, чтобы спрайты загрузились нужного размера. Причина по которой я захардкодил 427х320 попорции — с размерами/разрешениями легко запутаться, поэтому кто понимает что к чему, разберется, как адаптировать это под свой случай. Так, комбинируя подходы, можно довольно быстро создавать гибкую графику. Файлы со слоями хранятся в директории ./res/layout/ по аналогии с Android. Фрагментация разрешений экранов Разные разрешения экрана поддерживаются двойным набором графики. Набор графики с обычным разрешением хранится в ./res/drawable-mdpi/, а ретина — в ./res/drawable-xhdpi/. Если разрешение экрана не совпадает с одним из этих, то будет взят наиболее подходящий набор и смасштабирован. Директории ./res/drawable-ldpi и ./res/drawable-hdpi пока не поддерживаются движком. Важный момент — при загрузке слоя желательно использовать упакованные спрайты в одну текстуру для того, чтобы оптимизировать объем расходуемой памяти. В фрейворке поддерживается MOAI формат, в который умеет конвертировать платный TexturePacker. Warning: не используйте в TexturePacker упаковку текстур с удалением пустых областей, т. к. в экспортере в формат MOAI есть баг и графика в итоге поплывет. Разное Для получения спрайта из слоя используйте функцию findPropById (опять-таки аналогия с Android) Для обработки нажатия на спрайт, достаточно приаттачить специальный callback (см. пример в terevaka-samples). Другие различные примеры использования смотрите в проекте terevaka-samples. Чтобы запустить пример, скопируйте tereavaka в папку примера, а еще лучше — сделайте в нее симлинк. Чтобы протестировать приложение под разными экранами, вовсе не нужно много разных устройств — используйте профили запуска. Готовые профили лежат в каталоге ./terevaka/profiles. Для запуска с профилем, используйте команду moai ./terevaka/profiles/ipad.lua main.lua, где ipad.lua — профиль айпада. В профиле как правило 3-4 строки, вы можете с легкостью создать свои профили. Спрайты для ui builder нужно сохранять в разрешении mdpi. Резюме Изначально проект начинался, как выделение некого общего кода из кода моей новой игры. В попытке структурировать, как сам код, так и требования к нему, привели к появлению фреймворка, а затем, используя мои старые наработки, и графического дизайнера к нему. Помимо этого, пришлось дорабатывать и сам MOAI, однако благодаря быстрому отклику его разработчиков, все изменения уже внесены в основной репозиторий. Также — это показательный опыт, что не нужно боятся писать свои библиотеки, если четко понимаете требования к ним, а также если пишете на скриптовом языке :) Ссылки Terevaka: github.com/Nepherhotep/terevaka Samples: github.com/Nepherhotep/terevaka-samples UI Builder: github.com/Nepherhotep/terevaka-ui-builder Official MOAI: github.com/moai/moai-dev My fork: github.com/Nepherhotep/moai-dev", "image": ["https://habrastorage.org/storage2/e93/011/68f/e9301168fc7dce2c0c8a2fca2b63c1a1.png", "https://habrastorage.org/storage2/670/e53/001/670e5300144d8992b508f0c28b454f95.png", "https://habrastorage.org/storage2/02c/41e/889/02c41e8897e53c12dea0985567bf3542.png", "https://habrastorage.org/storage2/a3b/4b6/1da/a3b4b61da7d2545bf291953f0da4ac76.png", "https://habrastorage.org/storage2/076/596/040/07659604058831bde0556ea48d932752.png", "https://habrastorage.org/storage2/787/242/5b7/7872425b7b4ff7a9a223cbb14bd94bf6.png", "https://habrastorage.org/storage2/591/beb/280/591beb2801fe373ca16010425ee1ba03.png", "https://habrastorage.org/storage2/b62/4ba/47b/b624ba47ba5a46040a43da9c73e16b93.png"], "tag": ["moai sdk", "terevaka", "mobile development", "lua", "ios", "android"], "rating": ["+8"], "bookmarks": ["36"], "views": ["6,8k"], "comments_count": []},
{"author": ["akamajoris"], "date": ["17 апреля 2013 в 18:38"], "hubs": ["MySQL", "Lua"], "type_label": ["Tutorial"], "text": "Разбираясь как работает та или иная CMS приходится использовать различные инструменты, облегчающие работу. Наиболее интересная тема — это работа с баз(ой|ами) данных. Естественно для изучения запросов и результатов запросов нужно использовать что-то универсальное. Что-то, что будет работать стабильно как с известным движком, так и с самописной системой. Предположим у вас оказалась система управления контентом и вам необходимо посмотреть как реализовано добавление новых пользователей или смена паролей. Большинство инструментов позволяющих мониторить работу с БД являются платными [раз, два]. Я хотел что-то более легкое и удобное, поэтому выбрал mysql-proxy. Хотя возможности утилиты гораздо шире чем мне требуется, я опишу лишь основное. Работает как под Windows, так и под Unix системами. Скачать можно тут: dev.mysql.com/downloads/mysql-proxy Первым делом нужно определиться с выбором дистрибутива. На данный момент новейшей версией является «MySQL Proxy 0.8.3 alpha», в качестве ОС у меня стоит Windows 7, поэтому все тесты будут на ней. После нажатия на кнопку «Download» вас попросят авторизироваться либо зарегистрировать, но снизу есть ссылка для скачивания без лишних действий. (В репозиториях Ubuntu и Debian есть готовые пакеты, так что: sudo apt-get install mysql-proxy) Хочу заметить, что при размере в 7.9Мб в дистрибутив входит Lua с поддержкой основых модулей. После скачивания архива его нужно распаковать в удобную для вас директорию, возьмем для примера C:\\mysql-proxy Для запуска приложения нужно определиться с параметрами. В данном контексте многое зависит от того, что у вас установлено. В качестве LAMP я использую Winginx, прочитать об этой связке можно тут: winginx.ru По умолчанию MySQL работает на 3306 порту, его мы трогать не будем. Нам нужно изменить порт для подключения php к базе. Для этого необходимо поправить php.ini Найдем строку «mysql.default_port» и установим порт (по умолчанию 4040). Для более универсальной работы измените и «mysqli.default_port» на 4040 Подготовительная часть пройдена, перейдем к делу. Вариант 1. Мониторинг запросов. Для простого мониторинга необходимо использовать Lua скрипт. Как я уже говорил Lua идет в комплекте, так что ничего нового устанавливать не надо. Создадим простой скрипт view.lua в директории C:\\mysql-proxy\\ с содержимым: function read_query(packet) if string.byte(packet) == proxy.COM_QUERY then print(string.sub(packet, 2)) end end Теперь можно проверить результат. Для удобства создадим в директории C:\\mysql-proxy файл view.bat c содержимым: C:\\mysql-proxy\\bin\\mysql-proxy.exe --proxy-lua-script=C:\\mysql-proxy\\view.lua --log-file=\"C:\\mysql-proxy\\mysql-proxy-log.txt\" --proxy-backend-addresses=localhost:3306 --proxy-backend-addresses — адрес MySQL сервера на который будем проксировать запрос. Запустив вэб-сервер и выполнив какие либо запросы к базе можете увидеть такое: Запросы отображаются, хорошо. Вариант 2. Мониторинг запросов и запись в файл. Для записи запросов в файл будем использовать штатные возможности Lua. Создадим файл view-write.lua в директории C:\\mysql-proxy\\ с содержимым: function read_query(packet) if string.byte(packet) == proxy.COM_QUERY then local file = io.open(\"C:\\\\mysql-proxy\\\\sql-log.txt\", \"a\") file:write(string.sub(packet, 2) .. \"\\n\") file:close() print(string.sub(packet, 2)) end end и bat файл — «view-write.bat» C:\\mysql-proxy\\bin\\mysql-proxy.exe --proxy-lua-script=\"C:\\mysql-proxy\\view-write.lua\" --log-file=\"C:\\mysql-proxy\\mysql-proxy-log.txt\" --proxy-backend-addresses=localhost:3306 Результат после выполнения запросов (по адресу «C:\\mysql-proxy\\sql-log.txt») Помимо отображения самих запросов, нам может понадобиться вывод результатов этих запросов. Вариант 3. Запросы и результат По той-же схеме создаём скрипт «view-result.lua»: function read_query( packet ) if packet:byte() == proxy.COM_QUERY then print(\"Query: \" .. string.sub(packet, 2)) local file = io.open(\"C:\\\\mysql-proxy\\\\sql-log.txt\", \"a\") file:write(\"Query: \" .. string.sub(packet, 2) .. \"\\n\") file:close() proxy.queries:append(2, string.char(proxy.COM_QUERY) .. string.sub(packet, 2), {resultset_is_needed = true} ) proxy.queries:append(1, packet, {resultset_is_needed = true}) return proxy.PROXY_SEND_QUERY end end function read_query_result(inj) if inj.id == 1 then for row in inj.resultset.rows do local i = 1 local fields = {} while row[i] do if row[i] == row then break end local file = io.open(\"C:\\\\mysql-proxy\\\\sql-log.txt\", \"a\") file:write(\"Response field: \" .. inj.resultset.fields[i].name .. \" => \" .. row[i] .. \"\\n\") file:close() print(\"Response field: \" .. inj.resultset.fields[i].name .. \" => \" .. row[i]) i = i + 1 end end return proxy.PROXY_IGNORE_RESULT end end И view-result.bat C:\\mysql-proxy\\bin\\mysql-proxy.exe --proxy-lua-script=\"C:\\mysql-proxy\\view-result.lua\" --log-file=\"C:\\mysql-proxy\\mysql-proxy-log.txt\" --proxy-backend-addresses=localhost:3306 В результате получаем полное логирование запросов и ответов в читаемом виде", "image": ["https://habrastorage.org/getpro/habr/post_images/2aa/c5d/7d8/2aac5d7d8b7a05abbc33ca261fdc13cc.jpg", "https://habrastorage.org/getpro/habr/post_images/e4c/8cd/ba8/e4c8cdba83263d9762a3775d39e8d129.jpg", "https://habrastorage.org/getpro/habr/post_images/f31/023/199/f31023199288a705f9596cccb1bff2d2.jpg", "https://habrastorage.org/getpro/habr/post_images/335/93c/6e0/33593c6e0ba51424e8d0bd166b836154.jpg", "https://habrastorage.org/getpro/habr/post_images/0c3/2d0/aa2/0c32d0aa2b87d7b3f735059dc9ee4a65.jpg", "https://habrastorage.org/getpro/habr/post_images/aac/52d/cd0/aac52dcd073c1706ba1d34eb973fbb0f.jpg"], "tag": ["mysql proxy", "анализ запросов", "монитор sql"], "rating": ["+28"], "bookmarks": ["370"], "views": ["30,4k"], "comments_count": ["31"]},
{"author": ["zm33y"], "date": ["19 февраля 2013 в 15:07"], "hubs": ["Разработка веб-сайтов", "Lua"], "type_label": [], "text": "Очень уж мне нравится смотреть сериалы, а еще я учу с их помощью языки. И если раньше я прилежно останавливал видео на непонятном месте, перематывал назад, включал субтитры и забивал незнакомые слова в Анки, то сейчас я делаю то же самое. Разве что лень заставила этот процесс автоматизировать, что привело к созданию расширения Say It Again для проигрывателя VLC со следующими особенностями: Навигация по субтитрам (переход к предыдущей, следующей фразе) — клавиши y, u; Сохранение слова, его транскрипции и перевода вместе с контекстом (см. скриншот) — клавиша i; Функция «Еще раз»: переход к предыдущей фразе, показ субтитра и пауза — клавиша backspace; Подключение любых словарей в формате Stardict (в сети лежат словари из Lingvo x3); Экспорт в Anki или другую программу, понимающую файлы в формате csv; Но зачем? В какой-то момент я понял, что просмотр сериалов с включенными субтитрами перестал давать ощутимые плоды (кроме повышения скорочтения). Но, выключая субтитры, я сталкивался со шквалом непонятных слов. Приходилось отматывать видео назад (конечно же либо недостаточно, либо слишком далеко от нужного места), включать субтитры, останавливать проигрывание, искать в словаре незнакомые слова, выписывать их в отдельный файлик, потом забивать в Анки (порой с контекстом, т.е. с фразой из фильма!) — в общем, геморрой. Отсюда и родилась идея расширения, которым я пользуюсь сегодня, и которым хочу поделиться с общественностью. Оно позволяет автоматизировать процесс сохранения слов с контекстом в текстовый файл такого вида: Пример файла экспортаdesecrate [ˈdesɪkreɪt] оскорблять, осквернять, позорить You've desecrated my owls. Weeds S07E12 Как этим пользоваться? На самом деле не самый user-friendly процесс, но тут уж ничего не поделаешь. Скрипт проверялся на VLC 2.0.5 под Windows. Скачиваем последнюю версию скрипта say_it_again.lua с Гитхаба (прямая ссылка) Копируем его, в зависимости от платформы, в %ProgramFiles%\\VideoLAN\\VLC\\lua\\extensions или /usr/share/vlc/lua/extensions. Ищем и качаем словарь в формате Stardict (копирайт? не, не слышал). Лично мне нравятся англо-английские словари Oxford American Dictionary. Распаковываем его. В результате должны получиться три файла на словарь: *.idx, *.dict, *.ifo. Если вместо *.dict у нас есть *.dz, то распаковываем его тоже — это обычный zip. Скачиваем базы WordNet и также распаковываем их куда-нибудь. Редактируем say_it_again.lua, изменяя dict_dir, wordnet_dir, chosen_dict. Пример настроек Запускаем VLC, открываем файл видео, рядом с которым лежит файл субтитров в формате srt; включаем в меню View — Say It Again. Voilà — используем кнопки y, u, i и backspace для соответствующих действий (см. выше) Можно обойтись без словарей (dict_dir = nil, chosen_dict = nil), но тогда значение слова придется забивать руками, и не будет транскрипции — смысл автоматизации теряется. Также можно не подключать wordnet (wordnet_dir = nil), но тогда не будет работать нормализация слов — по слову was не найдет в словаре глагол be. Технический аспект — VLC и Lua Начиная, кажется, с версии 1.1, проигрыватель VLC позволяет расширять свою функциональность с помощью скриптов на Lua. Для этого расширение должно удовлетворять определенным требованиям (некоторые не обязательны, но VLC будет ругаться): Возвращать свое описание в виде таблицы функцией descriptor(). Формат таблицы можно посмотреть в готовых скриптах в хранилище аддонов vlc; Иметь функции activate(), deactivate(); В зависимости от capabilities, указанных в таблице с описанием, нужны функции input_changed(), meta_changed(), menu(), trigger_menu(); Максимум может быть одно диалоговое окно на расширение. Хак с удалением и пересозданием диалога заново ведет к вылетаниям VLC. Вообще надо сказать, что механизм расширений довольно сырой, и VLC падает без предупреждения буквально от любого чиха. Вот некоторые моменты, которые я для себя отметил: Чтобы обрабатывать периодические события вместо поллинга лучше подписаться на событие intf-event. Обработчик колбэка должен быть «коротким», т.е. в нем не должно быть времязатратных операций. С учетом того, что параллелизм в и без того склонную к падениям систему я вносить не хотел, то пришлось изобретать небольшой хак: в начале хендлера отписываться от событий, а в конце подписываться вновь. А вообще корутины (coroutines) работают. Лучший способ иметь несколько разных диалогов, что я нашел, — это очищать текущий и наполнять его контролами в зависимости от задачи. Работа с форматами Stardict и WordNet, а также экспорт в Anki Описание форматов Stardict и WordNet привела Bienne в своей статье, поэтому повторяться не буду. Экспорт в Anki работает через csv-файл. Последовательность полей в нем захардкожена в соответствии со следующей моделью карточек (или, как это сейчас называется, Note Type): Посмотреть скриншоты Процесс импорта: Эпилог Расширение создавалось под собственные нужды, и его концепция менялась в процессе написания и использования. Отсюда следует немного хаотичный код и отпугивающий внешний вид. Тем не менее, я надеюсь, что кому-нибудь данные разработки покажутся интересными. Upd Теперь работает на Линуксе (проверено в Ubuntu 12.10 64bit; vlc 2.0.5).", "image": ["https://habrastorage.org/storage2/d35/861/1c1/d358611c188d31d6507b72ef28b705c9.png", "https://habrastorage.org/storage2/c56/86c/330/c5686c330959eb617d40cef9b3d96998.png", "https://habrastorage.org/storage2/666/898/8d9/6668988d997ec68c5728a22ccca51f0a.png", "https://habrastorage.org/storage2/ca0/6a9/6eb/ca06a96eb53cc884bb491ac42ee7756e.png", "https://habrastorage.org/storage2/8e9/985/54d/8e998554d9a55a28283e8a561abc09ab.png", "https://habrastorage.org/storage2/25a/7c6/648/25a7c6648ecf4d8a70090aa1f915e8ab.png"], "tag": ["vlc", "lua", "stardict", "wordnet", "anki", "английский язык", "английский", "иностранные языки", "изучение иностранных языков"], "rating": ["+108"], "bookmarks": ["1138"], "views": ["118k"], "comments_count": ["55"]}
]